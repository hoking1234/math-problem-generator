"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@google";
exports.ids = ["vendor-chunks/@google"];
exports.modules = {

/***/ "(rsc)/./node_modules/@google/genai/dist/node/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@google/genai/dist/node/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActivityHandling: () => (/* binding */ ActivityHandling),\n/* harmony export */   AdapterSize: () => (/* binding */ AdapterSize),\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   ApiSpec: () => (/* binding */ ApiSpec),\n/* harmony export */   AuthType: () => (/* binding */ AuthType),\n/* harmony export */   Batches: () => (/* binding */ Batches),\n/* harmony export */   Behavior: () => (/* binding */ Behavior),\n/* harmony export */   BlockedReason: () => (/* binding */ BlockedReason),\n/* harmony export */   Caches: () => (/* binding */ Caches),\n/* harmony export */   Chat: () => (/* binding */ Chat),\n/* harmony export */   Chats: () => (/* binding */ Chats),\n/* harmony export */   ComputeTokensResponse: () => (/* binding */ ComputeTokensResponse),\n/* harmony export */   ContentReferenceImage: () => (/* binding */ ContentReferenceImage),\n/* harmony export */   ControlReferenceImage: () => (/* binding */ ControlReferenceImage),\n/* harmony export */   ControlReferenceType: () => (/* binding */ ControlReferenceType),\n/* harmony export */   CountTokensResponse: () => (/* binding */ CountTokensResponse),\n/* harmony export */   CreateFileResponse: () => (/* binding */ CreateFileResponse),\n/* harmony export */   DeleteCachedContentResponse: () => (/* binding */ DeleteCachedContentResponse),\n/* harmony export */   DeleteFileResponse: () => (/* binding */ DeleteFileResponse),\n/* harmony export */   DeleteModelResponse: () => (/* binding */ DeleteModelResponse),\n/* harmony export */   DynamicRetrievalConfigMode: () => (/* binding */ DynamicRetrievalConfigMode),\n/* harmony export */   EditImageResponse: () => (/* binding */ EditImageResponse),\n/* harmony export */   EditMode: () => (/* binding */ EditMode),\n/* harmony export */   EmbedContentResponse: () => (/* binding */ EmbedContentResponse),\n/* harmony export */   EndSensitivity: () => (/* binding */ EndSensitivity),\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   FeatureSelectionPreference: () => (/* binding */ FeatureSelectionPreference),\n/* harmony export */   FileSource: () => (/* binding */ FileSource),\n/* harmony export */   FileState: () => (/* binding */ FileState),\n/* harmony export */   Files: () => (/* binding */ Files),\n/* harmony export */   FinishReason: () => (/* binding */ FinishReason),\n/* harmony export */   FunctionCallingConfigMode: () => (/* binding */ FunctionCallingConfigMode),\n/* harmony export */   FunctionResponse: () => (/* binding */ FunctionResponse),\n/* harmony export */   FunctionResponseBlob: () => (/* binding */ FunctionResponseBlob),\n/* harmony export */   FunctionResponseFileData: () => (/* binding */ FunctionResponseFileData),\n/* harmony export */   FunctionResponsePart: () => (/* binding */ FunctionResponsePart),\n/* harmony export */   FunctionResponseScheduling: () => (/* binding */ FunctionResponseScheduling),\n/* harmony export */   GenerateContentResponse: () => (/* binding */ GenerateContentResponse),\n/* harmony export */   GenerateContentResponsePromptFeedback: () => (/* binding */ GenerateContentResponsePromptFeedback),\n/* harmony export */   GenerateContentResponseUsageMetadata: () => (/* binding */ GenerateContentResponseUsageMetadata),\n/* harmony export */   GenerateImagesResponse: () => (/* binding */ GenerateImagesResponse),\n/* harmony export */   GenerateVideosOperation: () => (/* binding */ GenerateVideosOperation),\n/* harmony export */   GenerateVideosResponse: () => (/* binding */ GenerateVideosResponse),\n/* harmony export */   GoogleGenAI: () => (/* binding */ GoogleGenAI),\n/* harmony export */   HarmBlockMethod: () => (/* binding */ HarmBlockMethod),\n/* harmony export */   HarmBlockThreshold: () => (/* binding */ HarmBlockThreshold),\n/* harmony export */   HarmCategory: () => (/* binding */ HarmCategory),\n/* harmony export */   HarmProbability: () => (/* binding */ HarmProbability),\n/* harmony export */   HarmSeverity: () => (/* binding */ HarmSeverity),\n/* harmony export */   HttpResponse: () => (/* binding */ HttpResponse),\n/* harmony export */   ImagePromptLanguage: () => (/* binding */ ImagePromptLanguage),\n/* harmony export */   InlinedEmbedContentResponse: () => (/* binding */ InlinedEmbedContentResponse),\n/* harmony export */   InlinedResponse: () => (/* binding */ InlinedResponse),\n/* harmony export */   JobState: () => (/* binding */ JobState),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   ListBatchJobsResponse: () => (/* binding */ ListBatchJobsResponse),\n/* harmony export */   ListCachedContentsResponse: () => (/* binding */ ListCachedContentsResponse),\n/* harmony export */   ListFilesResponse: () => (/* binding */ ListFilesResponse),\n/* harmony export */   ListModelsResponse: () => (/* binding */ ListModelsResponse),\n/* harmony export */   ListTuningJobsResponse: () => (/* binding */ ListTuningJobsResponse),\n/* harmony export */   Live: () => (/* binding */ Live),\n/* harmony export */   LiveClientToolResponse: () => (/* binding */ LiveClientToolResponse),\n/* harmony export */   LiveMusicPlaybackControl: () => (/* binding */ LiveMusicPlaybackControl),\n/* harmony export */   LiveMusicServerMessage: () => (/* binding */ LiveMusicServerMessage),\n/* harmony export */   LiveSendToolResponseParameters: () => (/* binding */ LiveSendToolResponseParameters),\n/* harmony export */   LiveServerMessage: () => (/* binding */ LiveServerMessage),\n/* harmony export */   MaskReferenceImage: () => (/* binding */ MaskReferenceImage),\n/* harmony export */   MaskReferenceMode: () => (/* binding */ MaskReferenceMode),\n/* harmony export */   MediaModality: () => (/* binding */ MediaModality),\n/* harmony export */   MediaResolution: () => (/* binding */ MediaResolution),\n/* harmony export */   Modality: () => (/* binding */ Modality),\n/* harmony export */   Mode: () => (/* binding */ Mode),\n/* harmony export */   Models: () => (/* binding */ Models),\n/* harmony export */   MusicGenerationMode: () => (/* binding */ MusicGenerationMode),\n/* harmony export */   Operations: () => (/* binding */ Operations),\n/* harmony export */   Outcome: () => (/* binding */ Outcome),\n/* harmony export */   PagedItem: () => (/* binding */ PagedItem),\n/* harmony export */   Pager: () => (/* binding */ Pager),\n/* harmony export */   PersonGeneration: () => (/* binding */ PersonGeneration),\n/* harmony export */   RawReferenceImage: () => (/* binding */ RawReferenceImage),\n/* harmony export */   RecontextImageResponse: () => (/* binding */ RecontextImageResponse),\n/* harmony export */   ReplayResponse: () => (/* binding */ ReplayResponse),\n/* harmony export */   SafetyFilterLevel: () => (/* binding */ SafetyFilterLevel),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   SegmentImageResponse: () => (/* binding */ SegmentImageResponse),\n/* harmony export */   SegmentMode: () => (/* binding */ SegmentMode),\n/* harmony export */   Session: () => (/* binding */ Session),\n/* harmony export */   SingleEmbedContentResponse: () => (/* binding */ SingleEmbedContentResponse),\n/* harmony export */   StartSensitivity: () => (/* binding */ StartSensitivity),\n/* harmony export */   StyleReferenceImage: () => (/* binding */ StyleReferenceImage),\n/* harmony export */   SubjectReferenceImage: () => (/* binding */ SubjectReferenceImage),\n/* harmony export */   SubjectReferenceType: () => (/* binding */ SubjectReferenceType),\n/* harmony export */   Tokens: () => (/* binding */ Tokens),\n/* harmony export */   TrafficType: () => (/* binding */ TrafficType),\n/* harmony export */   TuningMode: () => (/* binding */ TuningMode),\n/* harmony export */   TuningTask: () => (/* binding */ TuningTask),\n/* harmony export */   TurnCompleteReason: () => (/* binding */ TurnCompleteReason),\n/* harmony export */   TurnCoverage: () => (/* binding */ TurnCoverage),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   UpscaleImageResponse: () => (/* binding */ UpscaleImageResponse),\n/* harmony export */   UrlRetrievalStatus: () => (/* binding */ UrlRetrievalStatus),\n/* harmony export */   VideoCompressionQuality: () => (/* binding */ VideoCompressionQuality),\n/* harmony export */   VideoGenerationMaskMode: () => (/* binding */ VideoGenerationMaskMode),\n/* harmony export */   VideoGenerationReferenceType: () => (/* binding */ VideoGenerationReferenceType),\n/* harmony export */   createModelContent: () => (/* binding */ createModelContent),\n/* harmony export */   createPartFromBase64: () => (/* binding */ createPartFromBase64),\n/* harmony export */   createPartFromCodeExecutionResult: () => (/* binding */ createPartFromCodeExecutionResult),\n/* harmony export */   createPartFromExecutableCode: () => (/* binding */ createPartFromExecutableCode),\n/* harmony export */   createPartFromFunctionCall: () => (/* binding */ createPartFromFunctionCall),\n/* harmony export */   createPartFromFunctionResponse: () => (/* binding */ createPartFromFunctionResponse),\n/* harmony export */   createPartFromText: () => (/* binding */ createPartFromText),\n/* harmony export */   createPartFromUri: () => (/* binding */ createPartFromUri),\n/* harmony export */   createUserContent: () => (/* binding */ createUserContent),\n/* harmony export */   mcpToTool: () => (/* binding */ mcpToTool),\n/* harmony export */   setDefaultBaseUrls: () => (/* binding */ setDefaultBaseUrls)\n/* harmony export */ });\n/* harmony import */ var google_auth_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n\n\n\n\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ let _defaultBaseGeminiUrl = undefined;\nlet _defaultBaseVertexUrl = undefined;\n/**\n * Overrides the base URLs for the Gemini API and Vertex AI API.\n *\n * @remarks This function should be called before initializing the SDK. If the\n * base URLs are set after initializing the SDK, the base URLs will not be\n * updated. Base URLs provided in the HttpOptions will also take precedence over\n * URLs set here.\n *\n * @example\n * ```ts\n * import {GoogleGenAI, setDefaultBaseUrls} from '@google/genai';\n * // Override the base URL for the Gemini API.\n * setDefaultBaseUrls({geminiUrl:'https://gemini.google.com'});\n *\n * // Override the base URL for the Vertex AI API.\n * setDefaultBaseUrls({vertexUrl: 'https://vertexai.googleapis.com'});\n *\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n */ function setDefaultBaseUrls(baseUrlParams) {\n    _defaultBaseGeminiUrl = baseUrlParams.geminiUrl;\n    _defaultBaseVertexUrl = baseUrlParams.vertexUrl;\n}\n/**\n * Returns the default base URLs for the Gemini API and Vertex AI API.\n */ function getDefaultBaseUrls() {\n    return {\n        geminiUrl: _defaultBaseGeminiUrl,\n        vertexUrl: _defaultBaseVertexUrl\n    };\n}\n/**\n * Returns the default base URL based on the following priority:\n *   1. Base URLs set via HttpOptions.\n *   2. Base URLs set via the latest call to setDefaultBaseUrls.\n *   3. Base URLs set via environment variables.\n */ function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {\n    var _a, _b;\n    if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {\n        const defaultBaseUrls = getDefaultBaseUrls();\n        if (vertexai) {\n            return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;\n        } else {\n            return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;\n        }\n    }\n    return httpOptions.baseUrl;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class BaseModule {\n}\nfunction formatMap(templateString, valueMap) {\n    // Use a regular expression to find all placeholders in the template string\n    const regex = /\\{([^}]+)\\}/g;\n    // Replace each placeholder with its corresponding value from the valueMap\n    return templateString.replace(regex, (match, key)=>{\n        if (Object.prototype.hasOwnProperty.call(valueMap, key)) {\n            const value = valueMap[key];\n            // Convert the value to a string if it's not a string already\n            return value !== undefined && value !== null ? String(value) : \"\";\n        } else {\n            // Handle missing keys\n            throw new Error(`Key '${key}' not found in valueMap.`);\n        }\n    });\n}\nfunction setValueByPath(data, keys, value) {\n    for(let i = 0; i < keys.length - 1; i++){\n        const key = keys[i];\n        if (key.endsWith(\"[]\")) {\n            const keyName = key.slice(0, -2);\n            if (!(keyName in data)) {\n                if (Array.isArray(value)) {\n                    data[keyName] = Array.from({\n                        length: value.length\n                    }, ()=>({}));\n                } else {\n                    throw new Error(`Value must be a list given an array path ${key}`);\n                }\n            }\n            if (Array.isArray(data[keyName])) {\n                const arrayData = data[keyName];\n                if (Array.isArray(value)) {\n                    for(let j = 0; j < arrayData.length; j++){\n                        const entry = arrayData[j];\n                        setValueByPath(entry, keys.slice(i + 1), value[j]);\n                    }\n                } else {\n                    for (const d of arrayData){\n                        setValueByPath(d, keys.slice(i + 1), value);\n                    }\n                }\n            }\n            return;\n        } else if (key.endsWith(\"[0]\")) {\n            const keyName = key.slice(0, -3);\n            if (!(keyName in data)) {\n                data[keyName] = [\n                    {}\n                ];\n            }\n            const arrayData = data[keyName];\n            setValueByPath(arrayData[0], keys.slice(i + 1), value);\n            return;\n        }\n        if (!data[key] || typeof data[key] !== \"object\") {\n            data[key] = {};\n        }\n        data = data[key];\n    }\n    const keyToSet = keys[keys.length - 1];\n    const existingData = data[keyToSet];\n    if (existingData !== undefined) {\n        if (!value || typeof value === \"object\" && Object.keys(value).length === 0) {\n            return;\n        }\n        if (value === existingData) {\n            return;\n        }\n        if (typeof existingData === \"object\" && typeof value === \"object\" && existingData !== null && value !== null) {\n            Object.assign(existingData, value);\n        } else {\n            throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);\n        }\n    } else {\n        if (keyToSet === \"_self\" && typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n            const valueAsRecord = value;\n            Object.assign(data, valueAsRecord);\n        } else {\n            data[keyToSet] = value;\n        }\n    }\n}\nfunction getValueByPath(data, keys) {\n    try {\n        if (keys.length === 1 && keys[0] === \"_self\") {\n            return data;\n        }\n        for(let i = 0; i < keys.length; i++){\n            if (typeof data !== \"object\" || data === null) {\n                return undefined;\n            }\n            const key = keys[i];\n            if (key.endsWith(\"[]\")) {\n                const keyName = key.slice(0, -2);\n                if (keyName in data) {\n                    const arrayData = data[keyName];\n                    if (!Array.isArray(arrayData)) {\n                        return undefined;\n                    }\n                    return arrayData.map((d)=>getValueByPath(d, keys.slice(i + 1)));\n                } else {\n                    return undefined;\n                }\n            } else {\n                data = data[key];\n            }\n        }\n        return data;\n    } catch (error) {\n        if (error instanceof TypeError) {\n            return undefined;\n        }\n        throw error;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function tBytes$1(fromBytes) {\n    if (typeof fromBytes !== \"string\") {\n        throw new Error(\"fromImageBytes must be a string\");\n    }\n    // TODO(b/389133914): Remove dummy bytes converter.\n    return fromBytes;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction fetchPredictOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"operationName\"\n        ], fromOperationName);\n    }\n    const fromResourceName = getValueByPath(fromObject, [\n        \"resourceName\"\n    ]);\n    if (fromResourceName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"resourceName\"\n        ], fromResourceName);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\",\n        \"generateVideoResponse\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromVertex$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"generatedSamples\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"videos\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromMldev$1(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromVertex$1(fromVideo));\n    }\n    return toObject;\n}\nfunction getOperationParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    return toObject;\n}\nfunction getOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    return toObject;\n}\nfunction videoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"video\",\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"video\",\n        \"encodedVideo\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"encoding\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /** Required. Outcome of the code execution. */ var Outcome;\n(function(Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */ Outcome[\"OUTCOME_UNSPECIFIED\"] = \"OUTCOME_UNSPECIFIED\";\n    /**\n     * Code execution completed successfully.\n     */ Outcome[\"OUTCOME_OK\"] = \"OUTCOME_OK\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the reason.\n     */ Outcome[\"OUTCOME_FAILED\"] = \"OUTCOME_FAILED\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not be a partial output present.\n     */ Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"OUTCOME_DEADLINE_EXCEEDED\";\n})(Outcome || (Outcome = {}));\n/** Required. Programming language of the `code`. */ var Language;\n(function(Language) {\n    /**\n     * Unspecified language. This value should not be used.\n     */ Language[\"LANGUAGE_UNSPECIFIED\"] = \"LANGUAGE_UNSPECIFIED\";\n    /**\n     * Python >= 3.10, with numpy and simpy available.\n     */ Language[\"PYTHON\"] = \"PYTHON\";\n})(Language || (Language = {}));\n/** Optional. The type of the data. */ var Type;\n(function(Type) {\n    /**\n     * Not specified, should not be used.\n     */ Type[\"TYPE_UNSPECIFIED\"] = \"TYPE_UNSPECIFIED\";\n    /**\n     * OpenAPI string type\n     */ Type[\"STRING\"] = \"STRING\";\n    /**\n     * OpenAPI number type\n     */ Type[\"NUMBER\"] = \"NUMBER\";\n    /**\n     * OpenAPI integer type\n     */ Type[\"INTEGER\"] = \"INTEGER\";\n    /**\n     * OpenAPI boolean type\n     */ Type[\"BOOLEAN\"] = \"BOOLEAN\";\n    /**\n     * OpenAPI array type\n     */ Type[\"ARRAY\"] = \"ARRAY\";\n    /**\n     * OpenAPI object type\n     */ Type[\"OBJECT\"] = \"OBJECT\";\n    /**\n     * Null type\n     */ Type[\"NULL\"] = \"NULL\";\n})(Type || (Type = {}));\n/** Required. Harm category. */ var HarmCategory;\n(function(HarmCategory) {\n    /**\n     * The harm category is unspecified.\n     */ HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    /**\n     * The harm category is hate speech.\n     */ HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    /**\n     * The harm category is dangerous content.\n     */ HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n    /**\n     * The harm category is harassment.\n     */ HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    /**\n     * The harm category is sexually explicit content.\n     */ HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    /**\n     * Deprecated: Election filter is not longer supported. The harm category is civic integrity.\n     */ HarmCategory[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n    /**\n     * The harm category is image hate.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_HATE\"] = \"HARM_CATEGORY_IMAGE_HATE\";\n    /**\n     * The harm category is image dangerous content.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\";\n    /**\n     * The harm category is image harassment.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_HARASSMENT\"] = \"HARM_CATEGORY_IMAGE_HARASSMENT\";\n    /**\n     * The harm category is image sexually explicit content.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\";\n})(HarmCategory || (HarmCategory = {}));\n/** Optional. Specify if the threshold is used for probability or severity score. If not specified, the threshold is used for probability score. */ var HarmBlockMethod;\n(function(HarmBlockMethod) {\n    /**\n     * The harm block method is unspecified.\n     */ HarmBlockMethod[\"HARM_BLOCK_METHOD_UNSPECIFIED\"] = \"HARM_BLOCK_METHOD_UNSPECIFIED\";\n    /**\n     * The harm block method uses both probability and severity scores.\n     */ HarmBlockMethod[\"SEVERITY\"] = \"SEVERITY\";\n    /**\n     * The harm block method uses the probability score.\n     */ HarmBlockMethod[\"PROBABILITY\"] = \"PROBABILITY\";\n})(HarmBlockMethod || (HarmBlockMethod = {}));\n/** Required. The harm block threshold. */ var HarmBlockThreshold;\n(function(HarmBlockThreshold) {\n    /**\n     * Unspecified harm block threshold.\n     */ HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Block low threshold and above (i.e. block more).\n     */ HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Block medium threshold and above.\n     */ HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Block only high threshold (i.e. block less).\n     */ HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    /**\n     * Block none.\n     */ HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n    /**\n     * Turn off the safety filter.\n     */ HarmBlockThreshold[\"OFF\"] = \"OFF\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/** The mode of the predictor to be used in dynamic retrieval. */ var Mode;\n(function(Mode) {\n    /**\n     * Always trigger retrieval.\n     */ Mode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */ Mode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(Mode || (Mode = {}));\n/** Type of auth scheme. */ var AuthType;\n(function(AuthType) {\n    AuthType[\"AUTH_TYPE_UNSPECIFIED\"] = \"AUTH_TYPE_UNSPECIFIED\";\n    /**\n     * No Auth.\n     */ AuthType[\"NO_AUTH\"] = \"NO_AUTH\";\n    /**\n     * API Key Auth.\n     */ AuthType[\"API_KEY_AUTH\"] = \"API_KEY_AUTH\";\n    /**\n     * HTTP Basic Auth.\n     */ AuthType[\"HTTP_BASIC_AUTH\"] = \"HTTP_BASIC_AUTH\";\n    /**\n     * Google Service Account Auth.\n     */ AuthType[\"GOOGLE_SERVICE_ACCOUNT_AUTH\"] = \"GOOGLE_SERVICE_ACCOUNT_AUTH\";\n    /**\n     * OAuth auth.\n     */ AuthType[\"OAUTH\"] = \"OAUTH\";\n    /**\n     * OpenID Connect (OIDC) Auth.\n     */ AuthType[\"OIDC_AUTH\"] = \"OIDC_AUTH\";\n})(AuthType || (AuthType = {}));\n/** The API spec that the external API implements. */ var ApiSpec;\n(function(ApiSpec) {\n    /**\n     * Unspecified API spec. This value should not be used.\n     */ ApiSpec[\"API_SPEC_UNSPECIFIED\"] = \"API_SPEC_UNSPECIFIED\";\n    /**\n     * Simple search API spec.\n     */ ApiSpec[\"SIMPLE_SEARCH\"] = \"SIMPLE_SEARCH\";\n    /**\n     * Elastic search API spec.\n     */ ApiSpec[\"ELASTIC_SEARCH\"] = \"ELASTIC_SEARCH\";\n})(ApiSpec || (ApiSpec = {}));\n/** Status of the url retrieval. */ var UrlRetrievalStatus;\n(function(UrlRetrievalStatus) {\n    /**\n     * Default value. This value is unused\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSPECIFIED\"] = \"URL_RETRIEVAL_STATUS_UNSPECIFIED\";\n    /**\n     * Url retrieval is successful.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_SUCCESS\"] = \"URL_RETRIEVAL_STATUS_SUCCESS\";\n    /**\n     * Url retrieval is failed due to error.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_ERROR\"] = \"URL_RETRIEVAL_STATUS_ERROR\";\n    /**\n     * Url retrieval is failed because the content is behind paywall.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_PAYWALL\"] = \"URL_RETRIEVAL_STATUS_PAYWALL\";\n    /**\n     * Url retrieval is failed because the content is unsafe.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSAFE\"] = \"URL_RETRIEVAL_STATUS_UNSAFE\";\n})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));\n/** Output only. The reason why the model stopped generating tokens.\n\n  If empty, the model has not stopped generating the tokens.\n   */ var FinishReason;\n(function(FinishReason) {\n    /**\n     * The finish reason is unspecified.\n     */ FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    /**\n     * Token generation reached a natural stopping point or a configured stop sequence.\n     */ FinishReason[\"STOP\"] = \"STOP\";\n    /**\n     * Token generation reached the configured maximum output tokens.\n     */ FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    /**\n     * Token generation stopped because the content potentially contains safety violations. NOTE: When streaming, [content][] is empty if content filters blocks the output.\n     */ FinishReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The token generation stopped because of potential recitation.\n     */ FinishReason[\"RECITATION\"] = \"RECITATION\";\n    /**\n     * The token generation stopped because of using an unsupported language.\n     */ FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    /**\n     * All other reasons that stopped the token generation.\n     */ FinishReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Token generation stopped because the content contains forbidden terms.\n     */ FinishReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Token generation stopped for potentially containing prohibited content.\n     */ FinishReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n     */ FinishReason[\"SPII\"] = \"SPII\";\n    /**\n     * The function call generated by the model is invalid.\n     */ FinishReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * Token generation stopped because generated images have safety violations.\n     */ FinishReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The tool call generated by the model is invalid.\n     */ FinishReason[\"UNEXPECTED_TOOL_CALL\"] = \"UNEXPECTED_TOOL_CALL\";\n    /**\n     * Image generation stopped because the generated images have prohibited content.\n     */ FinishReason[\"IMAGE_PROHIBITED_CONTENT\"] = \"IMAGE_PROHIBITED_CONTENT\";\n})(FinishReason || (FinishReason = {}));\n/** Output only. Harm probability levels in the content. */ var HarmProbability;\n(function(HarmProbability) {\n    /**\n     * Harm probability unspecified.\n     */ HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm.\n     */ HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    /**\n     * Low level of harm.\n     */ HarmProbability[\"LOW\"] = \"LOW\";\n    /**\n     * Medium level of harm.\n     */ HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    /**\n     * High level of harm.\n     */ HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/** Output only. Harm severity levels in the content. */ var HarmSeverity;\n(function(HarmSeverity) {\n    /**\n     * Harm severity unspecified.\n     */ HarmSeverity[\"HARM_SEVERITY_UNSPECIFIED\"] = \"HARM_SEVERITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_NEGLIGIBLE\"] = \"HARM_SEVERITY_NEGLIGIBLE\";\n    /**\n     * Low level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_LOW\"] = \"HARM_SEVERITY_LOW\";\n    /**\n     * Medium level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_MEDIUM\"] = \"HARM_SEVERITY_MEDIUM\";\n    /**\n     * High level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_HIGH\"] = \"HARM_SEVERITY_HIGH\";\n})(HarmSeverity || (HarmSeverity = {}));\n/** Output only. Blocked reason. */ var BlockedReason;\n(function(BlockedReason) {\n    /**\n     * Unspecified blocked reason.\n     */ BlockedReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    /**\n     * Candidates blocked due to safety.\n     */ BlockedReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * Candidates blocked due to other reason.\n     */ BlockedReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Candidates blocked due to the terms which are included from the terminology blocklist.\n     */ BlockedReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Candidates blocked due to prohibited content.\n     */ BlockedReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * Candidates blocked due to unsafe image generation content.\n     */ BlockedReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n})(BlockedReason || (BlockedReason = {}));\n/** Output only. Traffic type. This shows whether a request consumes Pay-As-You-Go or Provisioned Throughput quota. */ var TrafficType;\n(function(TrafficType) {\n    /**\n     * Unspecified request traffic type.\n     */ TrafficType[\"TRAFFIC_TYPE_UNSPECIFIED\"] = \"TRAFFIC_TYPE_UNSPECIFIED\";\n    /**\n     * Type for Pay-As-You-Go traffic.\n     */ TrafficType[\"ON_DEMAND\"] = \"ON_DEMAND\";\n    /**\n     * Type for Provisioned Throughput traffic.\n     */ TrafficType[\"PROVISIONED_THROUGHPUT\"] = \"PROVISIONED_THROUGHPUT\";\n})(TrafficType || (TrafficType = {}));\n/** Server content modalities. */ var Modality;\n(function(Modality) {\n    /**\n     * The modality is unspecified.\n     */ Modality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Indicates the model should return text\n     */ Modality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Indicates the model should return images.\n     */ Modality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Indicates the model should return audio.\n     */ Modality[\"AUDIO\"] = \"AUDIO\";\n})(Modality || (Modality = {}));\n/** The media resolution to use. */ var MediaResolution;\n(function(MediaResolution) {\n    /**\n     * Media resolution has not been set\n     */ MediaResolution[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low (64 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium (256 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high (zoomed reframing with 256 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(MediaResolution || (MediaResolution = {}));\n/** Job state. */ var JobState;\n(function(JobState) {\n    /**\n     * The job state is unspecified.\n     */ JobState[\"JOB_STATE_UNSPECIFIED\"] = \"JOB_STATE_UNSPECIFIED\";\n    /**\n     * The job has been just created or resumed and processing has not yet begun.\n     */ JobState[\"JOB_STATE_QUEUED\"] = \"JOB_STATE_QUEUED\";\n    /**\n     * The service is preparing to run the job.\n     */ JobState[\"JOB_STATE_PENDING\"] = \"JOB_STATE_PENDING\";\n    /**\n     * The job is in progress.\n     */ JobState[\"JOB_STATE_RUNNING\"] = \"JOB_STATE_RUNNING\";\n    /**\n     * The job completed successfully.\n     */ JobState[\"JOB_STATE_SUCCEEDED\"] = \"JOB_STATE_SUCCEEDED\";\n    /**\n     * The job failed.\n     */ JobState[\"JOB_STATE_FAILED\"] = \"JOB_STATE_FAILED\";\n    /**\n     * The job is being cancelled. From this state the job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.\n     */ JobState[\"JOB_STATE_CANCELLING\"] = \"JOB_STATE_CANCELLING\";\n    /**\n     * The job has been cancelled.\n     */ JobState[\"JOB_STATE_CANCELLED\"] = \"JOB_STATE_CANCELLED\";\n    /**\n     * The job has been stopped, and can be resumed.\n     */ JobState[\"JOB_STATE_PAUSED\"] = \"JOB_STATE_PAUSED\";\n    /**\n     * The job has expired.\n     */ JobState[\"JOB_STATE_EXPIRED\"] = \"JOB_STATE_EXPIRED\";\n    /**\n     * The job is being updated. Only jobs in the `JOB_STATE_RUNNING` state can be updated. After updating, the job goes back to the `JOB_STATE_RUNNING` state.\n     */ JobState[\"JOB_STATE_UPDATING\"] = \"JOB_STATE_UPDATING\";\n    /**\n     * The job is partially succeeded, some results may be missing due to errors.\n     */ JobState[\"JOB_STATE_PARTIALLY_SUCCEEDED\"] = \"JOB_STATE_PARTIALLY_SUCCEEDED\";\n})(JobState || (JobState = {}));\n/** Tuning mode. */ var TuningMode;\n(function(TuningMode) {\n    /**\n     * Tuning mode is unspecified.\n     */ TuningMode[\"TUNING_MODE_UNSPECIFIED\"] = \"TUNING_MODE_UNSPECIFIED\";\n    /**\n     * Full fine-tuning mode.\n     */ TuningMode[\"TUNING_MODE_FULL\"] = \"TUNING_MODE_FULL\";\n    /**\n     * PEFT adapter tuning mode.\n     */ TuningMode[\"TUNING_MODE_PEFT_ADAPTER\"] = \"TUNING_MODE_PEFT_ADAPTER\";\n})(TuningMode || (TuningMode = {}));\n/** Optional. Adapter size for tuning. */ var AdapterSize;\n(function(AdapterSize) {\n    /**\n     * Adapter size is unspecified.\n     */ AdapterSize[\"ADAPTER_SIZE_UNSPECIFIED\"] = \"ADAPTER_SIZE_UNSPECIFIED\";\n    /**\n     * Adapter size 1.\n     */ AdapterSize[\"ADAPTER_SIZE_ONE\"] = \"ADAPTER_SIZE_ONE\";\n    /**\n     * Adapter size 2.\n     */ AdapterSize[\"ADAPTER_SIZE_TWO\"] = \"ADAPTER_SIZE_TWO\";\n    /**\n     * Adapter size 4.\n     */ AdapterSize[\"ADAPTER_SIZE_FOUR\"] = \"ADAPTER_SIZE_FOUR\";\n    /**\n     * Adapter size 8.\n     */ AdapterSize[\"ADAPTER_SIZE_EIGHT\"] = \"ADAPTER_SIZE_EIGHT\";\n    /**\n     * Adapter size 16.\n     */ AdapterSize[\"ADAPTER_SIZE_SIXTEEN\"] = \"ADAPTER_SIZE_SIXTEEN\";\n    /**\n     * Adapter size 32.\n     */ AdapterSize[\"ADAPTER_SIZE_THIRTY_TWO\"] = \"ADAPTER_SIZE_THIRTY_TWO\";\n})(AdapterSize || (AdapterSize = {}));\n/** Optional. The tuning task. Either I2V or T2V. */ var TuningTask;\n(function(TuningTask) {\n    /**\n     * Default value. This value is unused.\n     */ TuningTask[\"TUNING_TASK_UNSPECIFIED\"] = \"TUNING_TASK_UNSPECIFIED\";\n    /**\n     * Tuning task for image to video.\n     */ TuningTask[\"TUNING_TASK_I2V\"] = \"TUNING_TASK_I2V\";\n    /**\n     * Tuning task for text to video.\n     */ TuningTask[\"TUNING_TASK_T2V\"] = \"TUNING_TASK_T2V\";\n})(TuningTask || (TuningTask = {}));\n/** Options for feature selection preference. */ var FeatureSelectionPreference;\n(function(FeatureSelectionPreference) {\n    FeatureSelectionPreference[\"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\"] = \"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\";\n    FeatureSelectionPreference[\"PRIORITIZE_QUALITY\"] = \"PRIORITIZE_QUALITY\";\n    FeatureSelectionPreference[\"BALANCED\"] = \"BALANCED\";\n    FeatureSelectionPreference[\"PRIORITIZE_COST\"] = \"PRIORITIZE_COST\";\n})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));\n/** Defines the function behavior. Defaults to `BLOCKING`. */ var Behavior;\n(function(Behavior) {\n    /**\n     * This value is unused.\n     */ Behavior[\"UNSPECIFIED\"] = \"UNSPECIFIED\";\n    /**\n     * If set, the system will wait to receive the function response before continuing the conversation.\n     */ Behavior[\"BLOCKING\"] = \"BLOCKING\";\n    /**\n     * If set, the system will not wait to receive the function response. Instead, it will attempt to handle function responses as they become available while maintaining the conversation between the user and the model.\n     */ Behavior[\"NON_BLOCKING\"] = \"NON_BLOCKING\";\n})(Behavior || (Behavior = {}));\n/** Config for the dynamic retrieval config mode. */ var DynamicRetrievalConfigMode;\n(function(DynamicRetrievalConfigMode) {\n    /**\n     * Always trigger retrieval.\n     */ DynamicRetrievalConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */ DynamicRetrievalConfigMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));\n/** The environment being operated. */ var Environment;\n(function(Environment) {\n    /**\n     * Defaults to browser.\n     */ Environment[\"ENVIRONMENT_UNSPECIFIED\"] = \"ENVIRONMENT_UNSPECIFIED\";\n    /**\n     * Operates in a web browser.\n     */ Environment[\"ENVIRONMENT_BROWSER\"] = \"ENVIRONMENT_BROWSER\";\n})(Environment || (Environment = {}));\n/** Config for the function calling config mode. */ var FunctionCallingConfigMode;\n(function(FunctionCallingConfigMode) {\n    /**\n     * The function calling config mode is unspecified. Should not be used.\n     */ FunctionCallingConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Default model behavior, model decides to predict either function calls or natural language response.\n     */ FunctionCallingConfigMode[\"AUTO\"] = \"AUTO\";\n    /**\n     * Model is constrained to always predicting function calls only. If \"allowed_function_names\" are set, the predicted function calls will be limited to any one of \"allowed_function_names\", else the predicted function calls will be any one of the provided \"function_declarations\".\n     */ FunctionCallingConfigMode[\"ANY\"] = \"ANY\";\n    /**\n     * Model will not predict any function calls. Model behavior is same as when not passing any function declarations.\n     */ FunctionCallingConfigMode[\"NONE\"] = \"NONE\";\n    /**\n     * Model decides to predict either a function call or a natural language response, but will validate function calls with constrained decoding. If \"allowed_function_names\" are set, the predicted function call will be limited to any one of \"allowed_function_names\", else the predicted function call will be any one of the provided \"function_declarations\".\n     */ FunctionCallingConfigMode[\"VALIDATED\"] = \"VALIDATED\";\n})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));\n/** Enum that controls the safety filter level for objectionable content. */ var SafetyFilterLevel;\n(function(SafetyFilterLevel) {\n    SafetyFilterLevel[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    SafetyFilterLevel[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(SafetyFilterLevel || (SafetyFilterLevel = {}));\n/** Enum that controls the generation of people. */ var PersonGeneration;\n(function(PersonGeneration) {\n    /**\n     * Block generation of images of people.\n     */ PersonGeneration[\"DONT_ALLOW\"] = \"DONT_ALLOW\";\n    /**\n     * Generate images of adults, but not children.\n     */ PersonGeneration[\"ALLOW_ADULT\"] = \"ALLOW_ADULT\";\n    /**\n     * Generate images that include adults and children.\n     */ PersonGeneration[\"ALLOW_ALL\"] = \"ALLOW_ALL\";\n})(PersonGeneration || (PersonGeneration = {}));\n/** Enum that specifies the language of the text in the prompt. */ var ImagePromptLanguage;\n(function(ImagePromptLanguage) {\n    /**\n     * Auto-detect the language.\n     */ ImagePromptLanguage[\"auto\"] = \"auto\";\n    /**\n     * English\n     */ ImagePromptLanguage[\"en\"] = \"en\";\n    /**\n     * Japanese\n     */ ImagePromptLanguage[\"ja\"] = \"ja\";\n    /**\n     * Korean\n     */ ImagePromptLanguage[\"ko\"] = \"ko\";\n    /**\n     * Hindi\n     */ ImagePromptLanguage[\"hi\"] = \"hi\";\n    /**\n     * Chinese\n     */ ImagePromptLanguage[\"zh\"] = \"zh\";\n    /**\n     * Portuguese\n     */ ImagePromptLanguage[\"pt\"] = \"pt\";\n    /**\n     * Spanish\n     */ ImagePromptLanguage[\"es\"] = \"es\";\n})(ImagePromptLanguage || (ImagePromptLanguage = {}));\n/** Enum representing the mask mode of a mask reference image. */ var MaskReferenceMode;\n(function(MaskReferenceMode) {\n    MaskReferenceMode[\"MASK_MODE_DEFAULT\"] = \"MASK_MODE_DEFAULT\";\n    MaskReferenceMode[\"MASK_MODE_USER_PROVIDED\"] = \"MASK_MODE_USER_PROVIDED\";\n    MaskReferenceMode[\"MASK_MODE_BACKGROUND\"] = \"MASK_MODE_BACKGROUND\";\n    MaskReferenceMode[\"MASK_MODE_FOREGROUND\"] = \"MASK_MODE_FOREGROUND\";\n    MaskReferenceMode[\"MASK_MODE_SEMANTIC\"] = \"MASK_MODE_SEMANTIC\";\n})(MaskReferenceMode || (MaskReferenceMode = {}));\n/** Enum representing the control type of a control reference image. */ var ControlReferenceType;\n(function(ControlReferenceType) {\n    ControlReferenceType[\"CONTROL_TYPE_DEFAULT\"] = \"CONTROL_TYPE_DEFAULT\";\n    ControlReferenceType[\"CONTROL_TYPE_CANNY\"] = \"CONTROL_TYPE_CANNY\";\n    ControlReferenceType[\"CONTROL_TYPE_SCRIBBLE\"] = \"CONTROL_TYPE_SCRIBBLE\";\n    ControlReferenceType[\"CONTROL_TYPE_FACE_MESH\"] = \"CONTROL_TYPE_FACE_MESH\";\n})(ControlReferenceType || (ControlReferenceType = {}));\n/** Enum representing the subject type of a subject reference image. */ var SubjectReferenceType;\n(function(SubjectReferenceType) {\n    SubjectReferenceType[\"SUBJECT_TYPE_DEFAULT\"] = \"SUBJECT_TYPE_DEFAULT\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PERSON\"] = \"SUBJECT_TYPE_PERSON\";\n    SubjectReferenceType[\"SUBJECT_TYPE_ANIMAL\"] = \"SUBJECT_TYPE_ANIMAL\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PRODUCT\"] = \"SUBJECT_TYPE_PRODUCT\";\n})(SubjectReferenceType || (SubjectReferenceType = {}));\n/** Enum representing the editing mode. */ var EditMode;\n(function(EditMode) {\n    EditMode[\"EDIT_MODE_DEFAULT\"] = \"EDIT_MODE_DEFAULT\";\n    EditMode[\"EDIT_MODE_INPAINT_REMOVAL\"] = \"EDIT_MODE_INPAINT_REMOVAL\";\n    EditMode[\"EDIT_MODE_INPAINT_INSERTION\"] = \"EDIT_MODE_INPAINT_INSERTION\";\n    EditMode[\"EDIT_MODE_OUTPAINT\"] = \"EDIT_MODE_OUTPAINT\";\n    EditMode[\"EDIT_MODE_CONTROLLED_EDITING\"] = \"EDIT_MODE_CONTROLLED_EDITING\";\n    EditMode[\"EDIT_MODE_STYLE\"] = \"EDIT_MODE_STYLE\";\n    EditMode[\"EDIT_MODE_BGSWAP\"] = \"EDIT_MODE_BGSWAP\";\n    EditMode[\"EDIT_MODE_PRODUCT_IMAGE\"] = \"EDIT_MODE_PRODUCT_IMAGE\";\n})(EditMode || (EditMode = {}));\n/** Enum that represents the segmentation mode. */ var SegmentMode;\n(function(SegmentMode) {\n    SegmentMode[\"FOREGROUND\"] = \"FOREGROUND\";\n    SegmentMode[\"BACKGROUND\"] = \"BACKGROUND\";\n    SegmentMode[\"PROMPT\"] = \"PROMPT\";\n    SegmentMode[\"SEMANTIC\"] = \"SEMANTIC\";\n    SegmentMode[\"INTERACTIVE\"] = \"INTERACTIVE\";\n})(SegmentMode || (SegmentMode = {}));\n/** Enum for the reference type of a video generation reference image. */ var VideoGenerationReferenceType;\n(function(VideoGenerationReferenceType) {\n    /**\n     * A reference image that provides assets to the generated video,\n        such as the scene, an object, a character, etc.\n     */ VideoGenerationReferenceType[\"ASSET\"] = \"ASSET\";\n    /**\n     * A reference image that provides aesthetics including colors,\n        lighting, texture, etc., to be used as the style of the generated video,\n        such as 'anime', 'photography', 'origami', etc.\n     */ VideoGenerationReferenceType[\"STYLE\"] = \"STYLE\";\n})(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));\n/** Enum for the mask mode of a video generation mask. */ var VideoGenerationMaskMode;\n(function(VideoGenerationMaskMode) {\n    /**\n     * The image mask contains a masked rectangular region which is\n        applied on the first frame of the input video. The object described in\n        the prompt is inserted into this region and will appear in subsequent\n        frames.\n     */ VideoGenerationMaskMode[\"INSERT\"] = \"INSERT\";\n    /**\n     * The image mask is used to determine an object in the\n        first video frame to track. This object is removed from the video.\n     */ VideoGenerationMaskMode[\"REMOVE\"] = \"REMOVE\";\n    /**\n     * The image mask is used to determine a region in the\n        video. Objects in this region will be removed.\n     */ VideoGenerationMaskMode[\"REMOVE_STATIC\"] = \"REMOVE_STATIC\";\n    /**\n     * The image mask contains a masked rectangular region where\n        the input video will go. The remaining area will be generated. Video\n        masks are not supported.\n     */ VideoGenerationMaskMode[\"OUTPAINT\"] = \"OUTPAINT\";\n})(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));\n/** Enum that controls the compression quality of the generated videos. */ var VideoCompressionQuality;\n(function(VideoCompressionQuality) {\n    /**\n     * Optimized video compression quality. This will produce videos\n        with a compressed, smaller file size.\n     */ VideoCompressionQuality[\"OPTIMIZED\"] = \"OPTIMIZED\";\n    /**\n     * Lossless video compression quality. This will produce videos\n        with a larger file size.\n     */ VideoCompressionQuality[\"LOSSLESS\"] = \"LOSSLESS\";\n})(VideoCompressionQuality || (VideoCompressionQuality = {}));\n/** State for the lifecycle of a File. */ var FileState;\n(function(FileState) {\n    FileState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    FileState[\"PROCESSING\"] = \"PROCESSING\";\n    FileState[\"ACTIVE\"] = \"ACTIVE\";\n    FileState[\"FAILED\"] = \"FAILED\";\n})(FileState || (FileState = {}));\n/** Source of the File. */ var FileSource;\n(function(FileSource) {\n    FileSource[\"SOURCE_UNSPECIFIED\"] = \"SOURCE_UNSPECIFIED\";\n    FileSource[\"UPLOADED\"] = \"UPLOADED\";\n    FileSource[\"GENERATED\"] = \"GENERATED\";\n})(FileSource || (FileSource = {}));\n/** The reason why the turn is complete. */ var TurnCompleteReason;\n(function(TurnCompleteReason) {\n    /**\n     * Default value. Reason is unspecified.\n     */ TurnCompleteReason[\"TURN_COMPLETE_REASON_UNSPECIFIED\"] = \"TURN_COMPLETE_REASON_UNSPECIFIED\";\n    /**\n     * The function call generated by the model is invalid.\n     */ TurnCompleteReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * The response is rejected by the model.\n     */ TurnCompleteReason[\"RESPONSE_REJECTED\"] = \"RESPONSE_REJECTED\";\n    /**\n     * Needs more input from the user.\n     */ TurnCompleteReason[\"NEED_MORE_INPUT\"] = \"NEED_MORE_INPUT\";\n})(TurnCompleteReason || (TurnCompleteReason = {}));\n/** Server content modalities. */ var MediaModality;\n(function(MediaModality) {\n    /**\n     * The modality is unspecified.\n     */ MediaModality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Plain text.\n     */ MediaModality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Images.\n     */ MediaModality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Video.\n     */ MediaModality[\"VIDEO\"] = \"VIDEO\";\n    /**\n     * Audio.\n     */ MediaModality[\"AUDIO\"] = \"AUDIO\";\n    /**\n     * Document, e.g. PDF.\n     */ MediaModality[\"DOCUMENT\"] = \"DOCUMENT\";\n})(MediaModality || (MediaModality = {}));\n/** Start of speech sensitivity. */ var StartSensitivity;\n(function(StartSensitivity) {\n    /**\n     * The default is START_SENSITIVITY_LOW.\n     */ StartSensitivity[\"START_SENSITIVITY_UNSPECIFIED\"] = \"START_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection will detect the start of speech more often.\n     */ StartSensitivity[\"START_SENSITIVITY_HIGH\"] = \"START_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection will detect the start of speech less often.\n     */ StartSensitivity[\"START_SENSITIVITY_LOW\"] = \"START_SENSITIVITY_LOW\";\n})(StartSensitivity || (StartSensitivity = {}));\n/** End of speech sensitivity. */ var EndSensitivity;\n(function(EndSensitivity) {\n    /**\n     * The default is END_SENSITIVITY_LOW.\n     */ EndSensitivity[\"END_SENSITIVITY_UNSPECIFIED\"] = \"END_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection ends speech more often.\n     */ EndSensitivity[\"END_SENSITIVITY_HIGH\"] = \"END_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection ends speech less often.\n     */ EndSensitivity[\"END_SENSITIVITY_LOW\"] = \"END_SENSITIVITY_LOW\";\n})(EndSensitivity || (EndSensitivity = {}));\n/** The different ways of handling user activity. */ var ActivityHandling;\n(function(ActivityHandling) {\n    /**\n     * If unspecified, the default behavior is `START_OF_ACTIVITY_INTERRUPTS`.\n     */ ActivityHandling[\"ACTIVITY_HANDLING_UNSPECIFIED\"] = \"ACTIVITY_HANDLING_UNSPECIFIED\";\n    /**\n     * If true, start of activity will interrupt the model's response (also called \"barge in\"). The model's current response will be cut-off in the moment of the interruption. This is the default behavior.\n     */ ActivityHandling[\"START_OF_ACTIVITY_INTERRUPTS\"] = \"START_OF_ACTIVITY_INTERRUPTS\";\n    /**\n     * The model's response will not be interrupted.\n     */ ActivityHandling[\"NO_INTERRUPTION\"] = \"NO_INTERRUPTION\";\n})(ActivityHandling || (ActivityHandling = {}));\n/** Options about which input is included in the user's turn. */ var TurnCoverage;\n(function(TurnCoverage) {\n    /**\n     * If unspecified, the default behavior is `TURN_INCLUDES_ONLY_ACTIVITY`.\n     */ TurnCoverage[\"TURN_COVERAGE_UNSPECIFIED\"] = \"TURN_COVERAGE_UNSPECIFIED\";\n    /**\n     * The users turn only includes activity since the last turn, excluding inactivity (e.g. silence on the audio stream). This is the default behavior.\n     */ TurnCoverage[\"TURN_INCLUDES_ONLY_ACTIVITY\"] = \"TURN_INCLUDES_ONLY_ACTIVITY\";\n    /**\n     * The users turn includes all realtime input since the last turn, including inactivity (e.g. silence on the audio stream).\n     */ TurnCoverage[\"TURN_INCLUDES_ALL_INPUT\"] = \"TURN_INCLUDES_ALL_INPUT\";\n})(TurnCoverage || (TurnCoverage = {}));\n/** Specifies how the response should be scheduled in the conversation. */ var FunctionResponseScheduling;\n(function(FunctionResponseScheduling) {\n    /**\n     * This value is unused.\n     */ FunctionResponseScheduling[\"SCHEDULING_UNSPECIFIED\"] = \"SCHEDULING_UNSPECIFIED\";\n    /**\n     * Only add the result to the conversation context, do not interrupt or trigger generation.\n     */ FunctionResponseScheduling[\"SILENT\"] = \"SILENT\";\n    /**\n     * Add the result to the conversation context, and prompt to generate output without interrupting ongoing generation.\n     */ FunctionResponseScheduling[\"WHEN_IDLE\"] = \"WHEN_IDLE\";\n    /**\n     * Add the result to the conversation context, interrupt ongoing generation and prompt to generate output.\n     */ FunctionResponseScheduling[\"INTERRUPT\"] = \"INTERRUPT\";\n})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));\n/** Scale of the generated music. */ var Scale;\n(function(Scale) {\n    /**\n     * Default value. This value is unused.\n     */ Scale[\"SCALE_UNSPECIFIED\"] = \"SCALE_UNSPECIFIED\";\n    /**\n     * C major or A minor.\n     */ Scale[\"C_MAJOR_A_MINOR\"] = \"C_MAJOR_A_MINOR\";\n    /**\n     * Db major or Bb minor.\n     */ Scale[\"D_FLAT_MAJOR_B_FLAT_MINOR\"] = \"D_FLAT_MAJOR_B_FLAT_MINOR\";\n    /**\n     * D major or B minor.\n     */ Scale[\"D_MAJOR_B_MINOR\"] = \"D_MAJOR_B_MINOR\";\n    /**\n     * Eb major or C minor\n     */ Scale[\"E_FLAT_MAJOR_C_MINOR\"] = \"E_FLAT_MAJOR_C_MINOR\";\n    /**\n     * E major or Db minor.\n     */ Scale[\"E_MAJOR_D_FLAT_MINOR\"] = \"E_MAJOR_D_FLAT_MINOR\";\n    /**\n     * F major or D minor.\n     */ Scale[\"F_MAJOR_D_MINOR\"] = \"F_MAJOR_D_MINOR\";\n    /**\n     * Gb major or Eb minor.\n     */ Scale[\"G_FLAT_MAJOR_E_FLAT_MINOR\"] = \"G_FLAT_MAJOR_E_FLAT_MINOR\";\n    /**\n     * G major or E minor.\n     */ Scale[\"G_MAJOR_E_MINOR\"] = \"G_MAJOR_E_MINOR\";\n    /**\n     * Ab major or F minor.\n     */ Scale[\"A_FLAT_MAJOR_F_MINOR\"] = \"A_FLAT_MAJOR_F_MINOR\";\n    /**\n     * A major or Gb minor.\n     */ Scale[\"A_MAJOR_G_FLAT_MINOR\"] = \"A_MAJOR_G_FLAT_MINOR\";\n    /**\n     * Bb major or G minor.\n     */ Scale[\"B_FLAT_MAJOR_G_MINOR\"] = \"B_FLAT_MAJOR_G_MINOR\";\n    /**\n     * B major or Ab minor.\n     */ Scale[\"B_MAJOR_A_FLAT_MINOR\"] = \"B_MAJOR_A_FLAT_MINOR\";\n})(Scale || (Scale = {}));\n/** The mode of music generation. */ var MusicGenerationMode;\n(function(MusicGenerationMode) {\n    /**\n     * Rely on the server default generation mode.\n     */ MusicGenerationMode[\"MUSIC_GENERATION_MODE_UNSPECIFIED\"] = \"MUSIC_GENERATION_MODE_UNSPECIFIED\";\n    /**\n     * Steer text prompts to regions of latent space with higher quality\n        music.\n     */ MusicGenerationMode[\"QUALITY\"] = \"QUALITY\";\n    /**\n     * Steer text prompts to regions of latent space with a larger\n        diversity of music.\n     */ MusicGenerationMode[\"DIVERSITY\"] = \"DIVERSITY\";\n    /**\n     * Steer text prompts to regions of latent space more likely to\n        generate music with vocals.\n     */ MusicGenerationMode[\"VOCALIZATION\"] = \"VOCALIZATION\";\n})(MusicGenerationMode || (MusicGenerationMode = {}));\n/** The playback control signal to apply to the music generation. */ var LiveMusicPlaybackControl;\n(function(LiveMusicPlaybackControl) {\n    /**\n     * This value is unused.\n     */ LiveMusicPlaybackControl[\"PLAYBACK_CONTROL_UNSPECIFIED\"] = \"PLAYBACK_CONTROL_UNSPECIFIED\";\n    /**\n     * Start generating the music.\n     */ LiveMusicPlaybackControl[\"PLAY\"] = \"PLAY\";\n    /**\n     * Hold the music generation. Use PLAY to resume from the current position.\n     */ LiveMusicPlaybackControl[\"PAUSE\"] = \"PAUSE\";\n    /**\n     * Stop the music generation and reset the context (prompts retained).\n        Use PLAY to restart the music generation.\n     */ LiveMusicPlaybackControl[\"STOP\"] = \"STOP\";\n    /**\n     * Reset the context of the music generation without stopping it.\n        Retains the current prompts and config.\n     */ LiveMusicPlaybackControl[\"RESET_CONTEXT\"] = \"RESET_CONTEXT\";\n})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));\n/** Raw media bytes for function response.\n\n  Text should not be sent as raw bytes, use the FunctionResponse.response\n  field.\n   */ class FunctionResponseBlob {\n}\n/** URI based data for function response. */ class FunctionResponseFileData {\n}\n/** A datatype containing media that is part of a `FunctionResponse` message.\n\n  A `FunctionResponsePart` consists of data which has an associated datatype. A\n  `FunctionResponsePart` can only contain one of the accepted types in\n  `FunctionResponsePart.data`.\n\n  A `FunctionResponsePart` must have a fixed IANA MIME type identifying the\n  type and subtype of the media if the `inline_data` field is filled with raw\n  bytes.\n   */ class FunctionResponsePart {\n}\n/** A function response. */ class FunctionResponse {\n}\n/**\n * Creates a `Part` object from a `URI` string.\n */ function createPartFromUri(uri, mimeType) {\n    return {\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `text` string.\n */ function createPartFromText(text) {\n    return {\n        text: text\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionCall` object.\n */ function createPartFromFunctionCall(name, args) {\n    return {\n        functionCall: {\n            name: name,\n            args: args\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionResponse` object.\n */ function createPartFromFunctionResponse(id, name, response) {\n    return {\n        functionResponse: {\n            id: id,\n            name: name,\n            response: response\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `base64` encoded `string`.\n */ function createPartFromBase64(data, mimeType) {\n    return {\n        inlineData: {\n            data: data,\n            mimeType: mimeType\n        }\n    };\n}\n/**\n * Creates a `Part` object from the `outcome` and `output` of a `CodeExecutionResult` object.\n */ function createPartFromCodeExecutionResult(outcome, output) {\n    return {\n        codeExecutionResult: {\n            outcome: outcome,\n            output: output\n        }\n    };\n}\n/**\n * Creates a `Part` object from the `code` and `language` of an `ExecutableCode` object.\n */ function createPartFromExecutableCode(code, language) {\n    return {\n        executableCode: {\n            code: code,\n            language: language\n        }\n    };\n}\nfunction _isPart(obj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        return \"fileData\" in obj || \"text\" in obj || \"functionCall\" in obj || \"functionResponse\" in obj || \"inlineData\" in obj || \"videoMetadata\" in obj || \"codeExecutionResult\" in obj || \"executableCode\" in obj;\n    }\n    return false;\n}\nfunction _toParts(partOrString) {\n    const parts = [];\n    if (typeof partOrString === \"string\") {\n        parts.push(createPartFromText(partOrString));\n    } else if (_isPart(partOrString)) {\n        parts.push(partOrString);\n    } else if (Array.isArray(partOrString)) {\n        if (partOrString.length === 0) {\n            throw new Error(\"partOrString cannot be an empty array\");\n        }\n        for (const part of partOrString){\n            if (typeof part === \"string\") {\n                parts.push(createPartFromText(part));\n            } else if (_isPart(part)) {\n                parts.push(part);\n            } else {\n                throw new Error(\"element in PartUnion must be a Part object or string\");\n            }\n        }\n    } else {\n        throw new Error(\"partOrString must be a Part object, string, or array\");\n    }\n    return parts;\n}\n/**\n * Creates a `Content` object with a user role from a `PartListUnion` object or `string`.\n */ function createUserContent(partOrString) {\n    return {\n        role: \"user\",\n        parts: _toParts(partOrString)\n    };\n}\n/**\n * Creates a `Content` object with a model role from a `PartListUnion` object or `string`.\n */ function createModelContent(partOrString) {\n    return {\n        role: \"model\",\n        parts: _toParts(partOrString)\n    };\n}\n/** A wrapper class for the http response. */ class HttpResponse {\n    constructor(response){\n        // Process the headers.\n        const headers = {};\n        for (const pair of response.headers.entries()){\n            headers[pair[0]] = pair[1];\n        }\n        this.headers = headers;\n        // Keep the original response.\n        this.responseInternal = response;\n    }\n    json() {\n        return this.responseInternal.json();\n    }\n}\n/** Content filter results for a prompt sent in the request. */ class GenerateContentResponsePromptFeedback {\n}\n/** Usage metadata about response(s). */ class GenerateContentResponseUsageMetadata {\n}\n/** Response message for PredictionService.GenerateContent. */ class GenerateContentResponse {\n    /**\n     * Returns the concatenation of all text parts from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the text from the first\n     * one will be returned.\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     * If there are thought parts in the response, the concatenation of all text\n     * parts excluding the thought parts will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'Why is the sky blue?',\n     * });\n     *\n     * console.debug(response.text);\n     * ```\n     */ get text() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning text from the first one.\");\n        }\n        let text = \"\";\n        let anyTextPartText = false;\n        const nonTextParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"text\" && fieldName !== \"thought\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === \"string\") {\n                if (typeof part.thought === \"boolean\" && part.thought) {\n                    continue;\n                }\n                anyTextPartText = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartText ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the first candidate\n     * in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the inline data from the\n     * first one will be returned. If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */ get data() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning data from the first one.\");\n        }\n        let data = \"\";\n        const nonDataParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"inlineData\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === \"string\") {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n    /**\n     * Returns the function calls from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the function calls from\n     * the first one will be returned.\n     * If there are no function calls in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const controlLightFunctionDeclaration: FunctionDeclaration = {\n     *   name: 'controlLight',\n     *   parameters: {\n     *   type: Type.OBJECT,\n     *   description: 'Set the brightness and color temperature of a room light.',\n     *   properties: {\n     *     brightness: {\n     *       type: Type.NUMBER,\n     *       description:\n     *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',\n     *     },\n     *     colorTemperature: {\n     *       type: Type.STRING,\n     *       description:\n     *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',\n     *     },\n     *   },\n     *   required: ['brightness', 'colorTemperature'],\n     *  };\n     *  const response = await ai.models.generateContent({\n     *     model: 'gemini-2.0-flash',\n     *     contents: 'Dim the lights so the room feels cozy and warm.',\n     *     config: {\n     *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],\n     *       toolConfig: {\n     *         functionCallingConfig: {\n     *           mode: FunctionCallingConfigMode.ANY,\n     *           allowedFunctionNames: ['controlLight'],\n     *         },\n     *       },\n     *     },\n     *   });\n     *  console.debug(JSON.stringify(response.functionCalls));\n     * ```\n     */ get functionCalls() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning function calls from the first one.\");\n        }\n        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.functionCall).map((part)=>part.functionCall).filter((functionCall)=>functionCall !== undefined);\n        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {\n            return undefined;\n        }\n        return functionCalls;\n    }\n    /**\n     * Returns the first executable code from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the executable code from\n     * the first one will be returned.\n     * If there are no executable code in the response, undefined will be\n     * returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.executableCode);\n     * ```\n     */ get executableCode() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning executable code from the first one.\");\n        }\n        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.executableCode).map((part)=>part.executableCode).filter((executableCode)=>executableCode !== undefined);\n        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {\n            return undefined;\n        }\n        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;\n    }\n    /**\n     * Returns the first code execution result from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the code execution result from\n     * the first one will be returned.\n     * If there are no code execution result in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.codeExecutionResult);\n     * ```\n     */ get codeExecutionResult() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning code execution result from the first one.\");\n        }\n        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.codeExecutionResult).map((part)=>part.codeExecutionResult).filter((codeExecutionResult)=>codeExecutionResult !== undefined);\n        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {\n            return undefined;\n        }\n        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;\n    }\n}\n/** Response for the embed_content method. */ class EmbedContentResponse {\n}\n/** The output images response. */ class GenerateImagesResponse {\n}\n/** Response for the request to edit an image. */ class EditImageResponse {\n}\nclass UpscaleImageResponse {\n}\n/** The output images response. */ class RecontextImageResponse {\n}\n/** The output images response. */ class SegmentImageResponse {\n}\nclass ListModelsResponse {\n}\nclass DeleteModelResponse {\n}\n/** Response for counting tokens. */ class CountTokensResponse {\n}\n/** Response for computing tokens. */ class ComputeTokensResponse {\n}\n/** Response with generated videos. */ class GenerateVideosResponse {\n}\n/** A video generation operation. */ class GenerateVideosOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */ _fromAPIResponse({ apiResponse, isVertexAI }) {\n        const operation = new GenerateVideosOperation();\n        let response;\n        const op = apiResponse;\n        if (isVertexAI) {\n            response = generateVideosOperationFromVertex$1(op);\n        } else {\n            response = generateVideosOperationFromMldev$1(op);\n        }\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/** Response for the list tuning jobs method. */ class ListTuningJobsResponse {\n}\n/** Empty response for caches.delete method. */ class DeleteCachedContentResponse {\n}\nclass ListCachedContentsResponse {\n}\n/** Response for the list files method. */ class ListFilesResponse {\n}\n/** Response for the create file method. */ class CreateFileResponse {\n}\n/** Response for the delete file method. */ class DeleteFileResponse {\n}\n/** Config for `inlined_responses` parameter. */ class InlinedResponse {\n}\n/** Config for `response` parameter. */ class SingleEmbedContentResponse {\n}\n/** Config for `inlined_embedding_responses` parameter. */ class InlinedEmbedContentResponse {\n}\n/** Config for batches.list return value. */ class ListBatchJobsResponse {\n}\n/** Represents a single response in a replay. */ class ReplayResponse {\n}\n/** A raw reference image.\n\n  A raw reference image represents the base image to edit, provided by the user.\n  It can optionally be provided in addition to a mask reference image or\n  a style reference image.\n   */ class RawReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_RAW\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId\n        };\n        return referenceImageAPI;\n    }\n}\n/** A mask reference image.\n\n  This encapsulates either a mask image provided by the user and configs for\n  the user provided mask, or only config parameters for the model to generate\n  a mask.\n\n  A mask image is an image whose non-zero values indicate where to edit the base\n  image. If the user provides a mask image, the mask must be in the same\n  dimensions as the raw image.\n   */ class MaskReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_MASK\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            maskImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A control reference image.\n\n  The image of the control reference image is either a control image provided\n  by the user, or a regular image which the backend will use to generate a\n  control image of. In the case of the latter, the\n  enable_control_image_computation field in the config should be set to True.\n\n  A control image is an image that represents a sketch image of areas for the\n  model to fill in based on the prompt.\n   */ class ControlReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_CONTROL\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            controlImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A style reference image.\n\n  This encapsulates a style reference image provided by the user, and\n  additionally optional config parameters for the style reference image.\n\n  A raw reference image can also be provided as a destination for the style to\n  be applied to.\n   */ class StyleReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_STYLE\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            styleImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A subject reference image.\n\n  This encapsulates a subject reference image provided by the user, and\n  additionally optional config parameters for the subject reference image.\n\n  A raw reference image can also be provided as a destination for the subject to\n  be applied to.\n   */ class SubjectReferenceImage {\n    /* Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_SUBJECT\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            subjectImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A content reference image.\n\n  A content reference image represents a subject to reference (ex. person,\n  product, animal) provided by the user. It can optionally be provided in\n  addition to a style reference image (ex. background, style reference).\n   */ class ContentReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_CONTENT\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId\n        };\n        return referenceImageAPI;\n    }\n}\n/** Response message for API call. */ class LiveServerMessage {\n    /**\n     * Returns the concatenation of all text parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     */ get text() {\n        var _a, _b, _c;\n        let text = \"\";\n        let anyTextPartFound = false;\n        const nonTextParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"text\" && fieldName !== \"thought\" && fieldValue !== null) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === \"string\") {\n                if (typeof part.thought === \"boolean\" && part.thought) {\n                    continue;\n                }\n                anyTextPartFound = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartFound ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */ get data() {\n        var _a, _b, _c;\n        let data = \"\";\n        const nonDataParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"inlineData\" && fieldValue !== null) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === \"string\") {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n}\n/** Client generated response to a `ToolCall` received from the server.\n\n  Individual `FunctionResponse` objects are matched to the respective\n  `FunctionCall` objects by the `id` field.\n\n  Note that in the unary and server-streaming GenerateContent APIs function\n  calling happens by exchanging the `Content` parts, while in the bidi\n  GenerateContent APIs function calling happens over this dedicated set of\n  messages.\n   */ class LiveClientToolResponse {\n}\n/** Parameters for sending tool responses to the live API. */ class LiveSendToolResponseParameters {\n    constructor(){\n        /** Tool responses to send to the session. */ this.functionResponses = [];\n    }\n}\n/** Response message for the LiveMusicClientMessage call. */ class LiveMusicServerMessage {\n    /**\n     * Returns the first audio chunk from the server content, if present.\n     *\n     * @remarks\n     * If there are no audio chunks in the response, undefined will be returned.\n     */ get audioChunk() {\n        if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {\n            return this.serverContent.audioChunks[0];\n        }\n        return undefined;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function tModel(apiClient, model) {\n    if (!model || typeof model !== \"string\") {\n        throw new Error(\"model is required and must be a string\");\n    }\n    if (apiClient.isVertexAI()) {\n        if (model.startsWith(\"publishers/\") || model.startsWith(\"projects/\") || model.startsWith(\"models/\")) {\n            return model;\n        } else if (model.indexOf(\"/\") >= 0) {\n            const parts = model.split(\"/\", 2);\n            return `publishers/${parts[0]}/models/${parts[1]}`;\n        } else {\n            return `publishers/google/models/${model}`;\n        }\n    } else {\n        if (model.startsWith(\"models/\") || model.startsWith(\"tunedModels/\")) {\n            return model;\n        } else {\n            return `models/${model}`;\n        }\n    }\n}\nfunction tCachesModel(apiClient, model) {\n    const transformedModel = tModel(apiClient, model);\n    if (!transformedModel) {\n        return \"\";\n    }\n    if (transformedModel.startsWith(\"publishers/\") && apiClient.isVertexAI()) {\n        // vertex caches only support model name start with projects.\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;\n    } else if (transformedModel.startsWith(\"models/\") && apiClient.isVertexAI()) {\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;\n    } else {\n        return transformedModel;\n    }\n}\nfunction tBlobs(blobs) {\n    if (Array.isArray(blobs)) {\n        return blobs.map((blob)=>tBlob(blob));\n    } else {\n        return [\n            tBlob(blobs)\n        ];\n    }\n}\nfunction tBlob(blob) {\n    if (typeof blob === \"object\" && blob !== null) {\n        return blob;\n    }\n    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);\n}\nfunction tImageBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"image/\")) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tAudioBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"audio/\")) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tPart(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"PartUnion is required\");\n    }\n    if (typeof origin === \"object\") {\n        return origin;\n    }\n    if (typeof origin === \"string\") {\n        return {\n            text: origin\n        };\n    }\n    throw new Error(`Unsupported part type: ${typeof origin}`);\n}\nfunction tParts(origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"PartListUnion is required\");\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tPart(item));\n    }\n    return [\n        tPart(origin)\n    ];\n}\nfunction _isContent(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"parts\" in origin && Array.isArray(origin.parts);\n}\nfunction _isFunctionCallPart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionCall\" in origin;\n}\nfunction _isFunctionResponsePart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionResponse\" in origin;\n}\nfunction tContent(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"ContentUnion is required\");\n    }\n    if (_isContent(origin)) {\n        // _isContent is a utility function that checks if the\n        // origin is a Content.\n        return origin;\n    }\n    return {\n        role: \"user\",\n        parts: tParts(origin)\n    };\n}\nfunction tContentsForEmbed(apiClient, origin) {\n    if (!origin) {\n        return [];\n    }\n    if (apiClient.isVertexAI() && Array.isArray(origin)) {\n        return origin.flatMap((item)=>{\n            const content = tContent(item);\n            if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n                return [\n                    content.parts[0].text\n                ];\n            }\n            return [];\n        });\n    } else if (apiClient.isVertexAI()) {\n        const content = tContent(origin);\n        if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n            return [\n                content.parts[0].text\n            ];\n        }\n        return [];\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tContent(item));\n    }\n    return [\n        tContent(origin)\n    ];\n}\nfunction tContents(origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"contents are required\");\n    }\n    if (!Array.isArray(origin)) {\n        // If it's not an array, it's a single content or a single PartUnion.\n        if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them\");\n        }\n        return [\n            tContent(origin)\n        ];\n    }\n    const result = [];\n    const accumulatedParts = [];\n    const isContentArray = _isContent(origin[0]);\n    for (const item of origin){\n        const isContent = _isContent(item);\n        if (isContent != isContentArray) {\n            throw new Error(\"Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them\");\n        }\n        if (isContent) {\n            // `isContent` contains the result of _isContent, which is a utility\n            // function that checks if the item is a Content.\n            result.push(item);\n        } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them\");\n        } else {\n            accumulatedParts.push(item);\n        }\n    }\n    if (!isContentArray) {\n        result.push({\n            role: \"user\",\n            parts: tParts(accumulatedParts)\n        });\n    }\n    return result;\n}\n/*\nTransform the type field from an array of types to an array of anyOf fields.\nExample:\n  {type: ['STRING', 'NUMBER']}\nwill be transformed to\n  {anyOf: [{type: 'STRING'}, {type: 'NUMBER'}]}\n*/ function flattenTypeArrayToAnyOf(typeList, resultingSchema) {\n    if (typeList.includes(\"null\")) {\n        resultingSchema[\"nullable\"] = true;\n    }\n    const listWithoutNull = typeList.filter((type)=>type !== \"null\");\n    if (listWithoutNull.length === 1) {\n        resultingSchema[\"type\"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;\n    } else {\n        resultingSchema[\"anyOf\"] = [];\n        for (const i of listWithoutNull){\n            resultingSchema[\"anyOf\"].push({\n                \"type\": Object.values(Type).includes(i.toUpperCase()) ? i.toUpperCase() : Type.TYPE_UNSPECIFIED\n            });\n        }\n    }\n}\nfunction processJsonSchema(_jsonSchema) {\n    const genAISchema = {};\n    const schemaFieldNames = [\n        \"items\"\n    ];\n    const listSchemaFieldNames = [\n        \"anyOf\"\n    ];\n    const dictSchemaFieldNames = [\n        \"properties\"\n    ];\n    if (_jsonSchema[\"type\"] && _jsonSchema[\"anyOf\"]) {\n        throw new Error(\"type and anyOf cannot be both populated.\");\n    }\n    /*\n    This is to handle the nullable array or object. The _jsonSchema will\n    be in the format of {anyOf: [{type: 'null'}, {type: 'object'}]}. The\n    logic is to check if anyOf has 2 elements and one of the element is null,\n    if so, the anyOf field is unnecessary, so we need to get rid of the anyOf\n    field and make the schema nullable. Then use the other element as the new\n    _jsonSchema for processing. This is because the backend doesn't have a null\n    type.\n    This has to be checked before we process any other fields.\n    For example:\n      const objectNullable = z.object({\n        nullableArray: z.array(z.string()).nullable(),\n      });\n    Will have the raw _jsonSchema as:\n    {\n      type: 'OBJECT',\n      properties: {\n          nullableArray: {\n             anyOf: [\n                {type: 'null'},\n                {\n                  type: 'array',\n                  items: {type: 'string'},\n                },\n              ],\n          }\n      },\n      required: [ 'nullableArray' ],\n    }\n    Will result in following schema compatible with Gemini API:\n      {\n        type: 'OBJECT',\n        properties: {\n           nullableArray: {\n              nullable: true,\n              type: 'ARRAY',\n              items: {type: 'string'},\n           }\n        },\n        required: [ 'nullableArray' ],\n      }\n    */ const incomingAnyOf = _jsonSchema[\"anyOf\"];\n    if (incomingAnyOf != null && incomingAnyOf.length == 2) {\n        if (incomingAnyOf[0][\"type\"] === \"null\") {\n            genAISchema[\"nullable\"] = true;\n            _jsonSchema = incomingAnyOf[1];\n        } else if (incomingAnyOf[1][\"type\"] === \"null\") {\n            genAISchema[\"nullable\"] = true;\n            _jsonSchema = incomingAnyOf[0];\n        }\n    }\n    if (_jsonSchema[\"type\"] instanceof Array) {\n        flattenTypeArrayToAnyOf(_jsonSchema[\"type\"], genAISchema);\n    }\n    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)){\n        // Skip if the fieldvalue is undefined or null.\n        if (fieldValue == null) {\n            continue;\n        }\n        if (fieldName == \"type\") {\n            if (fieldValue === \"null\") {\n                throw new Error(\"type: null can not be the only possible type for the field.\");\n            }\n            if (fieldValue instanceof Array) {\n                continue;\n            }\n            genAISchema[\"type\"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;\n        } else if (schemaFieldNames.includes(fieldName)) {\n            genAISchema[fieldName] = processJsonSchema(fieldValue);\n        } else if (listSchemaFieldNames.includes(fieldName)) {\n            const listSchemaFieldValue = [];\n            for (const item of fieldValue){\n                if (item[\"type\"] == \"null\") {\n                    genAISchema[\"nullable\"] = true;\n                    continue;\n                }\n                listSchemaFieldValue.push(processJsonSchema(item));\n            }\n            genAISchema[fieldName] = listSchemaFieldValue;\n        } else if (dictSchemaFieldNames.includes(fieldName)) {\n            const dictSchemaFieldValue = {};\n            for (const [key, value] of Object.entries(fieldValue)){\n                dictSchemaFieldValue[key] = processJsonSchema(value);\n            }\n            genAISchema[fieldName] = dictSchemaFieldValue;\n        } else {\n            // additionalProperties is not included in JSONSchema, skipping it.\n            if (fieldName === \"additionalProperties\") {\n                continue;\n            }\n            genAISchema[fieldName] = fieldValue;\n        }\n    }\n    return genAISchema;\n}\n// we take the unknown in the schema field because we want enable user to pass\n// the output of major schema declaration tools without casting. Tools such as\n// zodToJsonSchema, typebox, zodToJsonSchema function can return JsonSchema7Type\n// or object, see details in\n// https://github.com/StefanTerdell/zod-to-json-schema/blob/70525efe555cd226691e093d171370a3b10921d1/src/zodToJsonSchema.ts#L7\n// typebox can return unknown, see details in\n// https://github.com/sinclairzx81/typebox/blob/5a5431439f7d5ca6b494d0d18fbfd7b1a356d67c/src/type/create/type.ts#L35\n// Note: proper json schemas with the $schema field set never arrive to this\n// transformer. Schemas with $schema are routed to the equivalent API json\n// schema field.\nfunction tSchema(schema) {\n    return processJsonSchema(schema);\n}\nfunction tSpeechConfig(speechConfig) {\n    if (typeof speechConfig === \"object\") {\n        return speechConfig;\n    } else if (typeof speechConfig === \"string\") {\n        return {\n            voiceConfig: {\n                prebuiltVoiceConfig: {\n                    voiceName: speechConfig\n                }\n            }\n        };\n    } else {\n        throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);\n    }\n}\nfunction tLiveSpeechConfig(speechConfig) {\n    if (\"multiSpeakerVoiceConfig\" in speechConfig) {\n        throw new Error(\"multiSpeakerVoiceConfig is not supported in the live API.\");\n    }\n    return speechConfig;\n}\nfunction tTool(tool) {\n    if (tool.functionDeclarations) {\n        for (const functionDeclaration of tool.functionDeclarations){\n            if (functionDeclaration.parameters) {\n                if (!Object.keys(functionDeclaration.parameters).includes(\"$schema\")) {\n                    functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);\n                } else {\n                    if (!functionDeclaration.parametersJsonSchema) {\n                        functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;\n                        delete functionDeclaration.parameters;\n                    }\n                }\n            }\n            if (functionDeclaration.response) {\n                if (!Object.keys(functionDeclaration.response).includes(\"$schema\")) {\n                    functionDeclaration.response = processJsonSchema(functionDeclaration.response);\n                } else {\n                    if (!functionDeclaration.responseJsonSchema) {\n                        functionDeclaration.responseJsonSchema = functionDeclaration.response;\n                        delete functionDeclaration.response;\n                    }\n                }\n            }\n        }\n    }\n    return tool;\n}\nfunction tTools(tools) {\n    // Check if the incoming type is defined.\n    if (tools === undefined || tools === null) {\n        throw new Error(\"tools is required\");\n    }\n    if (!Array.isArray(tools)) {\n        throw new Error(\"tools is required and must be an array of Tools\");\n    }\n    const result = [];\n    for (const tool of tools){\n        result.push(tool);\n    }\n    return result;\n}\n/**\n * Prepends resource name with project, location, resource_prefix if needed.\n *\n * @param client The API client.\n * @param resourceName The resource name.\n * @param resourcePrefix The resource prefix.\n * @param splitsAfterPrefix The number of splits after the prefix.\n * @returns The completed resource name.\n *\n * Examples:\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/bar/locations/us-west1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'projects/foo/locations/us-central1/cachedContents/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/foo/locations/us-central1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns 'cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'some/wrong/cachedContents/resource/name/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * # client.vertexai = True\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * -> 'some/wrong/resource/name/123'\n * ```\n */ function resourceName(client, resourceName, resourcePrefix, splitsAfterPrefix = 1) {\n    const shouldAppendPrefix = !resourceName.startsWith(`${resourcePrefix}/`) && resourceName.split(\"/\").length === splitsAfterPrefix;\n    if (client.isVertexAI()) {\n        if (resourceName.startsWith(\"projects/\")) {\n            return resourceName;\n        } else if (resourceName.startsWith(\"locations/\")) {\n            return `projects/${client.getProject()}/${resourceName}`;\n        } else if (resourceName.startsWith(`${resourcePrefix}/`)) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName}`;\n        } else if (shouldAppendPrefix) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName}`;\n        } else {\n            return resourceName;\n        }\n    }\n    if (shouldAppendPrefix) {\n        return `${resourcePrefix}/${resourceName}`;\n    }\n    return resourceName;\n}\nfunction tCachedContentName(apiClient, name) {\n    if (typeof name !== \"string\") {\n        throw new Error(\"name must be a string\");\n    }\n    return resourceName(apiClient, name, \"cachedContents\");\n}\nfunction tTuningJobStatus(status) {\n    switch(status){\n        case \"STATE_UNSPECIFIED\":\n            return \"JOB_STATE_UNSPECIFIED\";\n        case \"CREATING\":\n            return \"JOB_STATE_RUNNING\";\n        case \"ACTIVE\":\n            return \"JOB_STATE_SUCCEEDED\";\n        case \"FAILED\":\n            return \"JOB_STATE_FAILED\";\n        default:\n            return status;\n    }\n}\nfunction tBytes(fromImageBytes) {\n    return tBytes$1(fromImageBytes);\n}\nfunction _isFile(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"name\" in origin;\n}\nfunction isGeneratedVideo(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"video\" in origin;\n}\nfunction isVideo(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"uri\" in origin;\n}\nfunction tFileName(fromName) {\n    var _a;\n    let name;\n    if (_isFile(fromName)) {\n        name = fromName.name;\n    }\n    if (isVideo(fromName)) {\n        name = fromName.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (isGeneratedVideo(fromName)) {\n        name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (typeof fromName === \"string\") {\n        name = fromName;\n    }\n    if (name === undefined) {\n        throw new Error(\"Could not extract file name from the provided input.\");\n    }\n    if (name.startsWith(\"https://\")) {\n        const suffix = name.split(\"files/\")[1];\n        const match = suffix.match(/[a-z0-9]+/);\n        if (match === null) {\n            throw new Error(`Could not extract file name from URI ${name}`);\n        }\n        name = match[0];\n    } else if (name.startsWith(\"files/\")) {\n        name = name.split(\"files/\")[1];\n    }\n    return name;\n}\nfunction tModelsUrl(apiClient, baseModels) {\n    let res;\n    if (apiClient.isVertexAI()) {\n        res = baseModels ? \"publishers/google/models\" : \"models\";\n    } else {\n        res = baseModels ? \"models\" : \"tunedModels\";\n    }\n    return res;\n}\nfunction tExtractModels(response) {\n    for (const key of [\n        \"models\",\n        \"tunedModels\",\n        \"publisherModels\"\n    ]){\n        if (hasField(response, key)) {\n            return response[key];\n        }\n    }\n    return [];\n}\nfunction hasField(data, fieldName) {\n    return data !== null && typeof data === \"object\" && fieldName in data;\n}\nfunction mcpToGeminiTool(mcpTool, config = {}) {\n    const mcpToolSchema = mcpTool;\n    const functionDeclaration = {\n        name: mcpToolSchema[\"name\"],\n        description: mcpToolSchema[\"description\"],\n        parametersJsonSchema: mcpToolSchema[\"inputSchema\"]\n    };\n    if (mcpToolSchema[\"outputSchema\"]) {\n        functionDeclaration[\"responseJsonSchema\"] = mcpToolSchema[\"outputSchema\"];\n    }\n    if (config.behavior) {\n        functionDeclaration[\"behavior\"] = config.behavior;\n    }\n    const geminiTool = {\n        functionDeclarations: [\n            functionDeclaration\n        ]\n    };\n    return geminiTool;\n}\n/**\n * Converts a list of MCP tools to a single Gemini tool with a list of function\n * declarations.\n */ function mcpToolsToGeminiTool(mcpTools, config = {}) {\n    const functionDeclarations = [];\n    const toolNames = new Set();\n    for (const mcpTool of mcpTools){\n        const mcpToolName = mcpTool.name;\n        if (toolNames.has(mcpToolName)) {\n            throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n        }\n        toolNames.add(mcpToolName);\n        const geminiTool = mcpToGeminiTool(mcpTool, config);\n        if (geminiTool.functionDeclarations) {\n            functionDeclarations.push(...geminiTool.functionDeclarations);\n        }\n    }\n    return {\n        functionDeclarations: functionDeclarations\n    };\n}\n// Transforms a source input into a BatchJobSource object with validation.\nfunction tBatchJobSource(client, src) {\n    let sourceObj;\n    if (typeof src === \"string\") {\n        if (client.isVertexAI()) {\n            if (src.startsWith(\"gs://\")) {\n                sourceObj = {\n                    format: \"jsonl\",\n                    gcsUri: [\n                        src\n                    ]\n                };\n            } else if (src.startsWith(\"bq://\")) {\n                sourceObj = {\n                    format: \"bigquery\",\n                    bigqueryUri: src\n                };\n            } else {\n                throw new Error(`Unsupported string source for Vertex AI: ${src}`);\n            }\n        } else {\n            // MLDEV\n            if (src.startsWith(\"files/\")) {\n                sourceObj = {\n                    fileName: src\n                }; // Default to fileName for string input\n            } else {\n                throw new Error(`Unsupported string source for Gemini API: ${src}`);\n            }\n        }\n    } else if (Array.isArray(src)) {\n        if (client.isVertexAI()) {\n            throw new Error(\"InlinedRequest[] is not supported in Vertex AI.\");\n        }\n        sourceObj = {\n            inlinedRequests: src\n        };\n    } else {\n        // It's already a BatchJobSource object\n        sourceObj = src;\n    }\n    // Validation logic\n    const vertexSourcesCount = [\n        sourceObj.gcsUri,\n        sourceObj.bigqueryUri\n    ].filter(Boolean).length;\n    const mldevSourcesCount = [\n        sourceObj.inlinedRequests,\n        sourceObj.fileName\n    ].filter(Boolean).length;\n    if (client.isVertexAI()) {\n        if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {\n            throw new Error(\"Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.\");\n        }\n    } else {\n        // MLDEV\n        if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {\n            throw new Error(\"Exactly one of `inlinedRequests`, `fileName`, \" + \"must be set for Gemini API.\");\n        }\n    }\n    return sourceObj;\n}\nfunction tBatchJobDestination(dest) {\n    if (typeof dest !== \"string\") {\n        return dest;\n    }\n    const destString = dest;\n    if (destString.startsWith(\"gs://\")) {\n        return {\n            format: \"jsonl\",\n            gcsUri: destString\n        };\n    } else if (destString.startsWith(\"bq://\")) {\n        return {\n            format: \"bigquery\",\n            bigqueryUri: destString\n        };\n    } else {\n        throw new Error(`Unsupported destination: ${destString}`);\n    }\n}\nfunction tRecvBatchJobDestination(dest) {\n    // Ensure dest is a non-null object before proceeding.\n    if (typeof dest !== \"object\" || dest === null) {\n        // If the input is not an object, it cannot be a valid BatchJobDestination\n        // based on the operations performed. Return it cast, or handle as an error.\n        // Casting an empty object might be a safe default.\n        return {};\n    }\n    // Cast to Record<string, unknown> to allow string property access.\n    const obj = dest;\n    // Safely access nested properties.\n    const inlineResponsesVal = obj[\"inlinedResponses\"];\n    if (typeof inlineResponsesVal !== \"object\" || inlineResponsesVal === null) {\n        return dest;\n    }\n    const inlineResponsesObj = inlineResponsesVal;\n    const responsesArray = inlineResponsesObj[\"inlinedResponses\"];\n    if (!Array.isArray(responsesArray) || responsesArray.length === 0) {\n        return dest;\n    }\n    // Check if any response has the 'embedding' property.\n    let hasEmbedding = false;\n    for (const responseItem of responsesArray){\n        if (typeof responseItem !== \"object\" || responseItem === null) {\n            continue;\n        }\n        const responseItemObj = responseItem;\n        const responseVal = responseItemObj[\"response\"];\n        if (typeof responseVal !== \"object\" || responseVal === null) {\n            continue;\n        }\n        const responseObj = responseVal;\n        // Check for the existence of the 'embedding' key.\n        if (responseObj[\"embedding\"] !== undefined) {\n            hasEmbedding = true;\n            break;\n        }\n    }\n    // Perform the transformation if an embedding was found.\n    if (hasEmbedding) {\n        obj[\"inlinedEmbedContentResponses\"] = obj[\"inlinedResponses\"];\n        delete obj[\"inlinedResponses\"];\n    }\n    // Cast the (potentially) modified object to the target type.\n    return dest;\n}\nfunction tBatchJobName(apiClient, name) {\n    const nameString = name;\n    if (!apiClient.isVertexAI()) {\n        const mldevPattern = /batches\\/[^/]+$/;\n        if (mldevPattern.test(nameString)) {\n            return nameString.split(\"/\").pop();\n        } else {\n            throw new Error(`Invalid batch job name: ${nameString}.`);\n        }\n    }\n    const vertexPattern = /^projects\\/[^/]+\\/locations\\/[^/]+\\/batchPredictionJobs\\/[^/]+$/;\n    if (vertexPattern.test(nameString)) {\n        return nameString.split(\"/\").pop();\n    } else if (/^\\d+$/.test(nameString)) {\n        return nameString;\n    } else {\n        throw new Error(`Invalid batch job name: ${nameString}.`);\n    }\n}\nfunction tJobState(state) {\n    const stateString = state;\n    if (stateString === \"BATCH_STATE_UNSPECIFIED\") {\n        return \"JOB_STATE_UNSPECIFIED\";\n    } else if (stateString === \"BATCH_STATE_PENDING\") {\n        return \"JOB_STATE_PENDING\";\n    } else if (stateString === \"BATCH_STATE_RUNNING\") {\n        return \"JOB_STATE_RUNNING\";\n    } else if (stateString === \"BATCH_STATE_SUCCEEDED\") {\n        return \"JOB_STATE_SUCCEEDED\";\n    } else if (stateString === \"BATCH_STATE_FAILED\") {\n        return \"JOB_STATE_FAILED\";\n    } else if (stateString === \"BATCH_STATE_CANCELLED\") {\n        return \"JOB_STATE_CANCELLED\";\n    } else if (stateString === \"BATCH_STATE_EXPIRED\") {\n        return \"JOB_STATE_EXPIRED\";\n    } else {\n        return stateString;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function batchJobDestinationFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, [\n        \"responsesFile\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromInlinedResponses = getValueByPath(fromObject, [\n        \"inlinedResponses\",\n        \"inlinedResponses\"\n    ]);\n    if (fromInlinedResponses != null) {\n        let transformedList = fromInlinedResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return inlinedResponseFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"inlinedResponses\"\n        ], transformedList);\n    }\n    const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [\n        \"inlinedEmbedContentResponses\",\n        \"inlinedResponses\"\n    ]);\n    if (fromInlinedEmbedContentResponses != null) {\n        let transformedList = fromInlinedEmbedContentResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return inlinedEmbedContentResponseFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"inlinedEmbedContentResponses\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobDestinationFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"predictionsFormat\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsDestination\",\n        \"outputUriPrefix\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryDestination\",\n        \"outputUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryUri\"\n        ], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobDestinationToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"predictionsFormat\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsDestination\",\n            \"outputUriPrefix\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryDestination\",\n            \"outputUri\"\n        ], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileName\"\n    ]) !== undefined) {\n        throw new Error(\"fileName parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedResponses\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedResponses parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedEmbedContentResponses\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedEmbedContentResponses parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction batchJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"metadata\",\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"metadata\",\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tJobState(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"metadata\",\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"metadata\",\n        \"output\"\n    ]);\n    if (fromDest != null) {\n        setValueByPath(toObject, [\n            \"dest\"\n        ], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction batchJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tJobState(fromState));\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], jobErrorFromVertex(fromError));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"inputConfig\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"src\"\n        ], batchJobSourceFromVertex(fromSrc));\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"outputConfig\"\n    ]);\n    if (fromDest != null) {\n        setValueByPath(toObject, [\n            \"dest\"\n        ], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction batchJobSourceFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"instancesFormat\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsSource\",\n        \"uris\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigquerySource\",\n        \"inputUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryUri\"\n        ], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"format\"\n    ]) !== undefined) {\n        throw new Error(\"format parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]) !== undefined) {\n        throw new Error(\"bigqueryUri parameter is not supported in Gemini API.\");\n    }\n    const fromFileName = getValueByPath(fromObject, [\n        \"fileName\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]);\n    if (fromInlinedRequests != null) {\n        let transformedList = fromInlinedRequests;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return inlinedRequestToMldev(apiClient, item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"requests\",\n            \"requests\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobSourceToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"instancesFormat\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsSource\",\n            \"uris\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigquerySource\",\n            \"inputUri\"\n        ], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileName\"\n    ]) !== undefined) {\n        throw new Error(\"fileName parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedRequests parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction blobFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction candidateFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], contentFromMldev$2(fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromMldev$1(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], urlContextMetadataFromMldev$2(fromUrlContextMetadata));\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citationSources\"\n    ]);\n    if (fromCitations != null) {\n        setValueByPath(toObject, [\n            \"citations\"\n        ], fromCitations);\n    }\n    return toObject;\n}\nfunction computerUseToMldev$4(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        \"excludedPredefinedFunctions\"\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, [\n            \"excludedPredefinedFunctions\"\n        ], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, [\n        \"values\"\n    ]);\n    if (fromValues != null) {\n        setValueByPath(toObject, [\n            \"values\"\n        ], fromValues);\n    }\n    return toObject;\n}\nfunction contentFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contentToMldev$4(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"batch\",\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    if (getValueByPath(fromObject, [\n        \"dest\"\n    ]) !== undefined) {\n        throw new Error(\"dest parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"dest\"\n    ]);\n    if (parentObject !== undefined && fromDest != null) {\n        setValueByPath(parentObject, [\n            \"outputConfig\"\n        ], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"batch\",\n            \"inputConfig\"\n        ], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"inputConfig\"\n        ], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createBatchJobConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"batch\",\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"batch\",\n            \"inputConfig\"\n        ], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], jobErrorFromMldev(fromError));\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], jobErrorFromVertex(fromError));\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$4(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction embedContentBatchToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"request\",\n            \"content\"\n        ], tContentsForEmbed(apiClient, fromContents));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], embedContentConfigToMldev$1(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"taskType\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, [\n        \"mimeType\"\n    ]) !== undefined) {\n        throw new Error(\"mimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]) !== undefined) {\n        throw new Error(\"autoTruncate parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction embeddingsBatchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, [\n        \"fileName\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"file_name\"\n        ], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]);\n    if (fromInlinedRequests != null) {\n        setValueByPath(toObject, [\n            \"requests\"\n        ], embedContentBatchToMldev(apiClient, fromInlinedRequests));\n    }\n    return toObject;\n}\nfunction fileDataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$4(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$4(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$4(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], schemaToMldev$1(tSchema(fromResponseSchema)));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]) !== undefined) {\n        throw new Error(\"routingConfig parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]) !== undefined) {\n        throw new Error(\"modelSelectionConfig parameter is not supported in Gemini API.\");\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToMldev$1(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$4(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev$2(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToMldev$3(tSpeechConfig(fromSpeechConfig)));\n    }\n    if (getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]) !== undefined) {\n        throw new Error(\"audioTimestamp parameter is not supported in Gemini API.\");\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], thinkingConfigToMldev$3(fromThinkingConfig));\n    }\n    const fromImageConfig = getValueByPath(fromObject, [\n        \"imageConfig\"\n    ]);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, [\n            \"imageConfig\"\n        ], imageConfigToMldev$1(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$4(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$4(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$4(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev$4(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction imageConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, [\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    return toObject;\n}\nfunction inlinedEmbedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], singleEmbedContentResponseFromMldev(fromResponse));\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], jobErrorFromMldev(fromError));\n    }\n    return toObject;\n}\nfunction inlinedRequestToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"request\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"request\",\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"request\",\n            \"generationConfig\"\n        ], generateContentConfigToMldev$1(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction inlinedResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateContentResponseFromMldev$1(fromResponse));\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], jobErrorFromMldev(fromError));\n    }\n    return toObject;\n}\nfunction intervalToMldev$4(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction jobErrorFromMldev(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, [\n        \"details\"\n    ]);\n    if (fromDetails != null) {\n        setValueByPath(toObject, [\n            \"details\"\n        ], fromDetails);\n    }\n    const fromCode = getValueByPath(fromObject, [\n        \"code\"\n    ]);\n    if (fromCode != null) {\n        setValueByPath(toObject, [\n            \"code\"\n        ], fromCode);\n    }\n    const fromMessage = getValueByPath(fromObject, [\n        \"message\"\n    ]);\n    if (fromMessage != null) {\n        setValueByPath(toObject, [\n            \"message\"\n        ], fromMessage);\n    }\n    return toObject;\n}\nfunction jobErrorFromVertex(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, [\n        \"details\"\n    ]);\n    if (fromDetails != null) {\n        setValueByPath(toObject, [\n            \"details\"\n        ], fromDetails);\n    }\n    const fromCode = getValueByPath(fromObject, [\n        \"code\"\n    ]);\n    if (fromCode != null) {\n        setValueByPath(toObject, [\n            \"code\"\n        ], fromCode);\n    }\n    const fromMessage = getValueByPath(fromObject, [\n        \"message\"\n    ]);\n    if (fromMessage != null) {\n        setValueByPath(toObject, [\n            \"message\"\n        ], fromMessage);\n    }\n    return toObject;\n}\nfunction latLngToMldev$2(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    if (getValueByPath(fromObject, [\n        \"filter\"\n    ]) !== undefined) {\n        throw new Error(\"filter parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listBatchJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listBatchJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        \"operations\"\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return batchJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"batchJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        \"batchPredictionJobs\"\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return batchJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"batchJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        \"speakerVoiceConfigs\"\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return speakerVoiceConfigToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"speakerVoiceConfigs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromMldev$2(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromMldev$2(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromMldev$2(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallFromMldev$2(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction partToMldev$4(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev$4(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$4(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$4(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$4(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction retrievalConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToMldev$2(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"method\"\n    ]) !== undefined) {\n        throw new Error(\"method parameter is not supported in Gemini API.\");\n    }\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction schemaToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAnyOf = getValueByPath(fromObject, [\n        \"anyOf\"\n    ]);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, [\n            \"anyOf\"\n        ], fromAnyOf);\n    }\n    const fromDefault = getValueByPath(fromObject, [\n        \"default\"\n    ]);\n    if (fromDefault != null) {\n        setValueByPath(toObject, [\n            \"default\"\n        ], fromDefault);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, [\n        \"enum\"\n    ]);\n    if (fromEnum != null) {\n        setValueByPath(toObject, [\n            \"enum\"\n        ], fromEnum);\n    }\n    const fromExample = getValueByPath(fromObject, [\n        \"example\"\n    ]);\n    if (fromExample != null) {\n        setValueByPath(toObject, [\n            \"example\"\n        ], fromExample);\n    }\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, [\n        \"items\"\n    ]);\n    if (fromItems != null) {\n        setValueByPath(toObject, [\n            \"items\"\n        ], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, [\n        \"maxItems\"\n    ]);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, [\n            \"maxItems\"\n        ], fromMaxItems);\n    }\n    const fromMaxLength = getValueByPath(fromObject, [\n        \"maxLength\"\n    ]);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, [\n            \"maxLength\"\n        ], fromMaxLength);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        \"maxProperties\"\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, [\n            \"maxProperties\"\n        ], fromMaxProperties);\n    }\n    const fromMaximum = getValueByPath(fromObject, [\n        \"maximum\"\n    ]);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, [\n            \"maximum\"\n        ], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, [\n        \"minItems\"\n    ]);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, [\n            \"minItems\"\n        ], fromMinItems);\n    }\n    const fromMinLength = getValueByPath(fromObject, [\n        \"minLength\"\n    ]);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, [\n            \"minLength\"\n        ], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        \"minProperties\"\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, [\n            \"minProperties\"\n        ], fromMinProperties);\n    }\n    const fromMinimum = getValueByPath(fromObject, [\n        \"minimum\"\n    ]);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, [\n            \"minimum\"\n        ], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, [\n        \"nullable\"\n    ]);\n    if (fromNullable != null) {\n        setValueByPath(toObject, [\n            \"nullable\"\n        ], fromNullable);\n    }\n    const fromPattern = getValueByPath(fromObject, [\n        \"pattern\"\n    ]);\n    if (fromPattern != null) {\n        setValueByPath(toObject, [\n            \"pattern\"\n        ], fromPattern);\n    }\n    const fromProperties = getValueByPath(fromObject, [\n        \"properties\"\n    ]);\n    if (fromProperties != null) {\n        setValueByPath(toObject, [\n            \"properties\"\n        ], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        \"propertyOrdering\"\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, [\n            \"propertyOrdering\"\n        ], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, [\n        \"required\"\n    ]);\n    if (fromRequired != null) {\n        setValueByPath(toObject, [\n            \"required\"\n        ], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (fromTitle != null) {\n        setValueByPath(toObject, [\n            \"title\"\n        ], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, [\n        \"type\"\n    ]);\n    if (fromType != null) {\n        setValueByPath(toObject, [\n            \"type\"\n        ], fromType);\n    }\n    return toObject;\n}\nfunction singleEmbedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromEmbedding = getValueByPath(fromObject, [\n        \"embedding\"\n    ]);\n    if (fromEmbedding != null) {\n        setValueByPath(toObject, [\n            \"embedding\"\n        ], contentEmbeddingFromMldev$1(fromEmbedding));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, [\n        \"speaker\"\n    ]);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, [\n            \"speaker\"\n        ], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$3(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction speechConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$3(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"multiSpeakerVoiceConfig\"\n        ], multiSpeakerVoiceConfigToMldev$3(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev$2(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToMldev$2(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$4(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$4(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$4(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev$4());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], computerUseToMldev$4(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, [\n        \"urlMetadata\"\n    ]);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return urlMetadataFromMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"urlMetadata\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction urlContextToMldev$4() {\n    const toObject = {};\n    return toObject;\n}\nfunction urlMetadataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, [\n        \"retrievedUrl\"\n    ]);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, [\n            \"retrievedUrl\"\n        ], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        \"urlRetrievalStatus\"\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, [\n            \"urlRetrievalStatus\"\n        ], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction videoMetadataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataToMldev$4(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToMldev$3(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ var PagedItem;\n(function(PagedItem) {\n    PagedItem[\"PAGED_ITEM_BATCH_JOBS\"] = \"batchJobs\";\n    PagedItem[\"PAGED_ITEM_MODELS\"] = \"models\";\n    PagedItem[\"PAGED_ITEM_TUNING_JOBS\"] = \"tuningJobs\";\n    PagedItem[\"PAGED_ITEM_FILES\"] = \"files\";\n    PagedItem[\"PAGED_ITEM_CACHED_CONTENTS\"] = \"cachedContents\";\n})(PagedItem || (PagedItem = {}));\n/**\n * Pager class for iterating through paginated results.\n */ class Pager {\n    constructor(name, request, response, params){\n        this.pageInternal = [];\n        this.paramsInternal = {};\n        this.requestInternal = request;\n        this.init(name, response, params);\n    }\n    init(name, response, params) {\n        var _a, _b;\n        this.nameInternal = name;\n        this.pageInternal = response[this.nameInternal] || [];\n        this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;\n        this.idxInternal = 0;\n        let requestParams = {\n            config: {}\n        };\n        if (!params || Object.keys(params).length === 0) {\n            requestParams = {\n                config: {}\n            };\n        } else if (typeof params === \"object\") {\n            requestParams = Object.assign({}, params);\n        } else {\n            requestParams = params;\n        }\n        if (requestParams[\"config\"]) {\n            requestParams[\"config\"][\"pageToken\"] = response[\"nextPageToken\"];\n        }\n        this.paramsInternal = requestParams;\n        this.pageInternalSize = (_b = (_a = requestParams[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageSize\"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;\n    }\n    initNextPage(response) {\n        this.init(this.nameInternal, response, this.paramsInternal);\n    }\n    /**\n     * Returns the current page, which is a list of items.\n     *\n     * @remarks\n     * The first page is retrieved when the pager is created. The returned list of\n     * items could be a subset of the entire list.\n     */ get page() {\n        return this.pageInternal;\n    }\n    /**\n     * Returns the type of paged item (for example, ``batch_jobs``).\n     */ get name() {\n        return this.nameInternal;\n    }\n    /**\n     * Returns the length of the page fetched each time by this pager.\n     *\n     * @remarks\n     * The number of items in the page is less than or equal to the page length.\n     */ get pageSize() {\n        return this.pageInternalSize;\n    }\n    /**\n     * Returns the headers of the API response.\n     */ get sdkHttpResponse() {\n        return this.sdkHttpResponseInternal;\n    }\n    /**\n     * Returns the parameters when making the API request for the next page.\n     *\n     * @remarks\n     * Parameters contain a set of optional configs that can be\n     * used to customize the API request. For example, the `pageToken` parameter\n     * contains the token to request the next page.\n     */ get params() {\n        return this.paramsInternal;\n    }\n    /**\n     * Returns the total number of items in the current page.\n     */ get pageLength() {\n        return this.pageInternal.length;\n    }\n    /**\n     * Returns the item at the given index.\n     */ getItem(index) {\n        return this.pageInternal[index];\n    }\n    /**\n     * Returns an async iterator that support iterating through all items\n     * retrieved from the API.\n     *\n     * @remarks\n     * The iterator will automatically fetch the next page if there are more items\n     * to fetch from the API.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * for await (const file of pager) {\n     *   console.log(file.name);\n     * }\n     * ```\n     */ [Symbol.asyncIterator]() {\n        return {\n            next: async ()=>{\n                if (this.idxInternal >= this.pageLength) {\n                    if (this.hasNextPage()) {\n                        await this.nextPage();\n                    } else {\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                }\n                const item = this.getItem(this.idxInternal);\n                this.idxInternal += 1;\n                return {\n                    value: item,\n                    done: false\n                };\n            },\n            return: async ()=>{\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     * Fetches the next page of items. This makes a new API request.\n     *\n     * @throws {Error} If there are no more pages to fetch.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * let page = pager.page;\n     * while (true) {\n     *   for (const file of page) {\n     *     console.log(file.name);\n     *   }\n     *   if (!pager.hasNextPage()) {\n     *     break;\n     *   }\n     *   page = await pager.nextPage();\n     * }\n     * ```\n     */ async nextPage() {\n        if (!this.hasNextPage()) {\n            throw new Error(\"No more pages to fetch.\");\n        }\n        const response = await this.requestInternal(this.params);\n        this.initNextPage(response);\n        return this.page;\n    }\n    /**\n     * Returns true if there are more pages to fetch from the API.\n     */ hasNextPage() {\n        var _a;\n        if (((_a = this.params[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageToken\"]) !== undefined) {\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Batches extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Create batch job.\n         *\n         * @param params - The parameters for create batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.create({\n         *   model: 'gemini-2.0-flash',\n         *   src: {gcsUri: 'gs://bucket/path/to/file.jsonl', format: 'jsonl'},\n         *   config: {\n         *     dest: {gcsUri: 'gs://bucket/path/output/directory', format: 'jsonl'},\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */ this.create = async (params)=>{\n            var _a, _b;\n            if (this.apiClient.isVertexAI()) {\n                // Format destination if not provided\n                // Cast params.src as Vertex AI path does not handle InlinedRequest[]\n                params.config = this.formatDestination(params.src, params.config);\n                return this.createInternal(params);\n            }\n            // MLDEV\n            const src = params.src;\n            const is_inlined = Array.isArray(params.src) || src.inlinedRequests !== undefined;\n            if (!is_inlined) {\n                return this.createInternal(params);\n            }\n            // Inlined generate content requests handling\n            const result = this.createInlinedGenerateContentRequest(params);\n            const path = result.path;\n            const requestBody = result.body;\n            const queryParams = createBatchJobParametersToMldev(this.apiClient, params)[\"_query\"] || {};\n            const response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(requestBody),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        };\n        /**\n         * **Experimental** Creates an embedding batch job.\n         *\n         * @param params - The parameters for create embedding batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.createEmbeddings({\n         *   model: 'text-embedding-004',\n         *   src: {fileName: 'files/my_embedding_input'},\n         * });\n         * console.log(response);\n         * ```\n         */ this.createEmbeddings = async (params)=>{\n            var _a, _b;\n            console.warn(\"batches.createEmbeddings() is experimental and may change without notice.\");\n            if (this.apiClient.isVertexAI()) {\n                throw new Error(\"Vertex AI does not support batches.createEmbeddings.\");\n            }\n            // MLDEV\n            const src = params.src;\n            const is_inlined = src.inlinedRequests !== undefined;\n            if (!is_inlined) {\n                return this.createEmbeddingsInternal(params); // Fixed typo here\n            }\n            // Inlined embed content requests handling\n            const result = this.createInlinedEmbedContentRequest(params);\n            const path = result.path;\n            const requestBody = result.body;\n            const queryParams = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params)[\"_query\"] || {};\n            const response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(requestBody),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        };\n        /**\n         * Lists batch job configurations.\n         *\n         * @param params - The parameters for the list request.\n         * @return The paginated results of the list of batch jobs.\n         *\n         * @example\n         * ```ts\n         * const batchJobs = await ai.batches.list({config: {'pageSize': 2}});\n         * for await (const batchJob of batchJobs) {\n         *   console.log(batchJob);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    // Helper function to handle inlined generate content requests\n    createInlinedGenerateContentRequest(params) {\n        const body = createBatchJobParametersToMldev(this.apiClient, params);\n        const urlParams = body[\"_url\"];\n        const path = formatMap(\"{model}:batchGenerateContent\", urlParams);\n        const batch = body[\"batch\"];\n        const inputConfig = batch[\"inputConfig\"];\n        const requestsWrapper = inputConfig[\"requests\"];\n        const requests = requestsWrapper[\"requests\"];\n        const newRequests = [];\n        for (const request of requests){\n            const requestDict = Object.assign({}, request); // Clone\n            if (requestDict[\"systemInstruction\"]) {\n                const systemInstructionValue = requestDict[\"systemInstruction\"];\n                delete requestDict[\"systemInstruction\"];\n                const requestContent = requestDict[\"request\"];\n                requestContent[\"systemInstruction\"] = systemInstructionValue;\n                requestDict[\"request\"] = requestContent;\n            }\n            newRequests.push(requestDict);\n        }\n        requestsWrapper[\"requests\"] = newRequests;\n        delete body[\"config\"];\n        delete body[\"_url\"];\n        delete body[\"_query\"];\n        return {\n            path,\n            body\n        };\n    }\n    // Helper function to handle inlined embedding requests\n    createInlinedEmbedContentRequest(params) {\n        const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);\n        const urlParams = body[\"_url\"];\n        const path = formatMap(\"{model}:asyncBatchEmbedContent\", urlParams);\n        const batch = body[\"batch\"];\n        const inputConfig = batch[\"inputConfig\"];\n        const requestsWrapper = inputConfig[\"requests\"];\n        const requests = requestsWrapper[\"requests\"];\n        const newRequests = [];\n        delete requestsWrapper[\"config\"]; // Remove top-level config\n        for (const request of requests){\n            const requestDict = Object.assign({}, request); // Clone\n            const innerRequest = requestDict[\"request\"];\n            for(const key in requestDict){\n                if (key !== \"request\") {\n                    innerRequest[key] = requestDict[key];\n                    delete requestDict[key];\n                }\n            }\n            newRequests.push(requestDict);\n        }\n        requestsWrapper[\"requests\"] = newRequests;\n        delete body[\"config\"];\n        delete body[\"_url\"];\n        delete body[\"_query\"];\n        return {\n            path,\n            body\n        };\n    }\n    // Helper function to get the first GCS URI\n    getGcsUri(src) {\n        if (typeof src === \"string\") {\n            return src.startsWith(\"gs://\") ? src : undefined;\n        }\n        if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {\n            return src.gcsUri[0];\n        }\n        return undefined;\n    }\n    // Helper function to get the BigQuery URI\n    getBigqueryUri(src) {\n        if (typeof src === \"string\") {\n            return src.startsWith(\"bq://\") ? src : undefined;\n        }\n        if (!Array.isArray(src)) {\n            return src.bigqueryUri;\n        }\n        return undefined;\n    }\n    // Function to format the destination configuration for Vertex AI\n    formatDestination(src, config) {\n        const newConfig = config ? Object.assign({}, config) : {};\n        const timestampStr = Date.now().toString();\n        if (!newConfig.displayName) {\n            newConfig.displayName = `genaiBatchJob_${timestampStr}`;\n        }\n        if (newConfig.dest === undefined) {\n            const gcsUri = this.getGcsUri(src);\n            const bigqueryUri = this.getBigqueryUri(src);\n            if (gcsUri) {\n                if (gcsUri.endsWith(\".jsonl\")) {\n                    // For .jsonl files, remove suffix and add /dest\n                    newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;\n                } else {\n                    // Fallback for other GCS URIs\n                    newConfig.dest = `${gcsUri}_dest_${timestampStr}`;\n                }\n            } else if (bigqueryUri) {\n                newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;\n            } else {\n                throw new Error(\"Unsupported source for Vertex AI: No GCS or BigQuery URI found.\");\n            }\n        }\n        return newConfig;\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */ async createInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = createBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:batchGenerateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */ async createEmbeddingsInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:asyncBatchEmbedContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets batch job configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The batch job.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Cancels a batch job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n        } else {\n            const body = cancelBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listBatchJobsParametersToVertex(params);\n            path = formatMap(\"batchPredictionJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listBatchJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listBatchJobsParametersToMldev(params);\n            path = formatMap(\"batches\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listBatchJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Deletes a batch job.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteResourceJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = deleteBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteResourceJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function apiKeyConfigToVertex$2(fromObject) {\n    const toObject = {};\n    const fromApiKeyString = getValueByPath(fromObject, [\n        \"apiKeyString\"\n    ]);\n    if (fromApiKeyString != null) {\n        setValueByPath(toObject, [\n            \"apiKeyString\"\n        ], fromApiKeyString);\n    }\n    return toObject;\n}\nfunction authConfigToVertex$2(fromObject) {\n    const toObject = {};\n    const fromApiKeyConfig = getValueByPath(fromObject, [\n        \"apiKeyConfig\"\n    ]);\n    if (fromApiKeyConfig != null) {\n        setValueByPath(toObject, [\n            \"apiKeyConfig\"\n        ], apiKeyConfigToVertex$2(fromApiKeyConfig));\n    }\n    const fromAuthType = getValueByPath(fromObject, [\n        \"authType\"\n    ]);\n    if (fromAuthType != null) {\n        setValueByPath(toObject, [\n            \"authType\"\n        ], fromAuthType);\n    }\n    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [\n        \"googleServiceAccountConfig\"\n    ]);\n    if (fromGoogleServiceAccountConfig != null) {\n        setValueByPath(toObject, [\n            \"googleServiceAccountConfig\"\n        ], fromGoogleServiceAccountConfig);\n    }\n    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [\n        \"httpBasicAuthConfig\"\n    ]);\n    if (fromHttpBasicAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"httpBasicAuthConfig\"\n        ], fromHttpBasicAuthConfig);\n    }\n    const fromOauthConfig = getValueByPath(fromObject, [\n        \"oauthConfig\"\n    ]);\n    if (fromOauthConfig != null) {\n        setValueByPath(toObject, [\n            \"oauthConfig\"\n        ], fromOauthConfig);\n    }\n    const fromOidcConfig = getValueByPath(fromObject, [\n        \"oidcConfig\"\n    ]);\n    if (fromOidcConfig != null) {\n        setValueByPath(toObject, [\n            \"oidcConfig\"\n        ], fromOidcConfig);\n    }\n    return toObject;\n}\nfunction blobToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction cachedContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (fromExpireTime != null) {\n        setValueByPath(toObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction cachedContentFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (fromExpireTime != null) {\n        setValueByPath(toObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction computerUseToMldev$3(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        \"excludedPredefinedFunctions\"\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, [\n            \"excludedPredefinedFunctions\"\n        ], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction computerUseToVertex$2(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        \"excludedPredefinedFunctions\"\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, [\n            \"excludedPredefinedFunctions\"\n        ], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction contentToMldev$3(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contentToVertex$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$3(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev$1(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"kmsKeyName\"\n    ]) !== undefined) {\n        throw new Error(\"kmsKeyName parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToVertex$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToVertex$1(fromToolConfig));\n    }\n    const fromKmsKeyName = getValueByPath(fromObject, [\n        \"kmsKeyName\"\n    ]);\n    if (parentObject !== undefined && fromKmsKeyName != null) {\n        setValueByPath(parentObject, [\n            \"encryption_spec\",\n            \"kmsKeyName\"\n        ], fromKmsKeyName);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction enterpriseWebSearchToVertex$2(fromObject) {\n    const toObject = {};\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, [\n            \"excludeDomains\"\n        ], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$3(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionCallToVertex$2(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$3(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToVertex$2(fromObject) {\n    const toObject = {};\n    const fromAuthConfig = getValueByPath(fromObject, [\n        \"authConfig\"\n    ]);\n    if (fromAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"authConfig\"\n        ], authConfigToVertex$2(fromAuthConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$3(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$3(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToVertex$2(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$3(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev$3(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction googleSearchToVertex$2(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToVertex$2(fromTimeRangeFilter));\n    }\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, [\n            \"excludeDomains\"\n        ], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction intervalToMldev$3(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction intervalToVertex$2(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction latLngToMldev$1(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction latLngToVertex$1(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listCachedContentsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listCachedContentsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return cachedContentFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"cachedContents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return cachedContentFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"cachedContents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$3(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev$3(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$3(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$3(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$3(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction partToVertex$2(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToVertex$2(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToVertex$2(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToVertex$2(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToVertex$2(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction retrievalConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToMldev$1(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction retrievalConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToVertex$1(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev$1(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToMldev$1(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToVertex$1(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToVertex$1(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$3(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$3(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$3(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev$3());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], computerUseToMldev$3(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction toolToVertex$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToVertex$2(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToVertex$2(fromGoogleSearchRetrieval));\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], enterpriseWebSearchToVertex$2(fromEnterpriseWebSearch));\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToVertex$2(fromGoogleMaps));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToVertex$2());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], computerUseToVertex$2(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction urlContextToMldev$3() {\n    const toObject = {};\n    return toObject;\n}\nfunction urlContextToVertex$2() {\n    const toObject = {};\n    return toObject;\n}\nfunction videoMetadataToMldev$3(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataToVertex$2(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Caches extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists cached content configurations.\n         *\n         * @param params - The parameters for the list request.\n         * @return The paginated results of the list of cached contents.\n         *\n         * @example\n         * ```ts\n         * const cachedContents = await ai.caches.list({config: {'pageSize': 2}});\n         * for await (const cachedContent of cachedContents) {\n         *   console.log(cachedContent);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Creates a cached contents resource.\n     *\n     * @remarks\n     * Context caching is only supported for specific models. See [Gemini\n     * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)\n     * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)\n     * for more information.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created cached content.\n     *\n     * @example\n     * ```ts\n     * const contents = ...; // Initialize the content to cache.\n     * const response = await ai.caches.create({\n     *   model: 'gemini-2.0-flash-001',\n     *   config: {\n     *    'contents': contents,\n     *    'displayName': 'test cache',\n     *    'systemInstruction': 'What is the sum of the two pdfs?',\n     *    'ttl': '86400s',\n     *  }\n     * });\n     * ```\n     */ async create(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = createCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets cached content configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The cached content.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes cached content.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteCachedContentResponseFromVertex(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = deleteCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteCachedContentResponseFromMldev(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates cached content configurations.\n     *\n     * @param params - The parameters for the update request.\n     * @return The updated cached content.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.caches.update({\n     *   name: '...',  // The server-generated resource name.\n     *   config: {'ttl': '7600s'}\n     * });\n     * ```\n     */ async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = updateCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listCachedContentsParametersToVertex(params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromVertex(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listCachedContentsParametersToMldev(params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromMldev(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function awaitReturn(f) {\n        return function(v) {\n            return Promise.resolve(v).then(f, reject);\n        };\n    }\n    function verb(n, f) {\n        if (g[n]) {\n            i[n] = function(v) {\n                return new Promise(function(a, b) {\n                    q.push([\n                        n,\n                        v,\n                        a,\n                        b\n                    ]) > 1 || resume(n, v);\n                });\n            };\n            if (f) i[n] = f(i[n]);\n        }\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Returns true if the response is valid, false otherwise.\n */ function isValidResponse(response) {\n    var _a;\n    if (response.candidates == undefined || response.candidates.length === 0) {\n        return false;\n    }\n    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;\n    if (content === undefined) {\n        return false;\n    }\n    return isValidContent(content);\n}\nfunction isValidContent(content) {\n    if (content.parts === undefined || content.parts.length === 0) {\n        return false;\n    }\n    for (const part of content.parts){\n        if (part === undefined || Object.keys(part).length === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Validates the history contains the correct roles.\n *\n * @throws Error if the history does not start with a user turn.\n * @throws Error if the history contains an invalid role.\n */ function validateHistory(history) {\n    // Empty history is valid.\n    if (history.length === 0) {\n        return;\n    }\n    for (const content of history){\n        if (content.role !== \"user\" && content.role !== \"model\") {\n            throw new Error(`Role must be user or model, but got ${content.role}.`);\n        }\n    }\n}\n/**\n * Extracts the curated (valid) history from a comprehensive history.\n *\n * @remarks\n * The model may sometimes generate invalid or empty contents(e.g., due to safty\n * filters or recitation). Extracting valid turns from the history\n * ensures that subsequent requests could be accpeted by the model.\n */ function extractCuratedHistory(comprehensiveHistory) {\n    if (comprehensiveHistory === undefined || comprehensiveHistory.length === 0) {\n        return [];\n    }\n    const curatedHistory = [];\n    const length = comprehensiveHistory.length;\n    let i = 0;\n    while(i < length){\n        if (comprehensiveHistory[i].role === \"user\") {\n            curatedHistory.push(comprehensiveHistory[i]);\n            i++;\n        } else {\n            const modelOutput = [];\n            let isValid = true;\n            while(i < length && comprehensiveHistory[i].role === \"model\"){\n                modelOutput.push(comprehensiveHistory[i]);\n                if (isValid && !isValidContent(comprehensiveHistory[i])) {\n                    isValid = false;\n                }\n                i++;\n            }\n            if (isValid) {\n                curatedHistory.push(...modelOutput);\n            } else {\n                // Remove the last user input when model content is invalid.\n                curatedHistory.pop();\n            }\n        }\n    }\n    return curatedHistory;\n}\n/**\n * A utility class to create a chat session.\n */ class Chats {\n    constructor(modelsModule, apiClient){\n        this.modelsModule = modelsModule;\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates a new chat session.\n     *\n     * @remarks\n     * The config in the params will be used for all requests within the chat\n     * session unless overridden by a per-request `config` in\n     * @see {@link types.SendMessageParameters#config}.\n     *\n     * @param params - Parameters for creating a chat session.\n     * @returns A new chat session.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({\n     *   model: 'gemini-2.0-flash'\n     *   config: {\n     *     temperature: 0.5,\n     *     maxOutputTokens: 1024,\n     *   }\n     * });\n     * ```\n     */ create(params) {\n        return new Chat(this.apiClient, this.modelsModule, params.model, params.config, // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        structuredClone(params.history));\n    }\n}\n/**\n * Chat session that enables sending messages to the model with previous\n * conversation context.\n *\n * @remarks\n * The session maintains all the turns between user and model.\n */ class Chat {\n    constructor(apiClient, modelsModule, model, config = {}, history = []){\n        this.apiClient = apiClient;\n        this.modelsModule = modelsModule;\n        this.model = model;\n        this.config = config;\n        this.history = history;\n        // A promise to represent the current state of the message being sent to the\n        // model.\n        this.sendPromise = Promise.resolve();\n        validateHistory(history);\n    }\n    /**\n     * Sends a message to the model and returns the response.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessageStream} for streaming method.\n     * @param params - parameters for sending messages within a chat session.\n     * @returns The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessage({\n     *   message: 'Why is the sky blue?'\n     * });\n     * console.log(response.text);\n     * ```\n     */ async sendMessage(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const responsePromise = this.modelsModule.generateContent({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        this.sendPromise = (async ()=>{\n            var _a, _b, _c;\n            const response = await responsePromise;\n            const outputContent = (_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n            // Because the AFC input contains the entire curated chat history in\n            // addition to the new user input, we need to truncate the AFC history\n            // to deduplicate the existing chat history.\n            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;\n            const index = this.getHistory(true).length;\n            let automaticFunctionCallingHistory = [];\n            if (fullAutomaticFunctionCallingHistory != null) {\n                automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];\n            }\n            const modelOutput = outputContent ? [\n                outputContent\n            ] : [];\n            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);\n            return;\n        })();\n        await this.sendPromise.catch(()=>{\n            // Resets sendPromise to avoid subsequent calls failing\n            this.sendPromise = Promise.resolve();\n        });\n        return responsePromise;\n    }\n    /**\n     * Sends a message to the model and returns the response in chunks.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessage} for non-streaming method.\n     * @param params - parameters for sending the message.\n     * @return The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessageStream({\n     *   message: 'Why is the sky blue?'\n     * });\n     * for await (const chunk of response) {\n     *   console.log(chunk.text);\n     * }\n     * ```\n     */ async sendMessageStream(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const streamResponse = this.modelsModule.generateContentStream({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        // Resolve the internal tracking of send completion promise - `sendPromise`\n        // for both success and failure response. The actual failure is still\n        // propagated by the `await streamResponse`.\n        this.sendPromise = streamResponse.then(()=>undefined).catch(()=>undefined);\n        const response = await streamResponse;\n        const result = this.processStreamResponse(response, inputContent);\n        return result;\n    }\n    /**\n     * Returns the chat history.\n     *\n     * @remarks\n     * The history is a list of contents alternating between user and model.\n     *\n     * There are two types of history:\n     * - The `curated history` contains only the valid turns between user and\n     * model, which will be included in the subsequent requests sent to the model.\n     * - The `comprehensive history` contains all turns, including invalid or\n     *   empty model outputs, providing a complete record of the history.\n     *\n     * The history is updated after receiving the response from the model,\n     * for streaming response, it means receiving the last chunk of the response.\n     *\n     * The `comprehensive history` is returned by default. To get the `curated\n     * history`, set the `curated` parameter to `true`.\n     *\n     * @param curated - whether to return the curated history or the comprehensive\n     *     history.\n     * @return History contents alternating between user and model for the entire\n     *     chat session.\n     */ getHistory(curated = false) {\n        const history = curated ? extractCuratedHistory(this.history) : this.history;\n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        return structuredClone(history);\n    }\n    processStreamResponse(streamResponse, inputContent) {\n        var _a, _b;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            var _c, e_1, _d, _e;\n            const outputContent = [];\n            try {\n                for(var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true){\n                    _e = streamResponse_1_1.value;\n                    _f = false;\n                    const chunk = _e;\n                    if (isValidResponse(chunk)) {\n                        const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n                        if (content !== undefined) {\n                            outputContent.push(content);\n                        }\n                    }\n                    yield yield __await(chunk);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n            this.recordHistory(inputContent, outputContent);\n        });\n    }\n    recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {\n        let outputContents = [];\n        if (modelOutput.length > 0 && modelOutput.every((content)=>content.role !== undefined)) {\n            outputContents = modelOutput;\n        } else {\n            // Appends an empty content when model returns empty response, so that the\n            // history is always alternating between user and model.\n            outputContents.push({\n                role: \"model\",\n                parts: []\n            });\n        }\n        if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {\n            this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));\n        } else {\n            this.history.push(userInput);\n        }\n        this.history.push(...outputContents);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * API errors raised by the GenAI API.\n */ class ApiError extends Error {\n    constructor(options){\n        super(options.message);\n        this.name = \"ApiError\";\n        this.status = options.status;\n        Object.setPrototypeOf(this, ApiError.prototype);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction createFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFile = getValueByPath(fromObject, [\n        \"file\"\n    ]);\n    if (fromFile != null) {\n        setValueByPath(toObject, [\n            \"file\"\n        ], fileToMldev(fromFile));\n    }\n    return toObject;\n}\nfunction createFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction deleteFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction fileFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromSizeBytes = getValueByPath(fromObject, [\n        \"sizeBytes\"\n    ]);\n    if (fromSizeBytes != null) {\n        setValueByPath(toObject, [\n            \"sizeBytes\"\n        ], fromSizeBytes);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromExpirationTime = getValueByPath(fromObject, [\n        \"expirationTime\"\n    ]);\n    if (fromExpirationTime != null) {\n        setValueByPath(toObject, [\n            \"expirationTime\"\n        ], fromExpirationTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromSha256Hash = getValueByPath(fromObject, [\n        \"sha256Hash\"\n    ]);\n    if (fromSha256Hash != null) {\n        setValueByPath(toObject, [\n            \"sha256Hash\"\n        ], fromSha256Hash);\n    }\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromDownloadUri = getValueByPath(fromObject, [\n        \"downloadUri\"\n    ]);\n    if (fromDownloadUri != null) {\n        setValueByPath(toObject, [\n            \"downloadUri\"\n        ], fromDownloadUri);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], fromState);\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        setValueByPath(toObject, [\n            \"source\"\n        ], fromSource);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fileStatusFromMldev(fromError));\n    }\n    return toObject;\n}\nfunction fileStatusFromMldev(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, [\n        \"details\"\n    ]);\n    if (fromDetails != null) {\n        setValueByPath(toObject, [\n            \"details\"\n        ], fromDetails);\n    }\n    const fromMessage = getValueByPath(fromObject, [\n        \"message\"\n    ]);\n    if (fromMessage != null) {\n        setValueByPath(toObject, [\n            \"message\"\n        ], fromMessage);\n    }\n    const fromCode = getValueByPath(fromObject, [\n        \"code\"\n    ]);\n    if (fromCode != null) {\n        setValueByPath(toObject, [\n            \"code\"\n        ], fromCode);\n    }\n    return toObject;\n}\nfunction fileStatusToMldev(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, [\n        \"details\"\n    ]);\n    if (fromDetails != null) {\n        setValueByPath(toObject, [\n            \"details\"\n        ], fromDetails);\n    }\n    const fromMessage = getValueByPath(fromObject, [\n        \"message\"\n    ]);\n    if (fromMessage != null) {\n        setValueByPath(toObject, [\n            \"message\"\n        ], fromMessage);\n    }\n    const fromCode = getValueByPath(fromObject, [\n        \"code\"\n    ]);\n    if (fromCode != null) {\n        setValueByPath(toObject, [\n            \"code\"\n        ], fromCode);\n    }\n    return toObject;\n}\nfunction fileToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromSizeBytes = getValueByPath(fromObject, [\n        \"sizeBytes\"\n    ]);\n    if (fromSizeBytes != null) {\n        setValueByPath(toObject, [\n            \"sizeBytes\"\n        ], fromSizeBytes);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromExpirationTime = getValueByPath(fromObject, [\n        \"expirationTime\"\n    ]);\n    if (fromExpirationTime != null) {\n        setValueByPath(toObject, [\n            \"expirationTime\"\n        ], fromExpirationTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromSha256Hash = getValueByPath(fromObject, [\n        \"sha256Hash\"\n    ]);\n    if (fromSha256Hash != null) {\n        setValueByPath(toObject, [\n            \"sha256Hash\"\n        ], fromSha256Hash);\n    }\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromDownloadUri = getValueByPath(fromObject, [\n        \"downloadUri\"\n    ]);\n    if (fromDownloadUri != null) {\n        setValueByPath(toObject, [\n            \"downloadUri\"\n        ], fromDownloadUri);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], fromState);\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        setValueByPath(toObject, [\n            \"source\"\n        ], fromSource);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fileStatusToMldev(fromError));\n    }\n    return toObject;\n}\nfunction getFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction listFilesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFilesParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listFilesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listFilesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromFiles = getValueByPath(fromObject, [\n        \"files\"\n    ]);\n    if (fromFiles != null) {\n        let transformedList = fromFiles;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return fileFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"files\"\n        ], transformedList);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Files extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists all current project files from the service.\n         *\n         * @param params - The parameters for the list request\n         * @return The paginated results of the list of files\n         *\n         * @example\n         * The following code prints the names of all files from the service, the\n         * size of each page is 10.\n         *\n         * ```ts\n         * const listResponse = await ai.files.list({config: {'pageSize': 10}});\n         * for await (const file of listResponse) {\n         *   console.log(file.name);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_FILES, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to the Gemini API.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     * Somex eamples for file extension to mimeType mapping:\n     * .txt -> text/plain\n     * .json -> application/json\n     * .jpg  -> image/jpeg\n     * .png -> image/png\n     * .mp3 -> audio/mpeg\n     * .mp4 -> video/mp4\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadFileParameters` interface.\n     *         @see {@link types.UploadFileParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a `types.File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to Gemini API.\n     *\n     * ```ts\n     * const file = await ai.files.upload({file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(file.name);\n     * ```\n     */ async upload(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Vertex AI does not support uploading files. You can share files through a GCS bucket.\");\n        }\n        return this.apiClient.uploadFile(params.file, params.config).then((response)=>{\n            const file = fileFromMldev(response);\n            return file;\n        });\n    }\n    /**\n     * Downloads a remotely stored file asynchronously to a location specified in\n     * the `params` object. This method only works on Node environment, to\n     * download files in the browser, use a browser compliant method like an <a>\n     * tag.\n     *\n     * @param params - The parameters for the download request.\n     *\n     * @example\n     * The following code downloads an example file named \"files/mehozpxf877d\" as\n     * \"file.txt\".\n     *\n     * ```ts\n     * await ai.files.download({file: file.name, downloadPath: 'file.txt'});\n     * ```\n     */ async download(params) {\n        await this.apiClient.downloadFile(params);\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = listFilesParametersToMldev(params);\n            path = formatMap(\"files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listFilesResponseFromMldev(apiResponse);\n                const typedResp = new ListFilesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async createInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createFileParametersToMldev(params);\n            path = formatMap(\"upload/v1beta/files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = createFileResponseFromMldev(apiResponse);\n                const typedResp = new CreateFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Retrieves the file information from the service.\n     *\n     * @param params - The parameters for the get request\n     * @return The Promise that resolves to the types.File object requested.\n     *\n     * @example\n     * ```ts\n     * const config: GetFileParameters = {\n     *   name: fileName,\n     * };\n     * file = await ai.files.get(config);\n     * console.log(file.name);\n     * ```\n     */ async get(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = getFileParametersToMldev(params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = fileFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a remotely stored file.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The DeleteFileResponse, the response for the delete method.\n     *\n     * @example\n     * The following code deletes an example file named \"files/mehozpxf877d\".\n     *\n     * ```ts\n     * await ai.files.delete({name: file.name});\n     * ```\n     */ async delete(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = deleteFileParametersToMldev(params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteFileResponseFromMldev(apiResponse);\n                const typedResp = new DeleteFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function activityEndToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityEndToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityStartToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityStartToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction apiKeyConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromApiKeyString = getValueByPath(fromObject, [\n        \"apiKeyString\"\n    ]);\n    if (fromApiKeyString != null) {\n        setValueByPath(toObject, [\n            \"apiKeyString\"\n        ], fromApiKeyString);\n    }\n    return toObject;\n}\nfunction audioChunkFromMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromSourceMetadata = getValueByPath(fromObject, [\n        \"sourceMetadata\"\n    ]);\n    if (fromSourceMetadata != null) {\n        setValueByPath(toObject, [\n            \"sourceMetadata\"\n        ], liveMusicSourceMetadataFromMldev(fromSourceMetadata));\n    }\n    return toObject;\n}\nfunction audioTranscriptionConfigToMldev$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction audioTranscriptionConfigToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction authConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromApiKeyConfig = getValueByPath(fromObject, [\n        \"apiKeyConfig\"\n    ]);\n    if (fromApiKeyConfig != null) {\n        setValueByPath(toObject, [\n            \"apiKeyConfig\"\n        ], apiKeyConfigToVertex$1(fromApiKeyConfig));\n    }\n    const fromAuthType = getValueByPath(fromObject, [\n        \"authType\"\n    ]);\n    if (fromAuthType != null) {\n        setValueByPath(toObject, [\n            \"authType\"\n        ], fromAuthType);\n    }\n    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [\n        \"googleServiceAccountConfig\"\n    ]);\n    if (fromGoogleServiceAccountConfig != null) {\n        setValueByPath(toObject, [\n            \"googleServiceAccountConfig\"\n        ], fromGoogleServiceAccountConfig);\n    }\n    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [\n        \"httpBasicAuthConfig\"\n    ]);\n    if (fromHttpBasicAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"httpBasicAuthConfig\"\n        ], fromHttpBasicAuthConfig);\n    }\n    const fromOauthConfig = getValueByPath(fromObject, [\n        \"oauthConfig\"\n    ]);\n    if (fromOauthConfig != null) {\n        setValueByPath(toObject, [\n            \"oauthConfig\"\n        ], fromOauthConfig);\n    }\n    const fromOidcConfig = getValueByPath(fromObject, [\n        \"oidcConfig\"\n    ]);\n    if (fromOidcConfig != null) {\n        setValueByPath(toObject, [\n            \"oidcConfig\"\n        ], fromOidcConfig);\n    }\n    return toObject;\n}\nfunction automaticActivityDetectionToMldev$1(fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, [\n        \"disabled\"\n    ]);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, [\n            \"disabled\"\n        ], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"startOfSpeechSensitivity\"\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"startOfSpeechSensitivity\"\n        ], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"endOfSpeechSensitivity\"\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"endOfSpeechSensitivity\"\n        ], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        \"prefixPaddingMs\"\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, [\n            \"prefixPaddingMs\"\n        ], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        \"silenceDurationMs\"\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, [\n            \"silenceDurationMs\"\n        ], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction automaticActivityDetectionToVertex(fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, [\n        \"disabled\"\n    ]);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, [\n            \"disabled\"\n        ], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"startOfSpeechSensitivity\"\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"startOfSpeechSensitivity\"\n        ], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"endOfSpeechSensitivity\"\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"endOfSpeechSensitivity\"\n        ], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        \"prefixPaddingMs\"\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, [\n            \"prefixPaddingMs\"\n        ], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        \"silenceDurationMs\"\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, [\n            \"silenceDurationMs\"\n        ], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction blobFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction computerUseToMldev$2(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        \"excludedPredefinedFunctions\"\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, [\n            \"excludedPredefinedFunctions\"\n        ], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction computerUseToVertex$1(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        \"excludedPredefinedFunctions\"\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, [\n            \"excludedPredefinedFunctions\"\n        ], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction contentFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contentFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contentToMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contentToVertex$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        \"triggerTokens\"\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, [\n            \"triggerTokens\"\n        ], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        \"slidingWindow\"\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, [\n            \"slidingWindow\"\n        ], slidingWindowToMldev$1(fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        \"triggerTokens\"\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, [\n            \"triggerTokens\"\n        ], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        \"slidingWindow\"\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, [\n            \"slidingWindow\"\n        ], slidingWindowToVertex(fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction enterpriseWebSearchToVertex$1(fromObject) {\n    const toObject = {};\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, [\n            \"excludeDomains\"\n        ], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction fileDataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionCallFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$2(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionCallToVertex$1(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$2(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction googleMapsToVertex$1(fromObject) {\n    const toObject = {};\n    const fromAuthConfig = getValueByPath(fromObject, [\n        \"authConfig\"\n    ]);\n    if (fromAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"authConfig\"\n        ], authConfigToVertex$1(fromAuthConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$2(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$2(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToVertex$1(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$2(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev$2(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction googleSearchToVertex$1(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToVertex$1(fromTimeRangeFilter));\n    }\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, [\n            \"excludeDomains\"\n        ], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction intervalToMldev$2(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction intervalToVertex$1(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], speechConfigToMldev$2(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"thinkingConfig\"\n        ], thinkingConfigToMldev$2(fromThinkingConfig));\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToMldev$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$2(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToMldev$1(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], audioTranscriptionConfigToMldev$1());\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], audioTranscriptionConfigToMldev$1());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], realtimeInputConfigToMldev$1(fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], contextWindowCompressionConfigToMldev$1(fromContextWindowCompression));\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], proactivityConfigToMldev$1(fromProactivity));\n    }\n    return toObject;\n}\nfunction liveConnectConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"thinkingConfig\"\n        ], thinkingConfigToVertex$1(fromThinkingConfig));\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToVertex$1(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToVertex(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], audioTranscriptionConfigToVertex());\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], audioTranscriptionConfigToVertex());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], realtimeInputConfigToVertex(fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], contextWindowCompressionConfigToVertex(fromContextWindowCompression));\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], proactivityConfigToVertex(fromProactivity));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToMldev$1(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveMusicClientContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        \"weightedPrompts\"\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return weightedPromptFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"weightedPrompts\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicClientContentToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        \"weightedPrompts\"\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return weightedPromptToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"weightedPrompts\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicClientMessageToMldev(fromObject) {\n    const toObject = {};\n    const fromSetup = getValueByPath(fromObject, [\n        \"setup\"\n    ]);\n    if (fromSetup != null) {\n        setValueByPath(toObject, [\n            \"setup\"\n        ], liveMusicClientSetupToMldev(fromSetup));\n    }\n    const fromClientContent = getValueByPath(fromObject, [\n        \"clientContent\"\n    ]);\n    if (fromClientContent != null) {\n        setValueByPath(toObject, [\n            \"clientContent\"\n        ], liveMusicClientContentToMldev(fromClientContent));\n    }\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        \"musicGenerationConfig\"\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationConfig\"\n        ], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));\n    }\n    const fromPlaybackControl = getValueByPath(fromObject, [\n        \"playbackControl\"\n    ]);\n    if (fromPlaybackControl != null) {\n        setValueByPath(toObject, [\n            \"playbackControl\"\n        ], fromPlaybackControl);\n    }\n    return toObject;\n}\nfunction liveMusicClientSetupToMldev(fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    return toObject;\n}\nfunction liveMusicFilteredPromptFromMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromFilteredReason = getValueByPath(fromObject, [\n        \"filteredReason\"\n    ]);\n    if (fromFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"filteredReason\"\n        ], fromFilteredReason);\n    }\n    return toObject;\n}\nfunction liveMusicGenerationConfigFromMldev(fromObject) {\n    const toObject = {};\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromGuidance = getValueByPath(fromObject, [\n        \"guidance\"\n    ]);\n    if (fromGuidance != null) {\n        setValueByPath(toObject, [\n            \"guidance\"\n        ], fromGuidance);\n    }\n    const fromBpm = getValueByPath(fromObject, [\n        \"bpm\"\n    ]);\n    if (fromBpm != null) {\n        setValueByPath(toObject, [\n            \"bpm\"\n        ], fromBpm);\n    }\n    const fromDensity = getValueByPath(fromObject, [\n        \"density\"\n    ]);\n    if (fromDensity != null) {\n        setValueByPath(toObject, [\n            \"density\"\n        ], fromDensity);\n    }\n    const fromBrightness = getValueByPath(fromObject, [\n        \"brightness\"\n    ]);\n    if (fromBrightness != null) {\n        setValueByPath(toObject, [\n            \"brightness\"\n        ], fromBrightness);\n    }\n    const fromScale = getValueByPath(fromObject, [\n        \"scale\"\n    ]);\n    if (fromScale != null) {\n        setValueByPath(toObject, [\n            \"scale\"\n        ], fromScale);\n    }\n    const fromMuteBass = getValueByPath(fromObject, [\n        \"muteBass\"\n    ]);\n    if (fromMuteBass != null) {\n        setValueByPath(toObject, [\n            \"muteBass\"\n        ], fromMuteBass);\n    }\n    const fromMuteDrums = getValueByPath(fromObject, [\n        \"muteDrums\"\n    ]);\n    if (fromMuteDrums != null) {\n        setValueByPath(toObject, [\n            \"muteDrums\"\n        ], fromMuteDrums);\n    }\n    const fromOnlyBassAndDrums = getValueByPath(fromObject, [\n        \"onlyBassAndDrums\"\n    ]);\n    if (fromOnlyBassAndDrums != null) {\n        setValueByPath(toObject, [\n            \"onlyBassAndDrums\"\n        ], fromOnlyBassAndDrums);\n    }\n    const fromMusicGenerationMode = getValueByPath(fromObject, [\n        \"musicGenerationMode\"\n    ]);\n    if (fromMusicGenerationMode != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationMode\"\n        ], fromMusicGenerationMode);\n    }\n    return toObject;\n}\nfunction liveMusicGenerationConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromGuidance = getValueByPath(fromObject, [\n        \"guidance\"\n    ]);\n    if (fromGuidance != null) {\n        setValueByPath(toObject, [\n            \"guidance\"\n        ], fromGuidance);\n    }\n    const fromBpm = getValueByPath(fromObject, [\n        \"bpm\"\n    ]);\n    if (fromBpm != null) {\n        setValueByPath(toObject, [\n            \"bpm\"\n        ], fromBpm);\n    }\n    const fromDensity = getValueByPath(fromObject, [\n        \"density\"\n    ]);\n    if (fromDensity != null) {\n        setValueByPath(toObject, [\n            \"density\"\n        ], fromDensity);\n    }\n    const fromBrightness = getValueByPath(fromObject, [\n        \"brightness\"\n    ]);\n    if (fromBrightness != null) {\n        setValueByPath(toObject, [\n            \"brightness\"\n        ], fromBrightness);\n    }\n    const fromScale = getValueByPath(fromObject, [\n        \"scale\"\n    ]);\n    if (fromScale != null) {\n        setValueByPath(toObject, [\n            \"scale\"\n        ], fromScale);\n    }\n    const fromMuteBass = getValueByPath(fromObject, [\n        \"muteBass\"\n    ]);\n    if (fromMuteBass != null) {\n        setValueByPath(toObject, [\n            \"muteBass\"\n        ], fromMuteBass);\n    }\n    const fromMuteDrums = getValueByPath(fromObject, [\n        \"muteDrums\"\n    ]);\n    if (fromMuteDrums != null) {\n        setValueByPath(toObject, [\n            \"muteDrums\"\n        ], fromMuteDrums);\n    }\n    const fromOnlyBassAndDrums = getValueByPath(fromObject, [\n        \"onlyBassAndDrums\"\n    ]);\n    if (fromOnlyBassAndDrums != null) {\n        setValueByPath(toObject, [\n            \"onlyBassAndDrums\"\n        ], fromOnlyBassAndDrums);\n    }\n    const fromMusicGenerationMode = getValueByPath(fromObject, [\n        \"musicGenerationMode\"\n    ]);\n    if (fromMusicGenerationMode != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationMode\"\n        ], fromMusicGenerationMode);\n    }\n    return toObject;\n}\nfunction liveMusicServerContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromAudioChunks = getValueByPath(fromObject, [\n        \"audioChunks\"\n    ]);\n    if (fromAudioChunks != null) {\n        let transformedList = fromAudioChunks;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return audioChunkFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"audioChunks\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicServerMessageFromMldev(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], liveMusicServerSetupCompleteFromMldev());\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], liveMusicServerContentFromMldev(fromServerContent));\n    }\n    const fromFilteredPrompt = getValueByPath(fromObject, [\n        \"filteredPrompt\"\n    ]);\n    if (fromFilteredPrompt != null) {\n        setValueByPath(toObject, [\n            \"filteredPrompt\"\n        ], liveMusicFilteredPromptFromMldev(fromFilteredPrompt));\n    }\n    return toObject;\n}\nfunction liveMusicServerSetupCompleteFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction liveMusicSetConfigParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        \"musicGenerationConfig\"\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationConfig\"\n        ], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));\n    }\n    return toObject;\n}\nfunction liveMusicSetWeightedPromptsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        \"weightedPrompts\"\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return weightedPromptToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"weightedPrompts\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicSourceMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromClientContent = getValueByPath(fromObject, [\n        \"clientContent\"\n    ]);\n    if (fromClientContent != null) {\n        setValueByPath(toObject, [\n            \"clientContent\"\n        ], liveMusicClientContentFromMldev(fromClientContent));\n    }\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        \"musicGenerationConfig\"\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationConfig\"\n        ], liveMusicGenerationConfigFromMldev(fromMusicGenerationConfig));\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, [\n        \"audio\"\n    ]);\n    if (fromAudio != null) {\n        setValueByPath(toObject, [\n            \"audio\"\n        ], tAudioBlob(fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], tImageBlob(fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], activityStartToMldev());\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], activityEndToMldev());\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, [\n        \"audio\"\n    ]);\n    if (fromAudio != null) {\n        setValueByPath(toObject, [\n            \"audio\"\n        ], tAudioBlob(fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], tImageBlob(fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], activityStartToVertex());\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], activityEndToVertex());\n    }\n    return toObject;\n}\nfunction liveServerContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromModelTurn = getValueByPath(fromObject, [\n        \"modelTurn\"\n    ]);\n    if (fromModelTurn != null) {\n        setValueByPath(toObject, [\n            \"modelTurn\"\n        ], contentFromMldev$1(fromModelTurn));\n    }\n    const fromTurnComplete = getValueByPath(fromObject, [\n        \"turnComplete\"\n    ]);\n    if (fromTurnComplete != null) {\n        setValueByPath(toObject, [\n            \"turnComplete\"\n        ], fromTurnComplete);\n    }\n    const fromInterrupted = getValueByPath(fromObject, [\n        \"interrupted\"\n    ]);\n    if (fromInterrupted != null) {\n        setValueByPath(toObject, [\n            \"interrupted\"\n        ], fromInterrupted);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromGenerationComplete = getValueByPath(fromObject, [\n        \"generationComplete\"\n    ]);\n    if (fromGenerationComplete != null) {\n        setValueByPath(toObject, [\n            \"generationComplete\"\n        ], fromGenerationComplete);\n    }\n    const fromInputTranscription = getValueByPath(fromObject, [\n        \"inputTranscription\"\n    ]);\n    if (fromInputTranscription != null) {\n        setValueByPath(toObject, [\n            \"inputTranscription\"\n        ], transcriptionFromMldev(fromInputTranscription));\n    }\n    const fromOutputTranscription = getValueByPath(fromObject, [\n        \"outputTranscription\"\n    ]);\n    if (fromOutputTranscription != null) {\n        setValueByPath(toObject, [\n            \"outputTranscription\"\n        ], transcriptionFromMldev(fromOutputTranscription));\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], urlContextMetadataFromMldev$1(fromUrlContextMetadata));\n    }\n    const fromTurnCompleteReason = getValueByPath(fromObject, [\n        \"turnCompleteReason\"\n    ]);\n    if (fromTurnCompleteReason != null) {\n        setValueByPath(toObject, [\n            \"turnCompleteReason\"\n        ], fromTurnCompleteReason);\n    }\n    const fromWaitingForInput = getValueByPath(fromObject, [\n        \"waitingForInput\"\n    ]);\n    if (fromWaitingForInput != null) {\n        setValueByPath(toObject, [\n            \"waitingForInput\"\n        ], fromWaitingForInput);\n    }\n    return toObject;\n}\nfunction liveServerContentFromVertex(fromObject) {\n    const toObject = {};\n    const fromModelTurn = getValueByPath(fromObject, [\n        \"modelTurn\"\n    ]);\n    if (fromModelTurn != null) {\n        setValueByPath(toObject, [\n            \"modelTurn\"\n        ], contentFromVertex$1(fromModelTurn));\n    }\n    const fromTurnComplete = getValueByPath(fromObject, [\n        \"turnComplete\"\n    ]);\n    if (fromTurnComplete != null) {\n        setValueByPath(toObject, [\n            \"turnComplete\"\n        ], fromTurnComplete);\n    }\n    const fromInterrupted = getValueByPath(fromObject, [\n        \"interrupted\"\n    ]);\n    if (fromInterrupted != null) {\n        setValueByPath(toObject, [\n            \"interrupted\"\n        ], fromInterrupted);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromGenerationComplete = getValueByPath(fromObject, [\n        \"generationComplete\"\n    ]);\n    if (fromGenerationComplete != null) {\n        setValueByPath(toObject, [\n            \"generationComplete\"\n        ], fromGenerationComplete);\n    }\n    const fromInputTranscription = getValueByPath(fromObject, [\n        \"inputTranscription\"\n    ]);\n    if (fromInputTranscription != null) {\n        setValueByPath(toObject, [\n            \"inputTranscription\"\n        ], transcriptionFromVertex(fromInputTranscription));\n    }\n    const fromOutputTranscription = getValueByPath(fromObject, [\n        \"outputTranscription\"\n    ]);\n    if (fromOutputTranscription != null) {\n        setValueByPath(toObject, [\n            \"outputTranscription\"\n        ], transcriptionFromVertex(fromOutputTranscription));\n    }\n    const fromTurnCompleteReason = getValueByPath(fromObject, [\n        \"turnCompleteReason\"\n    ]);\n    if (fromTurnCompleteReason != null) {\n        setValueByPath(toObject, [\n            \"turnCompleteReason\"\n        ], fromTurnCompleteReason);\n    }\n    const fromWaitingForInput = getValueByPath(fromObject, [\n        \"waitingForInput\"\n    ]);\n    if (fromWaitingForInput != null) {\n        setValueByPath(toObject, [\n            \"waitingForInput\"\n        ], fromWaitingForInput);\n    }\n    return toObject;\n}\nfunction liveServerGoAwayFromMldev(fromObject) {\n    const toObject = {};\n    const fromTimeLeft = getValueByPath(fromObject, [\n        \"timeLeft\"\n    ]);\n    if (fromTimeLeft != null) {\n        setValueByPath(toObject, [\n            \"timeLeft\"\n        ], fromTimeLeft);\n    }\n    return toObject;\n}\nfunction liveServerGoAwayFromVertex(fromObject) {\n    const toObject = {};\n    const fromTimeLeft = getValueByPath(fromObject, [\n        \"timeLeft\"\n    ]);\n    if (fromTimeLeft != null) {\n        setValueByPath(toObject, [\n            \"timeLeft\"\n        ], fromTimeLeft);\n    }\n    return toObject;\n}\nfunction liveServerMessageFromMldev(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], liveServerSetupCompleteFromMldev());\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], liveServerContentFromMldev(fromServerContent));\n    }\n    const fromToolCall = getValueByPath(fromObject, [\n        \"toolCall\"\n    ]);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, [\n            \"toolCall\"\n        ], liveServerToolCallFromMldev(fromToolCall));\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        \"toolCallCancellation\"\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, [\n            \"toolCallCancellation\"\n        ], liveServerToolCallCancellationFromMldev(fromToolCallCancellation));\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], usageMetadataFromMldev(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, [\n        \"goAway\"\n    ]);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, [\n            \"goAway\"\n        ], liveServerGoAwayFromMldev(fromGoAway));\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        \"sessionResumptionUpdate\"\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, [\n            \"sessionResumptionUpdate\"\n        ], liveServerSessionResumptionUpdateFromMldev(fromSessionResumptionUpdate));\n    }\n    return toObject;\n}\nfunction liveServerMessageFromVertex(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], liveServerSetupCompleteFromVertex(fromSetupComplete));\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], liveServerContentFromVertex(fromServerContent));\n    }\n    const fromToolCall = getValueByPath(fromObject, [\n        \"toolCall\"\n    ]);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, [\n            \"toolCall\"\n        ], liveServerToolCallFromVertex(fromToolCall));\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        \"toolCallCancellation\"\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, [\n            \"toolCallCancellation\"\n        ], liveServerToolCallCancellationFromVertex(fromToolCallCancellation));\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], usageMetadataFromVertex(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, [\n        \"goAway\"\n    ]);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, [\n            \"goAway\"\n        ], liveServerGoAwayFromVertex(fromGoAway));\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        \"sessionResumptionUpdate\"\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, [\n            \"sessionResumptionUpdate\"\n        ], liveServerSessionResumptionUpdateFromVertex(fromSessionResumptionUpdate));\n    }\n    return toObject;\n}\nfunction liveServerSessionResumptionUpdateFromMldev(fromObject) {\n    const toObject = {};\n    const fromNewHandle = getValueByPath(fromObject, [\n        \"newHandle\"\n    ]);\n    if (fromNewHandle != null) {\n        setValueByPath(toObject, [\n            \"newHandle\"\n        ], fromNewHandle);\n    }\n    const fromResumable = getValueByPath(fromObject, [\n        \"resumable\"\n    ]);\n    if (fromResumable != null) {\n        setValueByPath(toObject, [\n            \"resumable\"\n        ], fromResumable);\n    }\n    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [\n        \"lastConsumedClientMessageIndex\"\n    ]);\n    if (fromLastConsumedClientMessageIndex != null) {\n        setValueByPath(toObject, [\n            \"lastConsumedClientMessageIndex\"\n        ], fromLastConsumedClientMessageIndex);\n    }\n    return toObject;\n}\nfunction liveServerSessionResumptionUpdateFromVertex(fromObject) {\n    const toObject = {};\n    const fromNewHandle = getValueByPath(fromObject, [\n        \"newHandle\"\n    ]);\n    if (fromNewHandle != null) {\n        setValueByPath(toObject, [\n            \"newHandle\"\n        ], fromNewHandle);\n    }\n    const fromResumable = getValueByPath(fromObject, [\n        \"resumable\"\n    ]);\n    if (fromResumable != null) {\n        setValueByPath(toObject, [\n            \"resumable\"\n        ], fromResumable);\n    }\n    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [\n        \"lastConsumedClientMessageIndex\"\n    ]);\n    if (fromLastConsumedClientMessageIndex != null) {\n        setValueByPath(toObject, [\n            \"lastConsumedClientMessageIndex\"\n        ], fromLastConsumedClientMessageIndex);\n    }\n    return toObject;\n}\nfunction liveServerSetupCompleteFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction liveServerSetupCompleteFromVertex(fromObject) {\n    const toObject = {};\n    const fromSessionId = getValueByPath(fromObject, [\n        \"sessionId\"\n    ]);\n    if (fromSessionId != null) {\n        setValueByPath(toObject, [\n            \"sessionId\"\n        ], fromSessionId);\n    }\n    return toObject;\n}\nfunction liveServerToolCallCancellationFromMldev(fromObject) {\n    const toObject = {};\n    const fromIds = getValueByPath(fromObject, [\n        \"ids\"\n    ]);\n    if (fromIds != null) {\n        setValueByPath(toObject, [\n            \"ids\"\n        ], fromIds);\n    }\n    return toObject;\n}\nfunction liveServerToolCallCancellationFromVertex(fromObject) {\n    const toObject = {};\n    const fromIds = getValueByPath(fromObject, [\n        \"ids\"\n    ]);\n    if (fromIds != null) {\n        setValueByPath(toObject, [\n            \"ids\"\n        ], fromIds);\n    }\n    return toObject;\n}\nfunction liveServerToolCallFromMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionCalls = getValueByPath(fromObject, [\n        \"functionCalls\"\n    ]);\n    if (fromFunctionCalls != null) {\n        let transformedList = fromFunctionCalls;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionCallFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionCalls\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveServerToolCallFromVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionCalls = getValueByPath(fromObject, [\n        \"functionCalls\"\n    ]);\n    if (fromFunctionCalls != null) {\n        let transformedList = fromFunctionCalls;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionCallFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionCalls\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction modalityTokenCountFromMldev(fromObject) {\n    const toObject = {};\n    const fromModality = getValueByPath(fromObject, [\n        \"modality\"\n    ]);\n    if (fromModality != null) {\n        setValueByPath(toObject, [\n            \"modality\"\n        ], fromModality);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction modalityTokenCountFromVertex(fromObject) {\n    const toObject = {};\n    const fromModality = getValueByPath(fromObject, [\n        \"modality\"\n    ]);\n    if (fromModality != null) {\n        setValueByPath(toObject, [\n            \"modality\"\n        ], fromModality);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        \"speakerVoiceConfigs\"\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return speakerVoiceConfigToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"speakerVoiceConfigs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromMldev$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromMldev$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromMldev$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallFromMldev$1(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction partFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromVertex$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromVertex$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromVertex$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallFromVertex$1(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction partToMldev$2(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev$2(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$2(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$2(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$2(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction partToVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToVertex$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToVertex$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToVertex$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToVertex$1(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction proactivityConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromProactiveAudio = getValueByPath(fromObject, [\n        \"proactiveAudio\"\n    ]);\n    if (fromProactiveAudio != null) {\n        setValueByPath(toObject, [\n            \"proactiveAudio\"\n        ], fromProactiveAudio);\n    }\n    return toObject;\n}\nfunction proactivityConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromProactiveAudio = getValueByPath(fromObject, [\n        \"proactiveAudio\"\n    ]);\n    if (fromProactiveAudio != null) {\n        setValueByPath(toObject, [\n            \"proactiveAudio\"\n        ], fromProactiveAudio);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        \"automaticActivityDetection\"\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, [\n            \"automaticActivityDetection\"\n        ], automaticActivityDetectionToMldev$1(fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        \"activityHandling\"\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, [\n            \"activityHandling\"\n        ], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, [\n        \"turnCoverage\"\n    ]);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, [\n            \"turnCoverage\"\n        ], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        \"automaticActivityDetection\"\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, [\n            \"automaticActivityDetection\"\n        ], automaticActivityDetectionToVertex(fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        \"activityHandling\"\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, [\n            \"activityHandling\"\n        ], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, [\n        \"turnCoverage\"\n    ]);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, [\n            \"turnCoverage\"\n        ], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    if (getValueByPath(fromObject, [\n        \"transparent\"\n    ]) !== undefined) {\n        throw new Error(\"transparent parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    const fromTransparent = getValueByPath(fromObject, [\n        \"transparent\"\n    ]);\n    if (fromTransparent != null) {\n        setValueByPath(toObject, [\n            \"transparent\"\n        ], fromTransparent);\n    }\n    return toObject;\n}\nfunction slidingWindowToMldev$1(fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, [\n        \"targetTokens\"\n    ]);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, [\n            \"targetTokens\"\n        ], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction slidingWindowToVertex(fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, [\n        \"targetTokens\"\n    ]);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, [\n            \"targetTokens\"\n        ], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, [\n        \"speaker\"\n    ]);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, [\n            \"speaker\"\n        ], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$2(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction speechConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$2(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"multiSpeakerVoiceConfig\"\n        ], multiSpeakerVoiceConfigToMldev$2(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction speechConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToVertex$1(fromVoiceConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]) !== undefined) {\n        throw new Error(\"multiSpeakerVoiceConfig parameter is not supported in Vertex AI.\");\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction thinkingConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction toolToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$2(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$2(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev$2());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], computerUseToMldev$2(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction toolToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToVertex$1(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToVertex$1(fromGoogleSearchRetrieval));\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], enterpriseWebSearchToVertex$1(fromEnterpriseWebSearch));\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToVertex$1(fromGoogleMaps));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToVertex$1());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], computerUseToVertex$1(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction transcriptionFromMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromFinished = getValueByPath(fromObject, [\n        \"finished\"\n    ]);\n    if (fromFinished != null) {\n        setValueByPath(toObject, [\n            \"finished\"\n        ], fromFinished);\n    }\n    return toObject;\n}\nfunction transcriptionFromVertex(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromFinished = getValueByPath(fromObject, [\n        \"finished\"\n    ]);\n    if (fromFinished != null) {\n        setValueByPath(toObject, [\n            \"finished\"\n        ], fromFinished);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, [\n        \"urlMetadata\"\n    ]);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return urlMetadataFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"urlMetadata\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction urlContextToMldev$2() {\n    const toObject = {};\n    return toObject;\n}\nfunction urlContextToVertex$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction urlMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, [\n        \"retrievedUrl\"\n    ]);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, [\n            \"retrievedUrl\"\n        ], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        \"urlRetrievalStatus\"\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, [\n            \"urlRetrievalStatus\"\n        ], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction usageMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        \"promptTokenCount\"\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"promptTokenCount\"\n        ], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        \"responseTokenCount\"\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, [\n            \"responseTokenCount\"\n        ], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        \"toolUsePromptTokenCount\"\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"toolUsePromptTokenCount\"\n        ], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        \"thoughtsTokenCount\"\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, [\n            \"thoughtsTokenCount\"\n        ], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        \"totalTokenCount\"\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, [\n            \"totalTokenCount\"\n        ], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        \"promptTokensDetails\"\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"promptTokensDetails\"\n        ], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        \"cacheTokensDetails\"\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"cacheTokensDetails\"\n        ], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        \"responseTokensDetails\"\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"responseTokensDetails\"\n        ], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        \"toolUsePromptTokensDetails\"\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"toolUsePromptTokensDetails\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction usageMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        \"promptTokenCount\"\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"promptTokenCount\"\n        ], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        \"candidatesTokenCount\"\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, [\n            \"responseTokenCount\"\n        ], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        \"toolUsePromptTokenCount\"\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"toolUsePromptTokenCount\"\n        ], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        \"thoughtsTokenCount\"\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, [\n            \"thoughtsTokenCount\"\n        ], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        \"totalTokenCount\"\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, [\n            \"totalTokenCount\"\n        ], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        \"promptTokensDetails\"\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"promptTokensDetails\"\n        ], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        \"cacheTokensDetails\"\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"cacheTokensDetails\"\n        ], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        \"candidatesTokensDetails\"\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"responseTokensDetails\"\n        ], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        \"toolUsePromptTokensDetails\"\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"toolUsePromptTokensDetails\"\n        ], transformedList);\n    }\n    const fromTrafficType = getValueByPath(fromObject, [\n        \"trafficType\"\n    ]);\n    if (fromTrafficType != null) {\n        setValueByPath(toObject, [\n            \"trafficType\"\n        ], fromTrafficType);\n    }\n    return toObject;\n}\nfunction videoMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToMldev$2(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction voiceConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToVertex$1(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction weightedPromptFromMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromWeight = getValueByPath(fromObject, [\n        \"weight\"\n    ]);\n    if (fromWeight != null) {\n        setValueByPath(toObject, [\n            \"weight\"\n        ], fromWeight);\n    }\n    return toObject;\n}\nfunction weightedPromptToMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromWeight = getValueByPath(fromObject, [\n        \"weight\"\n    ]);\n    if (fromWeight != null) {\n        setValueByPath(toObject, [\n            \"weight\"\n        ], fromWeight);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function apiKeyConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromApiKeyString = getValueByPath(fromObject, [\n        \"apiKeyString\"\n    ]);\n    if (fromApiKeyString != null) {\n        setValueByPath(toObject, [\n            \"apiKeyString\"\n        ], fromApiKeyString);\n    }\n    return toObject;\n}\nfunction authConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromApiKeyConfig = getValueByPath(fromObject, [\n        \"apiKeyConfig\"\n    ]);\n    if (fromApiKeyConfig != null) {\n        setValueByPath(toObject, [\n            \"apiKeyConfig\"\n        ], apiKeyConfigToVertex(fromApiKeyConfig));\n    }\n    const fromAuthType = getValueByPath(fromObject, [\n        \"authType\"\n    ]);\n    if (fromAuthType != null) {\n        setValueByPath(toObject, [\n            \"authType\"\n        ], fromAuthType);\n    }\n    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [\n        \"googleServiceAccountConfig\"\n    ]);\n    if (fromGoogleServiceAccountConfig != null) {\n        setValueByPath(toObject, [\n            \"googleServiceAccountConfig\"\n        ], fromGoogleServiceAccountConfig);\n    }\n    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [\n        \"httpBasicAuthConfig\"\n    ]);\n    if (fromHttpBasicAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"httpBasicAuthConfig\"\n        ], fromHttpBasicAuthConfig);\n    }\n    const fromOauthConfig = getValueByPath(fromObject, [\n        \"oauthConfig\"\n    ]);\n    if (fromOauthConfig != null) {\n        setValueByPath(toObject, [\n            \"oauthConfig\"\n        ], fromOauthConfig);\n    }\n    const fromOidcConfig = getValueByPath(fromObject, [\n        \"oidcConfig\"\n    ]);\n    if (fromOidcConfig != null) {\n        setValueByPath(toObject, [\n            \"oidcConfig\"\n        ], fromOidcConfig);\n    }\n    return toObject;\n}\nfunction blobFromMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobFromVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobToVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction candidateFromMldev(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], contentFromMldev(fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromMldev(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], urlContextMetadataFromMldev(fromUrlContextMetadata));\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction candidateFromVertex(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], contentFromVertex(fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromVertex(fromCitationMetadata));\n    }\n    const fromFinishMessage = getValueByPath(fromObject, [\n        \"finishMessage\"\n    ]);\n    if (fromFinishMessage != null) {\n        setValueByPath(toObject, [\n            \"finishMessage\"\n        ], fromFinishMessage);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], urlContextMetadataFromVertex(fromUrlContextMetadata));\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction checkpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromCheckpointId = getValueByPath(fromObject, [\n        \"checkpointId\"\n    ]);\n    if (fromCheckpointId != null) {\n        setValueByPath(toObject, [\n            \"checkpointId\"\n        ], fromCheckpointId);\n    }\n    const fromEpoch = getValueByPath(fromObject, [\n        \"epoch\"\n    ]);\n    if (fromEpoch != null) {\n        setValueByPath(toObject, [\n            \"epoch\"\n        ], fromEpoch);\n    }\n    const fromStep = getValueByPath(fromObject, [\n        \"step\"\n    ]);\n    if (fromStep != null) {\n        setValueByPath(toObject, [\n            \"step\"\n        ], fromStep);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citationSources\"\n    ]);\n    if (fromCitations != null) {\n        setValueByPath(toObject, [\n            \"citations\"\n        ], fromCitations);\n    }\n    return toObject;\n}\nfunction citationMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citations\"\n    ]);\n    if (fromCitations != null) {\n        setValueByPath(toObject, [\n            \"citations\"\n        ], fromCitations);\n    }\n    return toObject;\n}\nfunction computeTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTokensInfo = getValueByPath(fromObject, [\n        \"tokensInfo\"\n    ]);\n    if (fromTokensInfo != null) {\n        setValueByPath(toObject, [\n            \"tokensInfo\"\n        ], fromTokensInfo);\n    }\n    return toObject;\n}\nfunction computerUseToMldev$1(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        \"excludedPredefinedFunctions\"\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, [\n            \"excludedPredefinedFunctions\"\n        ], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction computerUseToVertex(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        \"excludedPredefinedFunctions\"\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, [\n            \"excludedPredefinedFunctions\"\n        ], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromMldev(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, [\n        \"values\"\n    ]);\n    if (fromValues != null) {\n        setValueByPath(toObject, [\n            \"values\"\n        ], fromValues);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromVertex(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, [\n        \"values\"\n    ]);\n    if (fromValues != null) {\n        setValueByPath(toObject, [\n            \"values\"\n        ], fromValues);\n    }\n    const fromStatistics = getValueByPath(fromObject, [\n        \"statistics\"\n    ]);\n    if (fromStatistics != null) {\n        setValueByPath(toObject, [\n            \"statistics\"\n        ], contentEmbeddingStatisticsFromVertex(fromStatistics));\n    }\n    return toObject;\n}\nfunction contentEmbeddingStatisticsFromVertex(fromObject) {\n    const toObject = {};\n    const fromTruncated = getValueByPath(fromObject, [\n        \"truncated\"\n    ]);\n    if (fromTruncated != null) {\n        setValueByPath(toObject, [\n            \"truncated\"\n        ], fromTruncated);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"token_count\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction contentFromMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contentFromVertex(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contentToMldev$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contentToVertex(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction controlReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromControlType = getValueByPath(fromObject, [\n        \"controlType\"\n    ]);\n    if (fromControlType != null) {\n        setValueByPath(toObject, [\n            \"controlType\"\n        ], fromControlType);\n    }\n    const fromEnableControlImageComputation = getValueByPath(fromObject, [\n        \"enableControlImageComputation\"\n    ]);\n    if (fromEnableControlImageComputation != null) {\n        setValueByPath(toObject, [\n            \"computeControl\"\n        ], fromEnableControlImageComputation);\n    }\n    return toObject;\n}\nfunction countTokensConfigToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]) !== undefined) {\n        throw new Error(\"systemInstruction parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"tools\"\n    ]) !== undefined) {\n        throw new Error(\"tools parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]) !== undefined) {\n        throw new Error(\"generationConfig parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction countTokensConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToVertex(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    return toObject;\n}\nfunction countTokensParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        countTokensConfigToMldev(fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        countTokensConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    return toObject;\n}\nfunction deleteModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction editImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromEditMode = getValueByPath(fromObject, [\n        \"editMode\"\n    ]);\n    if (parentObject !== undefined && fromEditMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editMode\"\n        ], fromEditMode);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, [\n        \"baseSteps\"\n    ]);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editConfig\",\n            \"baseSteps\"\n        ], fromBaseSteps);\n    }\n    return toObject;\n}\nfunction editImageParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return referenceImageAPIInternalToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        editImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction editImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"taskType\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, [\n        \"mimeType\"\n    ]) !== undefined) {\n        throw new Error(\"mimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]) !== undefined) {\n        throw new Error(\"autoTruncate parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction embedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"task_type\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromAutoTruncate = getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]);\n    if (parentObject !== undefined && fromAutoTruncate != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"autoTruncate\"\n        ], fromAutoTruncate);\n    }\n    return toObject;\n}\nfunction embedContentMetadataFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction embedContentMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromBillableCharacterCount = getValueByPath(fromObject, [\n        \"billableCharacterCount\"\n    ]);\n    if (fromBillableCharacterCount != null) {\n        setValueByPath(toObject, [\n            \"billableCharacterCount\"\n        ], fromBillableCharacterCount);\n    }\n    return toObject;\n}\nfunction embedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"content\"\n        ], tContentsForEmbed(apiClient, fromContents));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        embedContentConfigToMldev(fromConfig, toObject);\n    }\n    const fromModelForEmbedContent = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModelForEmbedContent !== undefined) {\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"model\"\n        ], tModel(apiClient, fromModelForEmbedContent));\n    }\n    return toObject;\n}\nfunction embedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        setValueByPath(toObject, [\n            \"instances[]\",\n            \"content\"\n        ], tContentsForEmbed(apiClient, fromContents));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        embedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentEmbeddingFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"embeddings\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], embedContentMetadataFromMldev());\n    }\n    return toObject;\n}\nfunction embedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"predictions[]\",\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentEmbeddingFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"embeddings\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], embedContentMetadataFromVertex(fromMetadata));\n    }\n    return toObject;\n}\nfunction endpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"endpoint\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDeployedModelId = getValueByPath(fromObject, [\n        \"deployedModelId\"\n    ]);\n    if (fromDeployedModelId != null) {\n        setValueByPath(toObject, [\n            \"deployedModelId\"\n        ], fromDeployedModelId);\n    }\n    return toObject;\n}\nfunction enterpriseWebSearchToVertex(fromObject) {\n    const toObject = {};\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, [\n            \"excludeDomains\"\n        ], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction entityLabelFromVertex(fromObject) {\n    const toObject = {};\n    const fromLabel = getValueByPath(fromObject, [\n        \"label\"\n    ]);\n    if (fromLabel != null) {\n        setValueByPath(toObject, [\n            \"label\"\n        ], fromLabel);\n    }\n    const fromScore = getValueByPath(fromObject, [\n        \"score\"\n    ]);\n    if (fromScore != null) {\n        setValueByPath(toObject, [\n            \"score\"\n        ], fromScore);\n    }\n    return toObject;\n}\nfunction fileDataFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallFromMldev(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionCallFromVertex(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$1(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionCallToVertex(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$1(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$1(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], schemaToMldev(tSchema(fromResponseSchema)));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]) !== undefined) {\n        throw new Error(\"routingConfig parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]) !== undefined) {\n        throw new Error(\"modelSelectionConfig parameter is not supported in Gemini API.\");\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToMldev$1(tSpeechConfig(fromSpeechConfig)));\n    }\n    if (getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]) !== undefined) {\n        throw new Error(\"audioTimestamp parameter is not supported in Gemini API.\");\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], thinkingConfigToMldev$1(fromThinkingConfig));\n    }\n    const fromImageConfig = getValueByPath(fromObject, [\n        \"imageConfig\"\n    ]);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, [\n            \"imageConfig\"\n        ], imageConfigToMldev(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToVertex(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], schemaToVertex(tSchema(fromResponseSchema)));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, [\n            \"routingConfig\"\n        ], fromRoutingConfig);\n    }\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, [\n            \"modelConfig\"\n        ], modelSelectionConfigToVertex(fromModelSelectionConfig));\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToVertex(fromToolConfig));\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, [\n            \"audioTimestamp\"\n        ], fromAudioTimestamp);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], thinkingConfigToVertex(fromThinkingConfig));\n    }\n    const fromImageConfig = getValueByPath(fromObject, [\n        \"imageConfig\"\n    ]);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, [\n            \"imageConfig\"\n        ], imageConfigToVertex(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateImagesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"negativePrompt parameter is not supported in Gemini API.\");\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    if (getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]) !== undefined) {\n        throw new Error(\"addWatermark parameter is not supported in Gemini API.\");\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleImageSize\"\n        ], fromImageSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"enhancePrompt parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateImagesConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleImageSize\"\n        ], fromImageSize);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateImagesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateImagesConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateVideosConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"fps\"\n    ]) !== undefined) {\n        throw new Error(\"fps parameter is not supported in Gemini API.\");\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, [\n        \"resolution\"\n    ]);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"resolution\"\n        ], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    if (getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]) !== undefined) {\n        throw new Error(\"pubsubTopic parameter is not supported in Gemini API.\");\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    if (getValueByPath(fromObject, [\n        \"generateAudio\"\n    ]) !== undefined) {\n        throw new Error(\"generateAudio parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"lastFrame\"\n    ]) !== undefined) {\n        throw new Error(\"lastFrame parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]) !== undefined) {\n        throw new Error(\"referenceImages parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"mask\"\n    ]) !== undefined) {\n        throw new Error(\"mask parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"compressionQuality\"\n    ]) !== undefined) {\n        throw new Error(\"compressionQuality parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateVideosConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (parentObject !== undefined && fromFps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"fps\"\n        ], fromFps);\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, [\n        \"resolution\"\n    ]);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"resolution\"\n        ], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromPubsubTopic = getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]);\n    if (parentObject !== undefined && fromPubsubTopic != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"pubsubTopic\"\n        ], fromPubsubTopic);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    const fromGenerateAudio = getValueByPath(fromObject, [\n        \"generateAudio\"\n    ]);\n    if (parentObject !== undefined && fromGenerateAudio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"generateAudio\"\n        ], fromGenerateAudio);\n    }\n    const fromLastFrame = getValueByPath(fromObject, [\n        \"lastFrame\"\n    ]);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"lastFrame\"\n        ], imageToVertex(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return videoGenerationReferenceImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    const fromMask = getValueByPath(fromObject, [\n        \"mask\"\n    ]);\n    if (parentObject !== undefined && fromMask != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"mask\"\n        ], videoGenerationMaskToVertex(fromMask));\n    }\n    const fromCompressionQuality = getValueByPath(fromObject, [\n        \"compressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"compressionQuality\"\n        ], fromCompressionQuality);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\",\n        \"generateVideoResponse\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromVertex(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToMldev(fromImage));\n    }\n    if (getValueByPath(fromObject, [\n        \"video\"\n    ]) !== undefined) {\n        throw new Error(\"video parameter is not supported in Gemini API.\");\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        generateVideosSourceToMldev(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateVideosConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToVertex(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        generateVideosSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateVideosConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"generatedSamples\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"videos\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosSourceToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToMldev(fromImage));\n    }\n    if (getValueByPath(fromObject, [\n        \"video\"\n    ]) !== undefined) {\n        throw new Error(\"video parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateVideosSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedImageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromMldev(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromMldev(fromSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generatedImageFromVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromVertex(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromVertex(fromSafetyAttributes));\n    }\n    const fromEnhancedPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromEnhancedPrompt != null) {\n        setValueByPath(toObject, [\n            \"enhancedPrompt\"\n        ], fromEnhancedPrompt);\n    }\n    return toObject;\n}\nfunction generatedImageMaskFromVertex(fromObject) {\n    const toObject = {};\n    const fromMask = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromMask != null) {\n        setValueByPath(toObject, [\n            \"mask\"\n        ], imageFromVertex(fromMask));\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        let transformedList = fromLabels;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return entityLabelFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"labels\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction getModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction getModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction googleMapsToVertex(fromObject) {\n    const toObject = {};\n    const fromAuthConfig = getValueByPath(fromObject, [\n        \"authConfig\"\n    ]);\n    if (fromAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"authConfig\"\n        ], authConfigToVertex(fromAuthConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$1(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$1(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToVertex(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$1(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev$1(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction googleSearchToVertex(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToVertex(fromTimeRangeFilter));\n    }\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, [\n            \"excludeDomains\"\n        ], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction imageConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, [\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    return toObject;\n}\nfunction imageConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, [\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    return toObject;\n}\nfunction imageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageFromVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction intervalToMldev$1(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction intervalToVertex(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction latLngToMldev(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction latLngToVertex(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction listModelsConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, [\n        \"queryBase\"\n    ]);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, [\n            \"_url\",\n            \"models_url\"\n        ], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, [\n        \"queryBase\"\n    ]);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, [\n            \"_url\",\n            \"models_url\"\n        ], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listModelsConfigToMldev(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listModelsConfigToVertex(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modelFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"models\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modelFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"models\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction maskReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMaskMode = getValueByPath(fromObject, [\n        \"maskMode\"\n    ]);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, [\n            \"maskMode\"\n        ], fromMaskMode);\n    }\n    const fromSegmentationClasses = getValueByPath(fromObject, [\n        \"segmentationClasses\"\n    ]);\n    if (fromSegmentationClasses != null) {\n        setValueByPath(toObject, [\n            \"maskClasses\"\n        ], fromSegmentationClasses);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, [\n        \"maskDilation\"\n    ]);\n    if (fromMaskDilation != null) {\n        setValueByPath(toObject, [\n            \"dilation\"\n        ], fromMaskDilation);\n    }\n    return toObject;\n}\nfunction modelFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"version\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromMldev(fromTunedModelInfo));\n    }\n    const fromInputTokenLimit = getValueByPath(fromObject, [\n        \"inputTokenLimit\"\n    ]);\n    if (fromInputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"inputTokenLimit\"\n        ], fromInputTokenLimit);\n    }\n    const fromOutputTokenLimit = getValueByPath(fromObject, [\n        \"outputTokenLimit\"\n    ]);\n    if (fromOutputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"outputTokenLimit\"\n        ], fromOutputTokenLimit);\n    }\n    const fromSupportedActions = getValueByPath(fromObject, [\n        \"supportedGenerationMethods\"\n    ]);\n    if (fromSupportedActions != null) {\n        setValueByPath(toObject, [\n            \"supportedActions\"\n        ], fromSupportedActions);\n    }\n    return toObject;\n}\nfunction modelFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"versionId\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromEndpoints = getValueByPath(fromObject, [\n        \"deployedModels\"\n    ]);\n    if (fromEndpoints != null) {\n        let transformedList = fromEndpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return endpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"endpoints\"\n        ], transformedList);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromVertex(fromTunedModelInfo));\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (fromDefaultCheckpointId != null) {\n        setValueByPath(toObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, [\n        \"checkpoints\"\n    ]);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return checkpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"checkpoints\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction modelSelectionConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromFeatureSelectionPreference = getValueByPath(fromObject, [\n        \"featureSelectionPreference\"\n    ]);\n    if (fromFeatureSelectionPreference != null) {\n        setValueByPath(toObject, [\n            \"featureSelectionPreference\"\n        ], fromFeatureSelectionPreference);\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        \"speakerVoiceConfigs\"\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return speakerVoiceConfigToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"speakerVoiceConfigs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partFromMldev(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromMldev(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromMldev(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromMldev(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallFromMldev(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction partFromVertex(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromVertex(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromVertex(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromVertex(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallFromVertex(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction partToMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$1(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction partToVertex(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToVertex(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToVertex(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToVertex(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToVertex(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction productImageToVertex(fromObject) {\n    const toObject = {};\n    const fromProductImage = getValueByPath(fromObject, [\n        \"productImage\"\n    ]);\n    if (fromProductImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromProductImage));\n    }\n    return toObject;\n}\nfunction recontextImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, [\n        \"baseSteps\"\n    ]);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editConfig\",\n            \"baseSteps\"\n        ], fromBaseSteps);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction recontextImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        recontextImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        recontextImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction recontextImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction recontextImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromPersonImage = getValueByPath(fromObject, [\n        \"personImage\"\n    ]);\n    if (parentObject !== undefined && fromPersonImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"personImage\",\n            \"image\"\n        ], imageToVertex(fromPersonImage));\n    }\n    const fromProductImages = getValueByPath(fromObject, [\n        \"productImages\"\n    ]);\n    if (parentObject !== undefined && fromProductImages != null) {\n        let transformedList = fromProductImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return productImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"productImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction referenceImageAPIInternalToVertex(fromObject) {\n    const toObject = {};\n    const fromReferenceImage = getValueByPath(fromObject, [\n        \"referenceImage\"\n    ]);\n    if (fromReferenceImage != null) {\n        setValueByPath(toObject, [\n            \"referenceImage\"\n        ], imageToVertex(fromReferenceImage));\n    }\n    const fromReferenceId = getValueByPath(fromObject, [\n        \"referenceId\"\n    ]);\n    if (fromReferenceId != null) {\n        setValueByPath(toObject, [\n            \"referenceId\"\n        ], fromReferenceId);\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    const fromMaskImageConfig = getValueByPath(fromObject, [\n        \"maskImageConfig\"\n    ]);\n    if (fromMaskImageConfig != null) {\n        setValueByPath(toObject, [\n            \"maskImageConfig\"\n        ], maskReferenceConfigToVertex(fromMaskImageConfig));\n    }\n    const fromControlImageConfig = getValueByPath(fromObject, [\n        \"controlImageConfig\"\n    ]);\n    if (fromControlImageConfig != null) {\n        setValueByPath(toObject, [\n            \"controlImageConfig\"\n        ], controlReferenceConfigToVertex(fromControlImageConfig));\n    }\n    const fromStyleImageConfig = getValueByPath(fromObject, [\n        \"styleImageConfig\"\n    ]);\n    if (fromStyleImageConfig != null) {\n        setValueByPath(toObject, [\n            \"styleImageConfig\"\n        ], styleReferenceConfigToVertex(fromStyleImageConfig));\n    }\n    const fromSubjectImageConfig = getValueByPath(fromObject, [\n        \"subjectImageConfig\"\n    ]);\n    if (fromSubjectImageConfig != null) {\n        setValueByPath(toObject, [\n            \"subjectImageConfig\"\n        ], subjectReferenceConfigToVertex(fromSubjectImageConfig));\n    }\n    return toObject;\n}\nfunction retrievalConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToMldev(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction retrievalConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToVertex(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromMldev(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromVertex(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"method\"\n    ]) !== undefined) {\n        throw new Error(\"method parameter is not supported in Gemini API.\");\n    }\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction safetySettingToVertex(fromObject) {\n    const toObject = {};\n    const fromMethod = getValueByPath(fromObject, [\n        \"method\"\n    ]);\n    if (fromMethod != null) {\n        setValueByPath(toObject, [\n            \"method\"\n        ], fromMethod);\n    }\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction schemaToMldev(fromObject) {\n    const toObject = {};\n    const fromAnyOf = getValueByPath(fromObject, [\n        \"anyOf\"\n    ]);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, [\n            \"anyOf\"\n        ], fromAnyOf);\n    }\n    const fromDefault = getValueByPath(fromObject, [\n        \"default\"\n    ]);\n    if (fromDefault != null) {\n        setValueByPath(toObject, [\n            \"default\"\n        ], fromDefault);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, [\n        \"enum\"\n    ]);\n    if (fromEnum != null) {\n        setValueByPath(toObject, [\n            \"enum\"\n        ], fromEnum);\n    }\n    const fromExample = getValueByPath(fromObject, [\n        \"example\"\n    ]);\n    if (fromExample != null) {\n        setValueByPath(toObject, [\n            \"example\"\n        ], fromExample);\n    }\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, [\n        \"items\"\n    ]);\n    if (fromItems != null) {\n        setValueByPath(toObject, [\n            \"items\"\n        ], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, [\n        \"maxItems\"\n    ]);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, [\n            \"maxItems\"\n        ], fromMaxItems);\n    }\n    const fromMaxLength = getValueByPath(fromObject, [\n        \"maxLength\"\n    ]);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, [\n            \"maxLength\"\n        ], fromMaxLength);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        \"maxProperties\"\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, [\n            \"maxProperties\"\n        ], fromMaxProperties);\n    }\n    const fromMaximum = getValueByPath(fromObject, [\n        \"maximum\"\n    ]);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, [\n            \"maximum\"\n        ], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, [\n        \"minItems\"\n    ]);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, [\n            \"minItems\"\n        ], fromMinItems);\n    }\n    const fromMinLength = getValueByPath(fromObject, [\n        \"minLength\"\n    ]);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, [\n            \"minLength\"\n        ], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        \"minProperties\"\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, [\n            \"minProperties\"\n        ], fromMinProperties);\n    }\n    const fromMinimum = getValueByPath(fromObject, [\n        \"minimum\"\n    ]);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, [\n            \"minimum\"\n        ], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, [\n        \"nullable\"\n    ]);\n    if (fromNullable != null) {\n        setValueByPath(toObject, [\n            \"nullable\"\n        ], fromNullable);\n    }\n    const fromPattern = getValueByPath(fromObject, [\n        \"pattern\"\n    ]);\n    if (fromPattern != null) {\n        setValueByPath(toObject, [\n            \"pattern\"\n        ], fromPattern);\n    }\n    const fromProperties = getValueByPath(fromObject, [\n        \"properties\"\n    ]);\n    if (fromProperties != null) {\n        setValueByPath(toObject, [\n            \"properties\"\n        ], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        \"propertyOrdering\"\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, [\n            \"propertyOrdering\"\n        ], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, [\n        \"required\"\n    ]);\n    if (fromRequired != null) {\n        setValueByPath(toObject, [\n            \"required\"\n        ], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (fromTitle != null) {\n        setValueByPath(toObject, [\n            \"title\"\n        ], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, [\n        \"type\"\n    ]);\n    if (fromType != null) {\n        setValueByPath(toObject, [\n            \"type\"\n        ], fromType);\n    }\n    return toObject;\n}\nfunction schemaToVertex(fromObject) {\n    const toObject = {};\n    const fromAnyOf = getValueByPath(fromObject, [\n        \"anyOf\"\n    ]);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, [\n            \"anyOf\"\n        ], fromAnyOf);\n    }\n    const fromDefault = getValueByPath(fromObject, [\n        \"default\"\n    ]);\n    if (fromDefault != null) {\n        setValueByPath(toObject, [\n            \"default\"\n        ], fromDefault);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, [\n        \"enum\"\n    ]);\n    if (fromEnum != null) {\n        setValueByPath(toObject, [\n            \"enum\"\n        ], fromEnum);\n    }\n    const fromExample = getValueByPath(fromObject, [\n        \"example\"\n    ]);\n    if (fromExample != null) {\n        setValueByPath(toObject, [\n            \"example\"\n        ], fromExample);\n    }\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, [\n        \"items\"\n    ]);\n    if (fromItems != null) {\n        setValueByPath(toObject, [\n            \"items\"\n        ], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, [\n        \"maxItems\"\n    ]);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, [\n            \"maxItems\"\n        ], fromMaxItems);\n    }\n    const fromMaxLength = getValueByPath(fromObject, [\n        \"maxLength\"\n    ]);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, [\n            \"maxLength\"\n        ], fromMaxLength);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        \"maxProperties\"\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, [\n            \"maxProperties\"\n        ], fromMaxProperties);\n    }\n    const fromMaximum = getValueByPath(fromObject, [\n        \"maximum\"\n    ]);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, [\n            \"maximum\"\n        ], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, [\n        \"minItems\"\n    ]);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, [\n            \"minItems\"\n        ], fromMinItems);\n    }\n    const fromMinLength = getValueByPath(fromObject, [\n        \"minLength\"\n    ]);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, [\n            \"minLength\"\n        ], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        \"minProperties\"\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, [\n            \"minProperties\"\n        ], fromMinProperties);\n    }\n    const fromMinimum = getValueByPath(fromObject, [\n        \"minimum\"\n    ]);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, [\n            \"minimum\"\n        ], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, [\n        \"nullable\"\n    ]);\n    if (fromNullable != null) {\n        setValueByPath(toObject, [\n            \"nullable\"\n        ], fromNullable);\n    }\n    const fromPattern = getValueByPath(fromObject, [\n        \"pattern\"\n    ]);\n    if (fromPattern != null) {\n        setValueByPath(toObject, [\n            \"pattern\"\n        ], fromPattern);\n    }\n    const fromProperties = getValueByPath(fromObject, [\n        \"properties\"\n    ]);\n    if (fromProperties != null) {\n        setValueByPath(toObject, [\n            \"properties\"\n        ], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        \"propertyOrdering\"\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, [\n            \"propertyOrdering\"\n        ], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, [\n        \"required\"\n    ]);\n    if (fromRequired != null) {\n        setValueByPath(toObject, [\n            \"required\"\n        ], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (fromTitle != null) {\n        setValueByPath(toObject, [\n            \"title\"\n        ], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, [\n        \"type\"\n    ]);\n    if (fromType != null) {\n        setValueByPath(toObject, [\n            \"type\"\n        ], fromType);\n    }\n    return toObject;\n}\nfunction scribbleImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    return toObject;\n}\nfunction segmentImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"mode\"\n        ], fromMode);\n    }\n    const fromMaxPredictions = getValueByPath(fromObject, [\n        \"maxPredictions\"\n    ]);\n    if (parentObject !== undefined && fromMaxPredictions != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"maxPredictions\"\n        ], fromMaxPredictions);\n    }\n    const fromConfidenceThreshold = getValueByPath(fromObject, [\n        \"confidenceThreshold\"\n    ]);\n    if (parentObject !== undefined && fromConfidenceThreshold != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"confidenceThreshold\"\n        ], fromConfidenceThreshold);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, [\n        \"maskDilation\"\n    ]);\n    if (parentObject !== undefined && fromMaskDilation != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"maskDilation\"\n        ], fromMaskDilation);\n    }\n    const fromBinaryColorThreshold = getValueByPath(fromObject, [\n        \"binaryColorThreshold\"\n    ]);\n    if (parentObject !== undefined && fromBinaryColorThreshold != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"binaryColorThreshold\"\n        ], fromBinaryColorThreshold);\n    }\n    return toObject;\n}\nfunction segmentImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        segmentImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        segmentImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction segmentImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedMasks = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedMasks != null) {\n        let transformedList = fromGeneratedMasks;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageMaskFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedMasks\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction segmentImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromScribbleImage = getValueByPath(fromObject, [\n        \"scribbleImage\"\n    ]);\n    if (parentObject !== undefined && fromScribbleImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"scribble\"\n        ], scribbleImageToVertex(fromScribbleImage));\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, [\n        \"speaker\"\n    ]);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, [\n            \"speaker\"\n        ], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$1(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction speechConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$1(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"multiSpeakerVoiceConfig\"\n        ], multiSpeakerVoiceConfigToMldev$1(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction speechConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToVertex(fromVoiceConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]) !== undefined) {\n        throw new Error(\"multiSpeakerVoiceConfig parameter is not supported in Vertex AI.\");\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction styleReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromStyleDescription = getValueByPath(fromObject, [\n        \"styleDescription\"\n    ]);\n    if (fromStyleDescription != null) {\n        setValueByPath(toObject, [\n            \"styleDescription\"\n        ], fromStyleDescription);\n    }\n    return toObject;\n}\nfunction subjectReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromSubjectType = getValueByPath(fromObject, [\n        \"subjectType\"\n    ]);\n    if (fromSubjectType != null) {\n        setValueByPath(toObject, [\n            \"subjectType\"\n        ], fromSubjectType);\n    }\n    const fromSubjectDescription = getValueByPath(fromObject, [\n        \"subjectDescription\"\n    ]);\n    if (fromSubjectDescription != null) {\n        setValueByPath(toObject, [\n            \"subjectDescription\"\n        ], fromSubjectDescription);\n    }\n    return toObject;\n}\nfunction thinkingConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction thinkingConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToMldev(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToVertex(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToVertex(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$1(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$1(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev$1());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], computerUseToMldev$1(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction toolToVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToVertex(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToVertex(fromGoogleSearchRetrieval));\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], enterpriseWebSearchToVertex(fromEnterpriseWebSearch));\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToVertex(fromGoogleMaps));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToVertex());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], computerUseToVertex(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromMldev(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromVertex(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"labels\",\n        \"google-vertex-llm-tuning-base-model-id\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction updateModelConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateModelConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateModelConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromEnhanceInputImage = getValueByPath(fromObject, [\n        \"enhanceInputImage\"\n    ]);\n    if (parentObject !== undefined && fromEnhanceInputImage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"enhanceInputImage\"\n        ], fromEnhanceInputImage);\n    }\n    const fromImagePreservationFactor = getValueByPath(fromObject, [\n        \"imagePreservationFactor\"\n    ]);\n    if (parentObject !== undefined && fromImagePreservationFactor != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"imagePreservationFactor\"\n        ], fromImagePreservationFactor);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"mode\"\n        ], fromMode);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromUpscaleFactor = getValueByPath(fromObject, [\n        \"upscaleFactor\"\n    ]);\n    if (fromUpscaleFactor != null) {\n        setValueByPath(toObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"upscaleFactor\"\n        ], fromUpscaleFactor);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, [\n        \"urlMetadata\"\n    ]);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return urlMetadataFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"urlMetadata\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, [\n        \"urlMetadata\"\n    ]);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return urlMetadataFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"urlMetadata\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction urlContextToMldev$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction urlContextToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction urlMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, [\n        \"retrievedUrl\"\n    ]);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, [\n            \"retrievedUrl\"\n        ], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        \"urlRetrievalStatus\"\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, [\n            \"urlRetrievalStatus\"\n        ], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction urlMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, [\n        \"retrievedUrl\"\n    ]);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, [\n            \"retrievedUrl\"\n        ], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        \"urlRetrievalStatus\"\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, [\n            \"urlRetrievalStatus\"\n        ], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction videoFromMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"video\",\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"video\",\n        \"encodedVideo\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"encoding\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoGenerationMaskToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"_self\"\n        ], imageToVertex(fromImage));\n    }\n    const fromMaskMode = getValueByPath(fromObject, [\n        \"maskMode\"\n    ]);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, [\n            \"maskMode\"\n        ], fromMaskMode);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataToVertex(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoToVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"videoBytes\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToMldev$1(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction voiceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToVertex(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const CONTENT_TYPE_HEADER = \"Content-Type\";\nconst SERVER_TIMEOUT_HEADER = \"X-Server-Timeout\";\nconst USER_AGENT_HEADER = \"User-Agent\";\nconst GOOGLE_API_CLIENT_HEADER = \"x-goog-api-client\";\nconst SDK_VERSION = \"1.22.0\"; // x-release-please-version\nconst LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;\nconst VERTEX_AI_API_DEFAULT_VERSION = \"v1beta1\";\nconst GOOGLE_AI_API_DEFAULT_VERSION = \"v1beta\";\nconst responseLineRE = /^\\s*data: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n/**\n * The ApiClient class is used to send requests to the Gemini API or Vertex AI\n * endpoints.\n */ class ApiClient {\n    constructor(opts){\n        var _a, _b;\n        this.clientOptions = Object.assign(Object.assign({}, opts), {\n            project: opts.project,\n            location: opts.location,\n            apiKey: opts.apiKey,\n            vertexai: opts.vertexai\n        });\n        const initHttpOptions = {};\n        if (this.clientOptions.vertexai) {\n            initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();\n            this.normalizeAuthParameters();\n        } else {\n            // Gemini API\n            initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;\n        }\n        initHttpOptions.headers = this.getDefaultHeaders();\n        this.clientOptions.httpOptions = initHttpOptions;\n        if (opts.httpOptions) {\n            this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);\n        }\n    }\n    /**\n     * Determines the base URL for Vertex AI based on project and location.\n     * Uses the global endpoint if location is 'global' or if project/location\n     * are not specified (implying API key usage).\n     * @private\n     */ baseUrlFromProjectLocation() {\n        if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== \"global\") {\n            // Regional endpoint\n            return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;\n        }\n        // Global endpoint (covers 'global' location and API key usage)\n        return `https://aiplatform.googleapis.com/`;\n    }\n    /**\n     * Normalizes authentication parameters for Vertex AI.\n     * If project and location are provided, API key is cleared.\n     * If project and location are not provided (implying API key usage),\n     * project and location are cleared.\n     * @private\n     */ normalizeAuthParameters() {\n        if (this.clientOptions.project && this.clientOptions.location) {\n            // Using project/location for auth, clear potential API key\n            this.clientOptions.apiKey = undefined;\n            return;\n        }\n        // Using API key for auth (or no auth provided yet), clear project/location\n        this.clientOptions.project = undefined;\n        this.clientOptions.location = undefined;\n    }\n    isVertexAI() {\n        var _a;\n        return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;\n    }\n    getProject() {\n        return this.clientOptions.project;\n    }\n    getLocation() {\n        return this.clientOptions.location;\n    }\n    getApiVersion() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== undefined) {\n            return this.clientOptions.httpOptions.apiVersion;\n        }\n        throw new Error(\"API version is not set.\");\n    }\n    getBaseUrl() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== undefined) {\n            return this.clientOptions.httpOptions.baseUrl;\n        }\n        throw new Error(\"Base URL is not set.\");\n    }\n    getRequestUrl() {\n        return this.getRequestUrlInternal(this.clientOptions.httpOptions);\n    }\n    getHeaders() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== undefined) {\n            return this.clientOptions.httpOptions.headers;\n        } else {\n            throw new Error(\"Headers are not set.\");\n        }\n    }\n    getRequestUrlInternal(httpOptions) {\n        if (!httpOptions || httpOptions.baseUrl === undefined || httpOptions.apiVersion === undefined) {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n        const baseUrl = httpOptions.baseUrl.endsWith(\"/\") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;\n        const urlElement = [\n            baseUrl\n        ];\n        if (httpOptions.apiVersion && httpOptions.apiVersion !== \"\") {\n            urlElement.push(httpOptions.apiVersion);\n        }\n        return urlElement.join(\"/\");\n    }\n    getBaseResourcePath() {\n        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;\n    }\n    getApiKey() {\n        return this.clientOptions.apiKey;\n    }\n    getWebsocketBaseUrl() {\n        const baseUrl = this.getBaseUrl();\n        const urlParts = new URL(baseUrl);\n        urlParts.protocol = urlParts.protocol == \"http:\" ? \"ws\" : \"wss\";\n        return urlParts.toString();\n    }\n    setBaseUrl(url) {\n        if (this.clientOptions.httpOptions) {\n            this.clientOptions.httpOptions.baseUrl = url;\n        } else {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n    }\n    constructUrl(path, httpOptions, prependProjectLocation) {\n        const urlElement = [\n            this.getRequestUrlInternal(httpOptions)\n        ];\n        if (prependProjectLocation) {\n            urlElement.push(this.getBaseResourcePath());\n        }\n        if (path !== \"\") {\n            urlElement.push(path);\n        }\n        const url = new URL(`${urlElement.join(\"/\")}`);\n        return url;\n    }\n    shouldPrependVertexProjectPath(request) {\n        if (this.clientOptions.apiKey) {\n            return false;\n        }\n        if (!this.clientOptions.vertexai) {\n            return false;\n        }\n        if (request.path.startsWith(\"projects/\")) {\n            // Assume the path already starts with\n            // `projects/<project>/location/<location>`.\n            return false;\n        }\n        if (request.httpMethod === \"GET\" && request.path.startsWith(\"publishers/google/models\")) {\n            // These paths are used by Vertex's models.get and models.list\n            // calls. For base models Vertex does not accept a project/location\n            // prefix (for tuned model the prefix is required).\n            return false;\n        }\n        return true;\n    }\n    async request(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (request.queryParams) {\n            for (const [key, value] of Object.entries(request.queryParams)){\n                url.searchParams.append(key, String(value));\n            }\n        }\n        let requestInit = {};\n        if (request.httpMethod === \"GET\") {\n            if (request.body && request.body !== \"{}\") {\n                throw new Error(\"Request body should be empty for GET request, but got non empty request body\");\n            }\n        } else {\n            requestInit.body = request.body;\n        }\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);\n        return this.unaryApiCall(url, requestInit, request.httpMethod);\n    }\n    patchHttpOptions(baseHttpOptions, requestHttpOptions) {\n        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));\n        for (const [key, value] of Object.entries(requestHttpOptions)){\n            // Records compile to objects.\n            if (typeof value === \"object\") {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);\n            } else if (value !== undefined) {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = value;\n            }\n        }\n        return patchedHttpOptions;\n    }\n    async requestStream(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (!url.searchParams.has(\"alt\") || url.searchParams.get(\"alt\") !== \"sse\") {\n            url.searchParams.set(\"alt\", \"sse\");\n        }\n        let requestInit = {};\n        requestInit.body = request.body;\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);\n        return this.streamApiCall(url, requestInit, request.httpMethod);\n    }\n    async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, abortSignal) {\n        if (httpOptions && httpOptions.timeout || abortSignal) {\n            const abortController = new AbortController();\n            const signal = abortController.signal;\n            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {\n                const timeoutHandle = setTimeout(()=>abortController.abort(), httpOptions.timeout);\n                if (timeoutHandle && typeof timeoutHandle.unref === \"function\") {\n                    // call unref to prevent nodejs process from hanging, see\n                    // https://nodejs.org/api/timers.html#timeoutunref\n                    timeoutHandle.unref();\n                }\n            }\n            if (abortSignal) {\n                abortSignal.addEventListener(\"abort\", ()=>{\n                    abortController.abort();\n                });\n            }\n            requestInit.signal = signal;\n        }\n        if (httpOptions && httpOptions.extraBody !== null) {\n            includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);\n        }\n        requestInit.headers = await this.getHeadersInternal(httpOptions);\n        return requestInit;\n    }\n    async unaryApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return new HttpResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    async streamApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return this.processStreamResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    processStreamResponse(response) {\n        var _a;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();\n            const decoder = new TextDecoder(\"utf-8\");\n            if (!reader) {\n                throw new Error(\"Response body is empty\");\n            }\n            try {\n                let buffer = \"\";\n                while(true){\n                    const { done, value } = yield __await(reader.read());\n                    if (done) {\n                        if (buffer.trim().length > 0) {\n                            throw new Error(\"Incomplete JSON segment at the end\");\n                        }\n                        break;\n                    }\n                    const chunkString = decoder.decode(value, {\n                        stream: true\n                    });\n                    // Parse and throw an error if the chunk contains an error.\n                    try {\n                        const chunkJson = JSON.parse(chunkString);\n                        if (\"error\" in chunkJson) {\n                            const errorJson = JSON.parse(JSON.stringify(chunkJson[\"error\"]));\n                            const status = errorJson[\"status\"];\n                            const code = errorJson[\"code\"];\n                            const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;\n                            if (code >= 400 && code < 600) {\n                                const apiError = new ApiError({\n                                    message: errorMessage,\n                                    status: code\n                                });\n                                throw apiError;\n                            }\n                        }\n                    } catch (e) {\n                        const error = e;\n                        if (error.name === \"ApiError\") {\n                            throw e;\n                        }\n                    }\n                    buffer += chunkString;\n                    let match = buffer.match(responseLineRE);\n                    while(match){\n                        const processedChunkString = match[1];\n                        try {\n                            const partialResponse = new Response(processedChunkString, {\n                                headers: response === null || response === void 0 ? void 0 : response.headers,\n                                status: response === null || response === void 0 ? void 0 : response.status,\n                                statusText: response === null || response === void 0 ? void 0 : response.statusText\n                            });\n                            yield yield __await(new HttpResponse(partialResponse));\n                            buffer = buffer.slice(match[0].length);\n                            match = buffer.match(responseLineRE);\n                        } catch (e) {\n                            throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);\n                        }\n                    }\n                }\n            } finally{\n                reader.releaseLock();\n            }\n        });\n    }\n    async apiCall(url, requestInit) {\n        return fetch(url, requestInit).catch((e)=>{\n            throw new Error(`exception ${e} sending request`);\n        });\n    }\n    getDefaultHeaders() {\n        const headers = {};\n        const versionHeaderValue = LIBRARY_LABEL + \" \" + this.clientOptions.userAgentExtra;\n        headers[USER_AGENT_HEADER] = versionHeaderValue;\n        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;\n        headers[CONTENT_TYPE_HEADER] = \"application/json\";\n        return headers;\n    }\n    async getHeadersInternal(httpOptions) {\n        const headers = new Headers();\n        if (httpOptions && httpOptions.headers) {\n            for (const [key, value] of Object.entries(httpOptions.headers)){\n                headers.append(key, value);\n            }\n            // Append a timeout header if it is set, note that the timeout option is\n            // in milliseconds but the header is in seconds.\n            if (httpOptions.timeout && httpOptions.timeout > 0) {\n                headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1000)));\n            }\n        }\n        await this.clientOptions.auth.addAuthHeaders(headers);\n        return headers;\n    }\n    /**\n     * Uploads a file asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */ async uploadFile(file, config) {\n        var _a;\n        const fileToUpload = {};\n        if (config != null) {\n            fileToUpload.mimeType = config.mimeType;\n            fileToUpload.name = config.name;\n            fileToUpload.displayName = config.displayName;\n        }\n        if (fileToUpload.name && !fileToUpload.name.startsWith(\"files/\")) {\n            fileToUpload.name = `files/${fileToUpload.name}`;\n        }\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        fileToUpload.sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === \"\") {\n            throw new Error(\"Can not determine mimeType. Please provide mimeType in the config.\");\n        }\n        fileToUpload.mimeType = mimeType;\n        const uploadUrl = await this.fetchUploadUrl(fileToUpload, config);\n        return uploader.upload(file, uploadUrl, this);\n    }\n    /**\n     * Downloads a file asynchronously to the specified path.\n     *\n     * @params params - The parameters for the download request, see {@link\n     * DownloadFileParameters}\n     */ async downloadFile(params) {\n        const downloader = this.clientOptions.downloader;\n        await downloader.download(params, this);\n    }\n    async fetchUploadUrl(file, config) {\n        var _a;\n        let httpOptions = {};\n        if (config === null || config === void 0 ? void 0 : config.httpOptions) {\n            httpOptions = config.httpOptions;\n        } else {\n            httpOptions = {\n                apiVersion: \"\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"X-Goog-Upload-Protocol\": \"resumable\",\n                    \"X-Goog-Upload-Command\": \"start\",\n                    \"X-Goog-Upload-Header-Content-Length\": `${file.sizeBytes}`,\n                    \"X-Goog-Upload-Header-Content-Type\": `${file.mimeType}`\n                }\n            };\n        }\n        const body = {\n            \"file\": file\n        };\n        const httpResponse = await this.request({\n            path: formatMap(\"upload/v1beta/files\", body[\"_url\"]),\n            body: JSON.stringify(body),\n            httpMethod: \"POST\",\n            httpOptions\n        });\n        if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {\n            throw new Error(\"Server did not return an HttpResponse or the returned HttpResponse did not have headers.\");\n        }\n        const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a[\"x-goog-upload-url\"];\n        if (uploadUrl === undefined) {\n            throw new Error(\"Failed to get upload url. Server did not return the x-google-upload-url in the headers\");\n        }\n        return uploadUrl;\n    }\n}\nasync function throwErrorIfNotOK(response) {\n    var _a;\n    if (response === undefined) {\n        throw new Error(\"response is undefined\");\n    }\n    if (!response.ok) {\n        const status = response.status;\n        let errorBody;\n        if ((_a = response.headers.get(\"content-type\")) === null || _a === void 0 ? void 0 : _a.includes(\"application/json\")) {\n            errorBody = await response.json();\n        } else {\n            errorBody = {\n                error: {\n                    message: await response.text(),\n                    code: response.status,\n                    status: response.statusText\n                }\n            };\n        }\n        const errorMessage = JSON.stringify(errorBody);\n        if (status >= 400 && status < 600) {\n            const apiError = new ApiError({\n                message: errorMessage,\n                status: status\n            });\n            throw apiError;\n        }\n        throw new Error(errorMessage);\n    }\n}\n/**\n * Recursively updates the `requestInit.body` with values from an `extraBody` object.\n *\n * If `requestInit.body` is a string, it's assumed to be JSON and will be parsed.\n * The `extraBody` is then deeply merged into this parsed object.\n * If `requestInit.body` is a Blob, `extraBody` will be ignored, and a warning logged,\n * as merging structured data into an opaque Blob is not supported.\n *\n * The function does not enforce that updated values from `extraBody` have the\n * same type as existing values in `requestInit.body`. Type mismatches during\n * the merge will result in a warning, but the value from `extraBody` will overwrite\n * the original. `extraBody` users are responsible for ensuring `extraBody` has the correct structure.\n *\n * @param requestInit The RequestInit object whose body will be updated.\n * @param extraBody The object containing updates to be merged into `requestInit.body`.\n */ function includeExtraBodyToRequestInit(requestInit, extraBody) {\n    if (!extraBody || Object.keys(extraBody).length === 0) {\n        return;\n    }\n    if (requestInit.body instanceof Blob) {\n        console.warn(\"includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.\");\n        return;\n    }\n    let currentBodyObject = {};\n    // If adding new type to HttpRequest.body, please check the code below to\n    // see if we need to update the logic.\n    if (typeof requestInit.body === \"string\" && requestInit.body.length > 0) {\n        try {\n            const parsedBody = JSON.parse(requestInit.body);\n            if (typeof parsedBody === \"object\" && parsedBody !== null && !Array.isArray(parsedBody)) {\n                currentBodyObject = parsedBody;\n            } else {\n                console.warn(\"includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.\");\n                return;\n            }\n        /*  eslint-disable-next-line @typescript-eslint/no-unused-vars */ } catch (e) {\n            console.warn(\"includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.\");\n            return;\n        }\n    }\n    function deepMerge(target, source) {\n        const output = Object.assign({}, target);\n        for(const key in source){\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                const sourceValue = source[key];\n                const targetValue = output[key];\n                if (sourceValue && typeof sourceValue === \"object\" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === \"object\" && !Array.isArray(targetValue)) {\n                    output[key] = deepMerge(targetValue, sourceValue);\n                } else {\n                    if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {\n                        console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key \"${key}\". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);\n                    }\n                    output[key] = sourceValue;\n                }\n            }\n        }\n        return output;\n    }\n    const mergedBody = deepMerge(currentBodyObject, extraBody);\n    requestInit.body = JSON.stringify(mergedBody);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // TODO: b/416041229 - Determine how to retrieve the MCP package version.\nconst MCP_LABEL = \"mcp_used/unknown\";\n// Whether MCP tool usage is detected from mcpToTool. This is used for\n// telemetry.\nlet hasMcpToolUsageFromMcpToTool = false;\n// Checks whether the list of tools contains any MCP tools.\nfunction hasMcpToolUsage(tools) {\n    for (const tool of tools){\n        if (isMcpCallableTool(tool)) {\n            return true;\n        }\n        if (typeof tool === \"object\" && \"inputSchema\" in tool) {\n            return true;\n        }\n    }\n    return hasMcpToolUsageFromMcpToTool;\n}\n// Sets the MCP version label in the Google API client header.\nfunction setMcpUsageHeader(headers) {\n    var _a;\n    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : \"\";\n    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();\n}\n// Returns true if the object is a MCP CallableTool, otherwise false.\nfunction isMcpCallableTool(object) {\n    return object !== null && typeof object === \"object\" && object instanceof McpCallableTool;\n}\n// List all tools from the MCP client.\nfunction listAllTools(mcpClient, maxTools = 100) {\n    return __asyncGenerator(this, arguments, function* listAllTools_1() {\n        let cursor = undefined;\n        let numTools = 0;\n        while(numTools < maxTools){\n            const t = yield __await(mcpClient.listTools({\n                cursor\n            }));\n            for (const tool of t.tools){\n                yield yield __await(tool);\n                numTools++;\n            }\n            if (!t.nextCursor) {\n                break;\n            }\n            cursor = t.nextCursor;\n        }\n    });\n}\n/**\n * McpCallableTool can be used for model inference and invoking MCP clients with\n * given function call arguments.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */ class McpCallableTool {\n    constructor(mcpClients = [], config){\n        this.mcpTools = [];\n        this.functionNameToMcpClient = {};\n        this.mcpClients = mcpClients;\n        this.config = config;\n    }\n    /**\n     * Creates a McpCallableTool.\n     */ static create(mcpClients, config) {\n        return new McpCallableTool(mcpClients, config);\n    }\n    /**\n     * Validates the function names are not duplicate and initialize the function\n     * name to MCP client mapping.\n     *\n     * @throws {Error} if the MCP tools from the MCP clients have duplicate tool\n     *     names.\n     */ async initialize() {\n        var _a, e_1, _b, _c;\n        if (this.mcpTools.length > 0) {\n            return;\n        }\n        const functionMap = {};\n        const mcpTools = [];\n        for (const mcpClient of this.mcpClients){\n            try {\n                for(var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const mcpTool = _c;\n                    mcpTools.push(mcpTool);\n                    const mcpToolName = mcpTool.name;\n                    if (functionMap[mcpToolName]) {\n                        throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n                    }\n                    functionMap[mcpToolName] = mcpClient;\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        }\n        this.mcpTools = mcpTools;\n        this.functionNameToMcpClient = functionMap;\n    }\n    async tool() {\n        await this.initialize();\n        return mcpToolsToGeminiTool(this.mcpTools, this.config);\n    }\n    async callTool(functionCalls) {\n        await this.initialize();\n        const functionCallResponseParts = [];\n        for (const functionCall of functionCalls){\n            if (functionCall.name in this.functionNameToMcpClient) {\n                const mcpClient = this.functionNameToMcpClient[functionCall.name];\n                let requestOptions = undefined;\n                // TODO: b/424238654 - Add support for finer grained timeout control.\n                if (this.config.timeout) {\n                    requestOptions = {\n                        timeout: this.config.timeout\n                    };\n                }\n                const callToolResponse = await mcpClient.callTool({\n                    name: functionCall.name,\n                    arguments: functionCall.args\n                }, // Set the result schema to undefined to allow MCP to rely on the\n                // default schema.\n                undefined, requestOptions);\n                functionCallResponseParts.push({\n                    functionResponse: {\n                        name: functionCall.name,\n                        response: callToolResponse.isError ? {\n                            error: callToolResponse\n                        } : callToolResponse\n                    }\n                });\n            }\n        }\n        return functionCallResponseParts;\n    }\n}\nfunction isMcpClient(client) {\n    return client !== null && typeof client === \"object\" && \"listTools\" in client && typeof client.listTools === \"function\";\n}\n/**\n * Creates a McpCallableTool from MCP clients and an optional config.\n *\n * The callable tool can invoke the MCP clients with given function call\n * arguments. (often for automatic function calling).\n * Use the config to modify tool parameters such as behavior.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */ function mcpToTool(...args) {\n    // Set MCP usage for telemetry.\n    hasMcpToolUsageFromMcpToTool = true;\n    if (args.length === 0) {\n        throw new Error(\"No MCP clients provided\");\n    }\n    const maybeConfig = args[args.length - 1];\n    if (isMcpClient(maybeConfig)) {\n        return McpCallableTool.create(args, {});\n    }\n    return McpCallableTool.create(args.slice(0, args.length - 1), maybeConfig);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveMusicServerMessage, and then calling the onmessage callback.\n * Note that the first message which is received from the server is a\n * setupComplete message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */ async function handleWebSocketMessage$1(apiClient, onmessage, event) {\n    const serverMessage = new LiveMusicServerMessage();\n    let data;\n    if (event.data instanceof Blob) {\n        data = JSON.parse(await event.data.text());\n    } else {\n        data = JSON.parse(event.data);\n    }\n    const response = liveMusicServerMessageFromMldev(data);\n    Object.assign(serverMessage, response);\n    onmessage(serverMessage);\n}\n/**\n   LiveMusic class encapsulates the configuration for live music\n   generation via Lyria Live models.\n\n   @experimental\n  */ class LiveMusic {\n    constructor(apiClient, auth, webSocketFactory){\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n    }\n    /**\n       Establishes a connection to the specified model and returns a\n       LiveMusicSession object representing that connection.\n  \n       @experimental\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model = 'models/lyria-realtime-exp';\n       const session = await ai.live.music.connect({\n         model: model,\n         callbacks: {\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */ async connect(params) {\n        var _a, _b;\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Live music is not supported for Vertex AI.\");\n        }\n        console.warn(\"Live music generation is experimental and may change in future versions.\");\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());\n        const apiKey = this.apiClient.getApiKey();\n        const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;\n        let onopenResolve = ()=>{};\n        const onopenPromise = new Promise((resolve)=>{\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function() {\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event)=>{\n                void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {},\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {}\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        const model = tModel(this.apiClient, params.model);\n        const setup = liveMusicClientSetupToMldev({\n            model\n        });\n        const clientMessage = liveMusicClientMessageToMldev({\n            setup\n        });\n        conn.send(JSON.stringify(clientMessage));\n        return new LiveMusicSession(conn, this.apiClient);\n    }\n}\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */ class LiveMusicSession {\n    constructor(conn, apiClient){\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    /**\n      Sets inputs to steer music generation. Updates the session's current\n      weighted prompts.\n  \n      @param params - Contains one property, `weightedPrompts`.\n  \n        - `weightedPrompts` to send to the model; weights are normalized to\n          sum to 1.0.\n  \n      @experimental\n     */ async setWeightedPrompts(params) {\n        if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {\n            throw new Error(\"Weighted prompts must be set and contain at least one entry.\");\n        }\n        const setWeightedPromptsParameters = liveMusicSetWeightedPromptsParametersToMldev(params);\n        const clientContent = liveMusicClientContentToMldev(setWeightedPromptsParameters);\n        this.conn.send(JSON.stringify({\n            clientContent\n        }));\n    }\n    /**\n      Sets a configuration to the model. Updates the session's current\n      music generation config.\n  \n      @param params - Contains one property, `musicGenerationConfig`.\n  \n        - `musicGenerationConfig` to set in the model. Passing an empty or\n      undefined config to the model will reset the config to defaults.\n  \n      @experimental\n     */ async setMusicGenerationConfig(params) {\n        if (!params.musicGenerationConfig) {\n            params.musicGenerationConfig = {};\n        }\n        const setConfigParameters = liveMusicSetConfigParametersToMldev(params);\n        const clientMessage = liveMusicClientMessageToMldev(setConfigParameters);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    sendPlaybackControl(playbackControl) {\n        const clientMessage = liveMusicClientMessageToMldev({\n            playbackControl\n        });\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n     * Start the music stream.\n     *\n     * @experimental\n     */ play() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);\n    }\n    /**\n     * Temporarily halt the music stream. Use `play` to resume from the current\n     * position.\n     *\n     * @experimental\n     */ pause() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);\n    }\n    /**\n     * Stop the music stream and reset the state. Retains the current prompts\n     * and config.\n     *\n     * @experimental\n     */ stop() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);\n    }\n    /**\n     * Resets the context of the music generation without stopping it.\n     * Retains the current prompts and config.\n     *\n     * @experimental\n     */ resetContext() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n     */ close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap$1(headers) {\n    const headerMap = {};\n    headers.forEach((value, key)=>{\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders$1(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)){\n        headers.append(key, value);\n    }\n    return headers;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const FUNCTION_RESPONSE_REQUIRES_ID = \"FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.\";\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveServerMessages, and then calling the onmessage callback. Note that\n * the first message which is received from the server is a setupComplete\n * message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */ async function handleWebSocketMessage(apiClient, onmessage, event) {\n    const serverMessage = new LiveServerMessage();\n    let jsonData;\n    if (event.data instanceof Blob) {\n        jsonData = await event.data.text();\n    } else if (event.data instanceof ArrayBuffer) {\n        jsonData = new TextDecoder().decode(event.data);\n    } else {\n        jsonData = event.data;\n    }\n    const data = JSON.parse(jsonData);\n    if (apiClient.isVertexAI()) {\n        const resp = liveServerMessageFromVertex(data);\n        Object.assign(serverMessage, resp);\n    } else {\n        const resp = liveServerMessageFromMldev(data);\n        Object.assign(serverMessage, resp);\n    }\n    onmessage(serverMessage);\n}\n/**\n   Live class encapsulates the configuration for live interaction with the\n   Generative Language API. It embeds ApiClient for general API settings.\n\n   @experimental\n  */ class Live {\n    constructor(apiClient, auth, webSocketFactory){\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n        this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);\n    }\n    /**\n       Establishes a connection to the specified model with the given\n       configuration and returns a Session object representing that connection.\n  \n       @experimental Built-in MCP support is an experimental feature, may change in\n       future versions.\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         },\n         callbacks: {\n           onopen: () => {\n             console.log('Connected to the socket.');\n           },\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */ async connect(params) {\n        var _a, _b, _c, _d, _e, _f;\n        // TODO: b/404946746 - Support per request HTTP options.\n        if (params.config && params.config.httpOptions) {\n            throw new Error(\"The Live module does not support httpOptions at request-level in\" + \" LiveConnectConfig yet. Please use the client-level httpOptions\" + \" configuration instead.\");\n        }\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        let url;\n        const clientHeaders = this.apiClient.getHeaders();\n        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {\n            setMcpUsageHeader(clientHeaders);\n        }\n        const headers = mapToHeaders(clientHeaders);\n        if (this.apiClient.isVertexAI()) {\n            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;\n            await this.auth.addAuthHeaders(headers);\n        } else {\n            const apiKey = this.apiClient.getApiKey();\n            let method = \"BidiGenerateContent\";\n            let keyName = \"key\";\n            if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith(\"auth_tokens/\")) {\n                console.warn(\"Warning: Ephemeral token support is experimental and may change in future versions.\");\n                if (apiVersion !== \"v1alpha\") {\n                    console.warn(\"Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.\");\n                }\n                method = \"BidiGenerateContentConstrained\";\n                keyName = \"access_token\";\n            }\n            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;\n        }\n        let onopenResolve = ()=>{};\n        const onopenPromise = new Promise((resolve)=>{\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function() {\n            var _a;\n            (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a === void 0 ? void 0 : _a.call(callbacks);\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event)=>{\n                void handleWebSocketMessage(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {},\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {}\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        let transformedModel = tModel(this.apiClient, params.model);\n        if (this.apiClient.isVertexAI() && transformedModel.startsWith(\"publishers/\")) {\n            const project = this.apiClient.getProject();\n            const location = this.apiClient.getLocation();\n            transformedModel = `projects/${project}/locations/${location}/` + transformedModel;\n        }\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === undefined) {\n            // Set default to AUDIO to align with MLDev API.\n            if (params.config === undefined) {\n                params.config = {\n                    responseModalities: [\n                        Modality.AUDIO\n                    ]\n                };\n            } else {\n                params.config.responseModalities = [\n                    Modality.AUDIO\n                ];\n            }\n        }\n        if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {\n            // Raise deprecation warning for generationConfig.\n            console.warn(\"Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).\");\n        }\n        const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];\n        const convertedTools = [];\n        for (const tool of inputTools){\n            if (this.isCallableTool(tool)) {\n                const callableTool = tool;\n                convertedTools.push(await callableTool.tool());\n            } else {\n                convertedTools.push(tool);\n            }\n        }\n        if (convertedTools.length > 0) {\n            params.config.tools = convertedTools;\n        }\n        const liveConnectParameters = {\n            model: transformedModel,\n            config: params.config,\n            callbacks: params.callbacks\n        };\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);\n        } else {\n            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);\n        }\n        delete clientMessage[\"config\"];\n        conn.send(JSON.stringify(clientMessage));\n        return new Session(conn, this.apiClient);\n    }\n    // TODO: b/416041229 - Abstract this method to a common place.\n    isCallableTool(tool) {\n        return \"callTool\" in tool && typeof tool.callTool === \"function\";\n    }\n}\nconst defaultLiveSendClientContentParamerters = {\n    turnComplete: true\n};\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */ class Session {\n    constructor(conn, apiClient){\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    tLiveClientContent(apiClient, params) {\n        if (params.turns !== null && params.turns !== undefined) {\n            let contents = [];\n            try {\n                contents = tContents(params.turns);\n                if (apiClient.isVertexAI()) {\n                    contents = contents.map((item)=>contentToVertex(item));\n                } else {\n                    contents = contents.map((item)=>contentToMldev$1(item));\n                }\n            } catch (_a) {\n                throw new Error(`Failed to parse client content \"turns\", type: '${typeof params.turns}'`);\n            }\n            return {\n                clientContent: {\n                    turns: contents,\n                    turnComplete: params.turnComplete\n                }\n            };\n        }\n        return {\n            clientContent: {\n                turnComplete: params.turnComplete\n            }\n        };\n    }\n    tLiveClienttToolResponse(apiClient, params) {\n        let functionResponses = [];\n        if (params.functionResponses == null) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        if (!Array.isArray(params.functionResponses)) {\n            functionResponses = [\n                params.functionResponses\n            ];\n        } else {\n            functionResponses = params.functionResponses;\n        }\n        if (functionResponses.length === 0) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        for (const functionResponse of functionResponses){\n            if (typeof functionResponse !== \"object\" || functionResponse === null || !(\"name\" in functionResponse) || !(\"response\" in functionResponse)) {\n                throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);\n            }\n            if (!apiClient.isVertexAI() && !(\"id\" in functionResponse)) {\n                throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);\n            }\n        }\n        const clientMessage = {\n            toolResponse: {\n                functionResponses: functionResponses\n            }\n        };\n        return clientMessage;\n    }\n    /**\n      Send a message over the established connection.\n  \n      @param params - Contains two **optional** properties, `turns` and\n          `turnComplete`.\n  \n        - `turns` will be converted to a `Content[]`\n        - `turnComplete: true` [default] indicates that you are done sending\n          content and expect a response. If `turnComplete: false`, the server\n          will wait for additional messages before starting generation.\n  \n      @experimental\n  \n      @remarks\n      There are two ways to send messages to the live API:\n      `sendClientContent` and `sendRealtimeInput`.\n  \n      `sendClientContent` messages are added to the model context **in order**.\n      Having a conversation using `sendClientContent` messages is roughly\n      equivalent to using the `Chat.sendMessageStream`, except that the state of\n      the `chat` history is stored on the API server instead of locally.\n  \n      Because of `sendClientContent`'s order guarantee, the model cannot respons\n      as quickly to `sendClientContent` messages as to `sendRealtimeInput`\n      messages. This makes the biggest difference when sending objects that have\n      significant preprocessing time (typically images).\n  \n      The `sendClientContent` message sends a `Content[]`\n      which has more options than the `Blob` sent by `sendRealtimeInput`.\n  \n      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:\n  \n      - Sending anything that can't be represented as a `Blob` (text,\n      `sendClientContent({turns=\"Hello?\"}`)).\n      - Managing turns when not using audio input and voice activity detection.\n        (`sendClientContent({turnComplete:true})` or the short form\n      `sendClientContent()`)\n      - Prefilling a conversation context\n        ```\n        sendClientContent({\n            turns: [\n              Content({role:user, parts:...}),\n              Content({role:user, parts:...}),\n              ...\n            ]\n        })\n        ```\n      @experimental\n     */ sendClientContent(params) {\n        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);\n        const clientMessage = this.tLiveClientContent(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a realtime message over the established connection.\n  \n      @param params - Contains one property, `media`.\n  \n        - `media` will be converted to a `Blob`\n  \n      @experimental\n  \n      @remarks\n      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).\n  \n      With `sendRealtimeInput` the api will respond to audio automatically\n      based on voice activity detection (VAD).\n  \n      `sendRealtimeInput` is optimized for responsivness at the expense of\n      deterministic ordering guarantees. Audio and video tokens are to the\n      context when they become available.\n  \n      Note: The Call signature expects a `Blob` object, but only a subset\n      of audio and image mimetypes are allowed.\n     */ sendRealtimeInput(params) {\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToVertex(params)\n            };\n        } else {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToMldev(params)\n            };\n        }\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a function response message over the established connection.\n  \n      @param params - Contains property `functionResponses`.\n  \n        - `functionResponses` will be converted to a `functionResponses[]`\n  \n      @remarks\n      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.\n  \n      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.\n  \n      @experimental\n     */ sendToolResponse(params) {\n        if (params.functionResponses == null) {\n            throw new Error(\"Tool response parameters are required.\");\n        }\n        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         }\n       });\n  \n       session.close();\n       ```\n     */ close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap(headers) {\n    const headerMap = {};\n    headers.forEach((value, key)=>{\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)){\n        headers.append(key, value);\n    }\n    return headers;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const DEFAULT_MAX_REMOTE_CALLS = 10;\n/** Returns whether automatic function calling is disabled. */ function shouldDisableAfc(config) {\n    var _a, _b, _c;\n    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {\n        return true;\n    }\n    let callableToolsPresent = false;\n    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []){\n        if (isCallableTool(tool)) {\n            callableToolsPresent = true;\n            break;\n        }\n    }\n    if (!callableToolsPresent) {\n        return true;\n    }\n    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;\n    if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {\n        console.warn(\"Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:\", maxCalls);\n        return true;\n    }\n    return false;\n}\nfunction isCallableTool(tool) {\n    return \"callTool\" in tool && typeof tool.callTool === \"function\";\n}\n// Checks whether the list of tools contains any CallableTools. Will return true\n// if there is at least one CallableTool.\nfunction hasCallableTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool)=>isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n// Checks whether the list of tools contains any non-callable tools. Will return\n// true if there is at least one non-Callable tool.\nfunction hasNonCallableTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool)=>!isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n/**\n * Returns whether to append automatic function calling history to the\n * response.\n */ function shouldAppendAfcHistory(config) {\n    var _a;\n    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Models extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Makes an API request to generate content with a given model.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         * 'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContent({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     candidateCount: 2,\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */ this.generateContent = async (params)=>{\n            var _a, _b, _c, _d, _e;\n            const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n            this.maybeMoveToResponseJsonSchem(params);\n            if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {\n                return await this.generateContentInternal(transformedParams);\n            }\n            if (hasNonCallableTools(params)) {\n                throw new Error(\"Automatic function calling with CallableTools and Tools is not yet supported.\");\n            }\n            let response;\n            let functionResponseContent;\n            const automaticFunctionCallingHistory = tContents(transformedParams.contents);\n            const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n            let remoteCalls = 0;\n            while(remoteCalls < maxRemoteCalls){\n                response = await this.generateContentInternal(transformedParams);\n                if (!response.functionCalls || response.functionCalls.length === 0) {\n                    break;\n                }\n                const responseContent = response.candidates[0].content;\n                const functionResponseParts = [];\n                for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []){\n                    if (isCallableTool(tool)) {\n                        const callableTool = tool;\n                        const parts = await callableTool.callTool(response.functionCalls);\n                        functionResponseParts.push(...parts);\n                    }\n                }\n                remoteCalls++;\n                functionResponseContent = {\n                    role: \"user\",\n                    parts: functionResponseParts\n                };\n                transformedParams.contents = tContents(transformedParams.contents);\n                transformedParams.contents.push(responseContent);\n                transformedParams.contents.push(functionResponseContent);\n                if (shouldAppendAfcHistory(transformedParams.config)) {\n                    automaticFunctionCallingHistory.push(responseContent);\n                    automaticFunctionCallingHistory.push(functionResponseContent);\n                }\n            }\n            if (shouldAppendAfcHistory(transformedParams.config)) {\n                response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;\n            }\n            return response;\n        };\n        /**\n         * Makes an API request to generate content with a given model and yields the\n         * response in chunks.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         *  'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content with streaming response.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContentStream({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     maxOutputTokens: 200,\n         *   }\n         * });\n         * for await (const chunk of response) {\n         *   console.log(chunk);\n         * }\n         * ```\n         */ this.generateContentStream = async (params)=>{\n            this.maybeMoveToResponseJsonSchem(params);\n            if (shouldDisableAfc(params.config)) {\n                const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n                return await this.generateContentStreamInternal(transformedParams);\n            } else {\n                return await this.processAfcStream(params);\n            }\n        };\n        /**\n         * Generates an image based on a text description and configuration.\n         *\n         * @param params - The parameters for generating images.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.generateImages({\n         *  model: 'imagen-3.0-generate-002',\n         *  prompt: 'Robot holding a red skateboard',\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.generateImages = async (params)=>{\n            return await this.generateImagesInternal(params).then((apiResponse)=>{\n                var _a;\n                let positivePromptSafetyAttributes;\n                const generatedImages = [];\n                if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {\n                    for (const generatedImage of apiResponse.generatedImages){\n                        if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === \"Positive Prompt\") {\n                            positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;\n                        } else {\n                            generatedImages.push(generatedImage);\n                        }\n                    }\n                }\n                let response;\n                if (positivePromptSafetyAttributes) {\n                    response = {\n                        generatedImages: generatedImages,\n                        positivePromptSafetyAttributes: positivePromptSafetyAttributes,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse\n                    };\n                } else {\n                    response = {\n                        generatedImages: generatedImages,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse\n                    };\n                }\n                return response;\n            });\n        };\n        this.list = async (params)=>{\n            var _a;\n            const defaultConfig = {\n                queryBase: true\n            };\n            const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);\n            const actualParams = {\n                config: actualConfig\n            };\n            if (this.apiClient.isVertexAI()) {\n                if (!actualParams.config.queryBase) {\n                    if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {\n                        throw new Error(\"Filtering tuned models list for Vertex AI is not currently supported\");\n                    } else {\n                        actualParams.config.filter = \"labels.tune-type:*\";\n                    }\n                }\n            }\n            return new Pager(PagedItem.PAGED_ITEM_MODELS, (x)=>this.listInternal(x), await this.listInternal(actualParams), actualParams);\n        };\n        /**\n         * Edits an image based on a prompt, list of reference images, and configuration.\n         *\n         * @param params - The parameters for editing an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.editImage({\n         *  model: 'imagen-3.0-capability-001',\n         *  prompt: 'Generate an image containing a mug with the product logo [1] visible on the side of the mug.',\n         *  referenceImages: [subjectReferenceImage]\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.editImage = async (params)=>{\n            const paramsInternal = {\n                model: params.model,\n                prompt: params.prompt,\n                referenceImages: [],\n                config: params.config\n            };\n            if (params.referenceImages) {\n                if (params.referenceImages) {\n                    paramsInternal.referenceImages = params.referenceImages.map((img)=>img.toReferenceImageAPI());\n                }\n            }\n            return await this.editImageInternal(paramsInternal);\n        };\n        /**\n         * Upscales an image based on an image, upscale factor, and configuration.\n         * Only supported in Vertex AI currently.\n         *\n         * @param params - The parameters for upscaling an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.upscaleImage({\n         *  model: 'imagen-3.0-generate-002',\n         *  image: image,\n         *  upscaleFactor: 'x2',\n         *  config: {\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.upscaleImage = async (params)=>{\n            let apiConfig = {\n                numberOfImages: 1,\n                mode: \"upscale\"\n            };\n            if (params.config) {\n                apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);\n            }\n            const apiParams = {\n                model: params.model,\n                image: params.image,\n                upscaleFactor: params.upscaleFactor,\n                config: apiConfig\n            };\n            return await this.upscaleImageInternal(apiParams);\n        };\n        /**\n         *  Generates videos based on a text description and configuration.\n         *\n         * @param params - The parameters for generating videos.\n         * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.\n         *\n         * @example\n         * ```ts\n         * const operation = await ai.models.generateVideos({\n         *  model: 'veo-2.0-generate-001',\n         *  source: {\n         *    prompt: 'A neon hologram of a cat driving at top speed',\n         *  },\n         *  config: {\n         *    numberOfVideos: 1\n         * });\n         *\n         * while (!operation.done) {\n         *   await new Promise(resolve => setTimeout(resolve, 10000));\n         *   operation = await ai.operations.getVideosOperation({operation: operation});\n         * }\n         *\n         * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);\n         * ```\n         */ this.generateVideos = async (params)=>{\n            if ((params.prompt || params.image || params.video) && params.source) {\n                throw new Error(\"Source and prompt/image/video are mutually exclusive. Please only use source.\");\n            }\n            return await this.generateVideosInternal(params);\n        };\n    }\n    /**\n     * This logic is needed for GenerateContentConfig only.\n     * Previously we made GenerateContentConfig.responseSchema field to accept\n     * unknown. Since v1.9.0, we switch to use backend JSON schema support.\n     * To maintain backward compatibility, we move the data that was treated as\n     * JSON schema from the responseSchema field to the responseJsonSchema field.\n     */ maybeMoveToResponseJsonSchem(params) {\n        if (params.config && params.config.responseSchema) {\n            if (!params.config.responseJsonSchema) {\n                if (Object.keys(params.config.responseSchema).includes(\"$schema\")) {\n                    params.config.responseJsonSchema = params.config.responseSchema;\n                    delete params.config.responseSchema;\n                }\n            }\n        }\n        return;\n    }\n    /**\n     * Transforms the CallableTools in the parameters to be simply Tools, it\n     * copies the params into a new object and replaces the tools, it does not\n     * modify the original params. Also sets the MCP usage header if there are\n     * MCP tools in the parameters.\n     */ async processParamsMaybeAddMcpUsage(params) {\n        var _a, _b, _c;\n        const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;\n        if (!tools) {\n            return params;\n        }\n        const transformedTools = await Promise.all(tools.map(async (tool)=>{\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                return await callableTool.tool();\n            }\n            return tool;\n        }));\n        const newParams = {\n            model: params.model,\n            contents: params.contents,\n            config: Object.assign(Object.assign({}, params.config), {\n                tools: transformedTools\n            })\n        };\n        newParams.config.tools = transformedTools;\n        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {\n            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};\n            let newHeaders = Object.assign({}, headers);\n            if (Object.keys(newHeaders).length === 0) {\n                newHeaders = this.apiClient.getDefaultHeaders();\n            }\n            setMcpUsageHeader(newHeaders);\n            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), {\n                headers: newHeaders\n            });\n        }\n        return newParams;\n    }\n    async initAfcToolsMap(params) {\n        var _a, _b, _c;\n        const afcTools = new Map();\n        for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []){\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                const toolDeclaration = await callableTool.tool();\n                for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []){\n                    if (!declaration.name) {\n                        throw new Error(\"Function declaration name is required.\");\n                    }\n                    if (afcTools.has(declaration.name)) {\n                        throw new Error(`Duplicate tool declaration name: ${declaration.name}`);\n                    }\n                    afcTools.set(declaration.name, callableTool);\n                }\n            }\n        }\n        return afcTools;\n    }\n    async processAfcStream(params) {\n        var _a, _b, _c;\n        const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n        let wereFunctionsCalled = false;\n        let remoteCallCount = 0;\n        const afcToolsMap = await this.initAfcToolsMap(params);\n        return function(models, afcTools, params) {\n            var _a, _b;\n            return __asyncGenerator(this, arguments, function*() {\n                var _c, e_1, _d, _e;\n                while(remoteCallCount < maxRemoteCalls){\n                    if (wereFunctionsCalled) {\n                        remoteCallCount++;\n                        wereFunctionsCalled = false;\n                    }\n                    const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params));\n                    const response = yield __await(models.generateContentStreamInternal(transformedParams));\n                    const functionResponses = [];\n                    const responseContents = [];\n                    try {\n                        for(var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c = response_1_1.done, !_c; _f = true){\n                            _e = response_1_1.value;\n                            _f = false;\n                            const chunk = _e;\n                            yield yield __await(chunk);\n                            if (chunk.candidates && ((_a = chunk.candidates[0]) === null || _a === void 0 ? void 0 : _a.content)) {\n                                responseContents.push(chunk.candidates[0].content);\n                                for (const part of (_b = chunk.candidates[0].content.parts) !== null && _b !== void 0 ? _b : []){\n                                    if (remoteCallCount < maxRemoteCalls && part.functionCall) {\n                                        if (!part.functionCall.name) {\n                                            throw new Error(\"Function call name was not returned by the model.\");\n                                        }\n                                        if (!afcTools.has(part.functionCall.name)) {\n                                            throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);\n                                        } else {\n                                            const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([\n                                                part.functionCall\n                                            ]));\n                                            functionResponses.push(...responseParts);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_c && (_d = response_1.return)) yield __await(_d.call(response_1));\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                    if (functionResponses.length > 0) {\n                        wereFunctionsCalled = true;\n                        const typedResponseChunk = new GenerateContentResponse();\n                        typedResponseChunk.candidates = [\n                            {\n                                content: {\n                                    role: \"user\",\n                                    parts: functionResponses\n                                }\n                            }\n                        ];\n                        yield yield __await(typedResponseChunk);\n                        const newContents = [];\n                        newContents.push(...responseContents);\n                        newContents.push({\n                            role: \"user\",\n                            parts: functionResponses\n                        });\n                        const updatedContents = tContents(params.contents).concat(newContents);\n                        params.contents = updatedContents;\n                    } else {\n                        break;\n                    }\n                }\n            });\n        }(this, afcToolsMap, params);\n    }\n    async generateContentInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromVertex(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromMldev(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async generateContentStreamInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_2, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a = apiResponse_1_1.done, !_a; _d = true){\n                            _c = apiResponse_1_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromVertex((yield __await(chunk.json())));\n                            resp[\"sdkHttpResponse\"] = {\n                                headers: chunk.headers\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_2_1) {\n                        e_2 = {\n                            error: e_2_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_1.return)) yield __await(_b.call(apiResponse_1));\n                        } finally{\n                            if (e_2) throw e_2.error;\n                        }\n                    }\n                });\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_3, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a = apiResponse_2_1.done, !_a; _d = true){\n                            _c = apiResponse_2_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromMldev((yield __await(chunk.json())));\n                            resp[\"sdkHttpResponse\"] = {\n                                headers: chunk.headers\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_3_1) {\n                        e_3 = {\n                            error: e_3_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_2.return)) yield __await(_b.call(apiResponse_2));\n                        } finally{\n                            if (e_3) throw e_3.error;\n                        }\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Calculates embeddings for the given contents. Only text is supported.\n     *\n     * @param params - The parameters for embedding contents.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.embedContent({\n     *  model: 'text-embedding-004',\n     *  contents: [\n     *    'What is your name?',\n     *    'What is your favorite color?',\n     *  ],\n     *  config: {\n     *    outputDimensionality: 64,\n     *  },\n     * });\n     * console.log(response);\n     * ```\n     */ async embedContent(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = embedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromVertex(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = embedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:batchEmbedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromMldev(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for generating images.\n     */ async generateImagesInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateImagesParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromVertex(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateImagesParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromMldev(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for editing an image.\n     */ async editImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = editImageParametersInternalToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = editImageResponseFromVertex(apiResponse);\n                const typedResp = new EditImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Private method for upscaling an image.\n     */ async upscaleImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = upscaleImageResponseFromVertex(apiResponse);\n                const typedResp = new UpscaleImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Recontextualizes an image.\n     *\n     * There are two types of recontextualization currently supported:\n     * 1) Imagen Product Recontext - Generate images of products in new scenes\n     *    and contexts.\n     * 2) Virtual Try-On: Generate images of persons modeling fashion products.\n     *\n     * @param params - The parameters for recontextualizing an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response1 = await ai.models.recontextImage({\n     *  model: 'imagen-product-recontext-preview-06-30',\n     *  source: {\n     *    prompt: 'In a modern kitchen setting.',\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);\n     *\n     * const response2 = await ai.models.recontextImage({\n     *  model: 'virtual-try-on-preview-08-04',\n     *  source: {\n     *    personImage: personImage,\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);\n     * ```\n     */ async recontextImage(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = recontextImageParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = recontextImageResponseFromVertex(apiResponse);\n                const typedResp = new RecontextImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Segments an image, creating a mask of a specified area.\n     *\n     * @param params - The parameters for segmenting an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.segmentImage({\n     *  model: 'image-segmentation-001',\n     *  source: {\n     *    image: image,\n     *  },\n     *  config: {\n     *    mode: 'foreground',\n     *  },\n     * });\n     * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);\n     * ```\n     */ async segmentImage(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = segmentImageParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = segmentImageResponseFromVertex(apiResponse);\n                const typedResp = new SegmentImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Fetches information about a model by name.\n     *\n     * @example\n     * ```ts\n     * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listModelsParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{models_url}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listModelsResponseFromVertex(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listModelsParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{models_url}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listModelsResponseFromMldev(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates a tuned model by its name.\n     *\n     * @param params - The parameters for updating the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.update({\n     *   model: 'tuned-model-name',\n     *   config: {\n     *     displayName: 'New display name',\n     *     description: 'New description',\n     *   },\n     * });\n     * ```\n     */ async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = updateModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a tuned model by its name.\n     *\n     * @param params - The parameters for deleting the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.delete({model: 'tuned-model-name'});\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteModelResponseFromVertex(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = deleteModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteModelResponseFromMldev(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Counts the number of tokens in the given contents. Multimodal input is\n     * supported for Gemini models.\n     *\n     * @param params - The parameters for counting tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.countTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'The quick brown fox jumps over the lazy dog.'\n     * });\n     * console.log(response);\n     * ```\n     */ async countTokens(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = countTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromVertex(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = countTokensParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromMldev(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Given a list of contents, returns a corresponding TokensInfo containing\n     * the list of tokens and list of token ids.\n     *\n     * This method is not supported by the Gemini Developer API.\n     *\n     * @param params - The parameters for computing tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.computeTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'What is your name?'\n     * });\n     * console.log(response);\n     * ```\n     */ async computeTokens(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = computeTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:computeTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = computeTokensResponseFromVertex(apiResponse);\n                const typedResp = new ComputeTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Private method for generating videos.\n     */ async generateVideosInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateVideosParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromVertex(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateVideosParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromMldev(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Operations extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */ async getVideosOperation(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === \"\") {\n            throw new Error(\"Operation name is required.\");\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split(\"/operations/\")[0];\n            let httpOptions = undefined;\n            if (config && \"httpOptions\" in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: {\n                    httpOptions: httpOptions\n                }\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: true\n            });\n        } else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: false\n            });\n        }\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */ async get(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === \"\") {\n            throw new Error(\"Operation name is required.\");\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split(\"/operations/\")[0];\n            let httpOptions = undefined;\n            if (config && \"httpOptions\" in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: {\n                    httpOptions: httpOptions\n                }\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: true\n            });\n        } else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: false\n            });\n        }\n    }\n    async getVideosOperationInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getOperationParametersToVertex(params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        } else {\n            const body = getOperationParametersToMldev(params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        }\n    }\n    async fetchPredictVideosOperationInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = fetchPredictOperationParametersToVertex(params);\n            path = formatMap(\"{resourceName}:fetchPredictOperation\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function audioTranscriptionConfigToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction authTokenFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction automaticActivityDetectionToMldev(fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, [\n        \"disabled\"\n    ]);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, [\n            \"disabled\"\n        ], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"startOfSpeechSensitivity\"\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"startOfSpeechSensitivity\"\n        ], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"endOfSpeechSensitivity\"\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"endOfSpeechSensitivity\"\n        ], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        \"prefixPaddingMs\"\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, [\n            \"prefixPaddingMs\"\n        ], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        \"silenceDurationMs\"\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, [\n            \"silenceDurationMs\"\n        ], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction blobToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction computerUseToMldev(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        \"excludedPredefinedFunctions\"\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, [\n            \"excludedPredefinedFunctions\"\n        ], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction contentToMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        \"triggerTokens\"\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, [\n            \"triggerTokens\"\n        ], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        \"slidingWindow\"\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, [\n            \"slidingWindow\"\n        ], slidingWindowToMldev(fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromNewSessionExpireTime = getValueByPath(fromObject, [\n        \"newSessionExpireTime\"\n    ]);\n    if (parentObject !== undefined && fromNewSessionExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"newSessionExpireTime\"\n        ], fromNewSessionExpireTime);\n    }\n    const fromUses = getValueByPath(fromObject, [\n        \"uses\"\n    ]);\n    if (parentObject !== undefined && fromUses != null) {\n        setValueByPath(parentObject, [\n            \"uses\"\n        ], fromUses);\n    }\n    const fromLiveConnectConstraints = getValueByPath(fromObject, [\n        \"liveConnectConstraints\"\n    ]);\n    if (parentObject !== undefined && fromLiveConnectConstraints != null) {\n        setValueByPath(parentObject, [\n            \"bidiGenerateContentSetup\"\n        ], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));\n    }\n    const fromLockAdditionalFields = getValueByPath(fromObject, [\n        \"lockAdditionalFields\"\n    ]);\n    if (parentObject !== undefined && fromLockAdditionalFields != null) {\n        setValueByPath(parentObject, [\n            \"fieldMask\"\n        ], fromLockAdditionalFields);\n    }\n    return toObject;\n}\nfunction createAuthTokenParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction fileDataToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchToMldev(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction intervalToMldev(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], speechConfigToMldev(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"thinkingConfig\"\n        ], thinkingConfigToMldev(fromThinkingConfig));\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToMldev(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToMldev(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], audioTranscriptionConfigToMldev());\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], audioTranscriptionConfigToMldev());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], realtimeInputConfigToMldev(fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], contextWindowCompressionConfigToMldev(fromContextWindowCompression));\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], proactivityConfigToMldev(fromProactivity));\n    }\n    return toObject;\n}\nfunction liveConnectConstraintsToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        \"speakerVoiceConfigs\"\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return speakerVoiceConfigToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"speakerVoiceConfigs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction proactivityConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromProactiveAudio = getValueByPath(fromObject, [\n        \"proactiveAudio\"\n    ]);\n    if (fromProactiveAudio != null) {\n        setValueByPath(toObject, [\n            \"proactiveAudio\"\n        ], fromProactiveAudio);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        \"automaticActivityDetection\"\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, [\n            \"automaticActivityDetection\"\n        ], automaticActivityDetectionToMldev(fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        \"activityHandling\"\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, [\n            \"activityHandling\"\n        ], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, [\n        \"turnCoverage\"\n    ]);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, [\n            \"turnCoverage\"\n        ], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    if (getValueByPath(fromObject, [\n        \"transparent\"\n    ]) !== undefined) {\n        throw new Error(\"transparent parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction slidingWindowToMldev(fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, [\n        \"targetTokens\"\n    ]);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, [\n            \"targetTokens\"\n        ], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, [\n        \"speaker\"\n    ]);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, [\n            \"speaker\"\n        ], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction speechConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"multiSpeakerVoiceConfig\"\n        ], multiSpeakerVoiceConfigToMldev(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction toolToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], computerUseToMldev(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction urlContextToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction videoMetadataToMldev(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToMldev(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Returns a comma-separated list of field masks from a given object.\n *\n * @param setup The object to extract field masks from.\n * @return A comma-separated list of field masks.\n */ function getFieldMasks(setup) {\n    const fields = [];\n    for(const key in setup){\n        if (Object.prototype.hasOwnProperty.call(setup, key)) {\n            const value = setup[key];\n            // 2nd layer, recursively get field masks see TODO(b/418290100)\n            if (typeof value === \"object\" && value != null && Object.keys(value).length > 0) {\n                const field = Object.keys(value).map((kk)=>`${key}.${kk}`);\n                fields.push(...field);\n            } else {\n                fields.push(key); // 1st layer\n            }\n        }\n    }\n    return fields.join(\",\");\n}\n/**\n * Converts bidiGenerateContentSetup.\n * @param requestDict - The request dictionary.\n * @param config - The configuration object.\n * @return - The modified request dictionary.\n */ function convertBidiSetupToTokenSetup(requestDict, config) {\n    // Convert bidiGenerateContentSetup from bidiGenerateContentSetup.setup.\n    let setupForMaskGeneration = null;\n    const bidiGenerateContentSetupValue = requestDict[\"bidiGenerateContentSetup\"];\n    if (typeof bidiGenerateContentSetupValue === \"object\" && bidiGenerateContentSetupValue !== null && \"setup\" in bidiGenerateContentSetupValue) {\n        // Now we know bidiGenerateContentSetupValue is an object and has a 'setup'\n        // property.\n        const innerSetup = bidiGenerateContentSetupValue.setup;\n        if (typeof innerSetup === \"object\" && innerSetup !== null) {\n            // Valid inner setup found.\n            requestDict[\"bidiGenerateContentSetup\"] = innerSetup;\n            setupForMaskGeneration = innerSetup;\n        } else {\n            // `bidiGenerateContentSetupValue.setup` is not a valid object; treat as\n            // if bidiGenerateContentSetup is invalid.\n            delete requestDict[\"bidiGenerateContentSetup\"];\n        }\n    } else if (bidiGenerateContentSetupValue !== undefined) {\n        // `bidiGenerateContentSetup` exists but not in the expected\n        // shape {setup: {...}}; treat as invalid.\n        delete requestDict[\"bidiGenerateContentSetup\"];\n    }\n    const preExistingFieldMask = requestDict[\"fieldMask\"];\n    // Handle mask generation setup.\n    if (setupForMaskGeneration) {\n        const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);\n        if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {\n            // Case 1: lockAdditionalFields is an empty array. Lock only fields from\n            // bidi setup.\n            if (generatedMaskFromBidi) {\n                // Only assign if mask is not empty\n                requestDict[\"fieldMask\"] = generatedMaskFromBidi;\n            } else {\n                delete requestDict[\"fieldMask\"]; // If mask is empty, effectively no\n            // specific fields locked by bidi\n            }\n        } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {\n            // Case 2: Lock fields from bidi setup + additional fields\n            // (preExistingFieldMask).\n            const generationConfigFields = [\n                \"temperature\",\n                \"topK\",\n                \"topP\",\n                \"maxOutputTokens\",\n                \"responseModalities\",\n                \"seed\",\n                \"speechConfig\"\n            ];\n            let mappedFieldsFromPreExisting = [];\n            if (preExistingFieldMask.length > 0) {\n                mappedFieldsFromPreExisting = preExistingFieldMask.map((field)=>{\n                    if (generationConfigFields.includes(field)) {\n                        return `generationConfig.${field}`;\n                    }\n                    return field; // Keep original field name if not in\n                // generationConfigFields\n                });\n            }\n            const finalMaskParts = [];\n            if (generatedMaskFromBidi) {\n                finalMaskParts.push(generatedMaskFromBidi);\n            }\n            if (mappedFieldsFromPreExisting.length > 0) {\n                finalMaskParts.push(...mappedFieldsFromPreExisting);\n            }\n            if (finalMaskParts.length > 0) {\n                requestDict[\"fieldMask\"] = finalMaskParts.join(\",\");\n            } else {\n                // If no fields from bidi and no valid additional fields from\n                // pre-existing mask.\n                delete requestDict[\"fieldMask\"];\n            }\n        } else {\n            // Case 3: \"Lock all fields\" (meaning, don't send a field_mask, let server\n            // defaults apply or all are mutable). This is hit if:\n            //  - `config.lockAdditionalFields` is undefined.\n            //  - `config.lockAdditionalFields` is non-empty, BUT\n            //  `preExistingFieldMask` is null, not a string, or an empty string.\n            delete requestDict[\"fieldMask\"];\n        }\n    } else {\n        // No valid `bidiGenerateContentSetup` was found or extracted.\n        // \"Lock additional null fields if any\".\n        if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {\n            // If there's a pre-existing field mask, it's a string, and it's not\n            // empty, then we should lock all fields.\n            requestDict[\"fieldMask\"] = preExistingFieldMask.join(\",\");\n        } else {\n            delete requestDict[\"fieldMask\"];\n        }\n    }\n    return requestDict;\n}\nclass Tokens extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates an ephemeral auth token resource.\n     *\n     * @experimental\n     *\n     * @remarks\n     * Ephemeral auth tokens is only supported in the Gemini Developer API.\n     * It can be used for the session connection to the Live constrained API.\n     * Support in v1alpha only.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created auth token.\n     *\n     * @example\n     * ```ts\n     * const ai = new GoogleGenAI({\n     *     apiKey: token.name,\n     *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.\n     * });\n     *\n     * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig\n     * // when using the token in Live API sessions. Each session connection can\n     * // use a different configuration.\n     * const config: CreateAuthTokenConfig = {\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 2: If LiveEphemeralParameters is set, lock all fields in\n     * // LiveConnectConfig when using the token in Live API sessions. For\n     * // example, changing `outputAudioTranscription` in the Live API\n     * // connection will be ignored by the API.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     }\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // set, lock LiveConnectConfig with set and additional fields (e.g.\n     * // responseModalities, systemInstruction, temperature in this example) when\n     * // using the token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: ['temperature'],\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // empty array, lock LiveConnectConfig with set fields (e.g.\n     * // responseModalities, systemInstruction in this example) when using the\n     * // token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: [],\n     * }\n     * const token = await ai.tokens.create(config);\n     * ```\n     */ async create(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"The client.tokens.create method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createAuthTokenParametersToMldev(this.apiClient, params);\n            path = formatMap(\"auth_tokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const transformedBody = convertBidiSetupToTokenSetup(body, params.config);\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(transformedBody),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = authTokenFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const GOOGLE_API_KEY_HEADER = \"x-goog-api-key\";\nconst REQUIRED_VERTEX_AI_SCOPE = \"https://www.googleapis.com/auth/cloud-platform\";\nclass NodeAuth {\n    constructor(opts){\n        if (opts.apiKey !== undefined) {\n            this.apiKey = opts.apiKey;\n            return;\n        }\n        const vertexAuthOptions = buildGoogleAuthOptions(opts.googleAuthOptions);\n        this.googleAuth = new google_auth_library__WEBPACK_IMPORTED_MODULE_0__.GoogleAuth(vertexAuthOptions);\n    }\n    async addAuthHeaders(headers) {\n        if (this.apiKey !== undefined) {\n            if (this.apiKey.startsWith(\"auth_tokens/\")) {\n                throw new Error(\"Ephemeral tokens are only supported by the live API.\");\n            }\n            this.addKeyHeader(headers);\n            return;\n        }\n        return this.addGoogleAuthHeaders(headers);\n    }\n    addKeyHeader(headers) {\n        if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {\n            return;\n        }\n        if (this.apiKey === undefined) {\n            // This should never happen, this method is only called\n            // when apiKey is set.\n            throw new Error(\"Trying to set API key header but apiKey is not set\");\n        }\n        headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);\n    }\n    async addGoogleAuthHeaders(headers) {\n        if (this.googleAuth === undefined) {\n            // This should never happen, addGoogleAuthHeaders should only be\n            // called when there is no apiKey set and in these cases googleAuth\n            // is set.\n            throw new Error(\"Trying to set google-auth headers but googleAuth is unset\");\n        }\n        const authHeaders = await this.googleAuth.getRequestHeaders();\n        for(const key in authHeaders){\n            if (headers.get(key) !== null) {\n                continue;\n            }\n            headers.append(key, authHeaders[key]);\n        }\n    }\n}\nfunction buildGoogleAuthOptions(googleAuthOptions) {\n    let authOptions;\n    if (!googleAuthOptions) {\n        authOptions = {\n            scopes: [\n                REQUIRED_VERTEX_AI_SCOPE\n            ]\n        };\n        return authOptions;\n    } else {\n        authOptions = googleAuthOptions;\n        if (!authOptions.scopes) {\n            authOptions.scopes = [\n                REQUIRED_VERTEX_AI_SCOPE\n            ];\n            return authOptions;\n        } else if (typeof authOptions.scopes === \"string\" && authOptions.scopes !== REQUIRED_VERTEX_AI_SCOPE || Array.isArray(authOptions.scopes) && authOptions.scopes.indexOf(REQUIRED_VERTEX_AI_SCOPE) < 0) {\n            throw new Error(`Invalid auth scopes. Scopes must include: ${REQUIRED_VERTEX_AI_SCOPE}`);\n        }\n        return authOptions;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeDownloader {\n    async download(params, apiClient) {\n        if (params.downloadPath) {\n            const response = await downloadFile(params, apiClient);\n            if (response instanceof HttpResponse) {\n                const writer = (0,fs__WEBPACK_IMPORTED_MODULE_1__.createWriteStream)(params.downloadPath);\n                node_stream__WEBPACK_IMPORTED_MODULE_2__.Readable.fromWeb(response.responseInternal.body).pipe(writer);\n            } else {\n                (0,fs__WEBPACK_IMPORTED_MODULE_1__.writeFile)(params.downloadPath, response, {\n                    encoding: \"base64\"\n                }, (error)=>{\n                    if (error) {\n                        throw new Error(`Failed to write file to ${params.downloadPath}: ${error}`);\n                    }\n                });\n            }\n        }\n    }\n}\nasync function downloadFile(params, apiClient) {\n    var _a, _b, _c;\n    const name = tFileName(params.file);\n    if (name !== undefined) {\n        return await apiClient.request({\n            path: `files/${name}:download`,\n            httpMethod: \"GET\",\n            queryParams: {\n                \"alt\": \"media\"\n            },\n            httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n        });\n    } else if (isGeneratedVideo(params.file)) {\n        const videoBytes = (_c = params.file.video) === null || _c === void 0 ? void 0 : _c.videoBytes;\n        if (typeof videoBytes === \"string\") {\n            return videoBytes;\n        } else {\n            throw new Error(\"Failed to download generated video, Uri or videoBytes not found.\");\n        }\n    } else if (isVideo(params.file)) {\n        const videoBytes = params.file.videoBytes;\n        if (typeof videoBytes === \"string\") {\n            return videoBytes;\n        } else {\n            throw new Error(\"Failed to download video, Uri or videoBytes not found.\");\n        }\n    } else {\n        throw new Error(\"Unsupported file type\");\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeWebSocketFactory {\n    create(url, headers, callbacks) {\n        return new NodeWebSocket(url, headers, callbacks);\n    }\n}\nclass NodeWebSocket {\n    constructor(url, headers, callbacks){\n        this.url = url;\n        this.headers = headers;\n        this.callbacks = callbacks;\n    }\n    connect() {\n        this.ws = new ws__WEBPACK_IMPORTED_MODULE_3__.WebSocket(this.url, {\n            headers: this.headers\n        });\n        this.ws.onopen = this.callbacks.onopen;\n        this.ws.onerror = this.callbacks.onerror;\n        this.ws.onclose = this.callbacks.onclose;\n        this.ws.onmessage = this.callbacks.onmessage;\n    }\n    send(message) {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.send(message);\n    }\n    close() {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.close();\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction cancelTuningJobParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction cancelTuningJobParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"validationDataset\"\n    ]) !== undefined) {\n        throw new Error(\"validationDataset parameter is not supported in Gemini API.\");\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromTunedModelDisplayName);\n    }\n    if (getValueByPath(fromObject, [\n        \"description\"\n    ]) !== undefined) {\n        throw new Error(\"description parameter is not supported in Gemini API.\");\n    }\n    const fromEpochCount = getValueByPath(fromObject, [\n        \"epochCount\"\n    ]);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"epochCount\"\n        ], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        \"learningRateMultiplier\"\n    ]);\n    if (fromLearningRateMultiplier != null) {\n        setValueByPath(toObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"learningRateMultiplier\"\n        ], fromLearningRateMultiplier);\n    }\n    if (getValueByPath(fromObject, [\n        \"exportLastCheckpointOnly\"\n    ]) !== undefined) {\n        throw new Error(\"exportLastCheckpointOnly parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"preTunedModelCheckpointId\"\n    ]) !== undefined) {\n        throw new Error(\"preTunedModelCheckpointId parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"adapterSize\"\n    ]) !== undefined) {\n        throw new Error(\"adapterSize parameter is not supported in Gemini API.\");\n    }\n    const fromBatchSize = getValueByPath(fromObject, [\n        \"batchSize\"\n    ]);\n    if (parentObject !== undefined && fromBatchSize != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"batchSize\"\n        ], fromBatchSize);\n    }\n    const fromLearningRate = getValueByPath(fromObject, [\n        \"learningRate\"\n    ]);\n    if (parentObject !== undefined && fromLearningRate != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"learningRate\"\n        ], fromLearningRate);\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromValidationDataset = getValueByPath(fromObject, [\n        \"validationDataset\"\n    ]);\n    if (parentObject !== undefined && fromValidationDataset != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\"\n        ], tuningValidationDatasetToVertex(fromValidationDataset, toObject));\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEpochCount = getValueByPath(fromObject, [\n        \"epochCount\"\n    ]);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"hyperParameters\",\n            \"epochCount\"\n        ], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        \"learningRateMultiplier\"\n    ]);\n    if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"hyperParameters\",\n            \"learningRateMultiplier\"\n        ], fromLearningRateMultiplier);\n    }\n    const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n        \"exportLastCheckpointOnly\"\n    ]);\n    if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"exportLastCheckpointOnly\"\n        ], fromExportLastCheckpointOnly);\n    }\n    const fromAdapterSize = getValueByPath(fromObject, [\n        \"adapterSize\"\n    ]);\n    if (parentObject !== undefined && fromAdapterSize != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"hyperParameters\",\n            \"adapterSize\"\n        ], fromAdapterSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"batchSize\"\n    ]) !== undefined) {\n        throw new Error(\"batchSize parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"learningRate\"\n    ]) !== undefined) {\n        throw new Error(\"learningRate parameter is not supported in Vertex AI.\");\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToMldev(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        \"trainingDataset\"\n    ]);\n    if (fromTrainingDataset != null) {\n        setValueByPath(toObject, [\n            \"tuningTask\",\n            \"trainingData\"\n        ], tuningDatasetToMldev(fromTrainingDataset));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createTuningJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToVertex(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        \"trainingDataset\"\n    ]);\n    if (fromTrainingDataset != null) {\n        setValueByPath(toObject, [\n            \"supervisedTuningSpec\",\n            \"trainingDatasetUri\"\n        ], tuningDatasetToVertex(fromTrainingDataset, toObject));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createTuningJobConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listTuningJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listTuningJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, [\n        \"tunedModels\"\n    ]);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"tuningJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, [\n        \"tuningJobs\"\n    ]);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"tuningJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction tunedModelCheckpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromCheckpointId = getValueByPath(fromObject, [\n        \"checkpointId\"\n    ]);\n    if (fromCheckpointId != null) {\n        setValueByPath(toObject, [\n            \"checkpointId\"\n        ], fromCheckpointId);\n    }\n    const fromEpoch = getValueByPath(fromObject, [\n        \"epoch\"\n    ]);\n    if (fromEpoch != null) {\n        setValueByPath(toObject, [\n            \"epoch\"\n        ], fromEpoch);\n    }\n    const fromStep = getValueByPath(fromObject, [\n        \"step\"\n    ]);\n    if (fromStep != null) {\n        setValueByPath(toObject, [\n            \"step\"\n        ], fromStep);\n    }\n    const fromEndpoint = getValueByPath(fromObject, [\n        \"endpoint\"\n    ]);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, [\n            \"endpoint\"\n        ], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tunedModelFromMldev(fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, [\n            \"endpoint\"\n        ], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tunedModelFromVertex(fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, [\n        \"endpoint\"\n    ]);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, [\n            \"endpoint\"\n        ], fromEndpoint);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, [\n        \"checkpoints\"\n    ]);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tunedModelCheckpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"checkpoints\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction tuningDatasetToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"vertexDatasetResource\"\n    ]) !== undefined) {\n        throw new Error(\"vertexDatasetResource parameter is not supported in Gemini API.\");\n    }\n    const fromExamples = getValueByPath(fromObject, [\n        \"examples\"\n    ]);\n    if (fromExamples != null) {\n        let transformedList = fromExamples;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningExampleToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"examples\",\n            \"examples\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction tuningDatasetToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (parentObject !== undefined && fromGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"trainingDatasetUri\"\n        ], fromGcsUri);\n    }\n    const fromVertexDatasetResource = getValueByPath(fromObject, [\n        \"vertexDatasetResource\"\n    ]);\n    if (parentObject !== undefined && fromVertexDatasetResource != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"trainingDatasetUri\"\n        ], fromVertexDatasetResource);\n    }\n    if (getValueByPath(fromObject, [\n        \"examples\"\n    ]) !== undefined) {\n        throw new Error(\"examples parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction tuningExampleToMldev(fromObject) {\n    const toObject = {};\n    const fromTextInput = getValueByPath(fromObject, [\n        \"textInput\"\n    ]);\n    if (fromTextInput != null) {\n        setValueByPath(toObject, [\n            \"textInput\"\n        ], fromTextInput);\n    }\n    const fromOutput = getValueByPath(fromObject, [\n        \"output\"\n    ]);\n    if (fromOutput != null) {\n        setValueByPath(toObject, [\n            \"output\"\n        ], fromOutput);\n    }\n    return toObject;\n}\nfunction tuningJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"tuningTask\",\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"tuningTask\",\n        \"completeTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, [\n            \"tunedModel\"\n        ], tunedModelFromMldev(fromTunedModel));\n    }\n    const fromCustomBaseModel = getValueByPath(fromObject, [\n        \"customBaseModel\"\n    ]);\n    if (fromCustomBaseModel != null) {\n        setValueByPath(toObject, [\n            \"customBaseModel\"\n        ], fromCustomBaseModel);\n    }\n    const fromExperiment = getValueByPath(fromObject, [\n        \"experiment\"\n    ]);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, [\n            \"experiment\"\n        ], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromOutputUri = getValueByPath(fromObject, [\n        \"outputUri\"\n    ]);\n    if (fromOutputUri != null) {\n        setValueByPath(toObject, [\n            \"outputUri\"\n        ], fromOutputUri);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, [\n        \"pipelineJob\"\n    ]);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, [\n            \"pipelineJob\"\n        ], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        \"serviceAccount\"\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, [\n            \"serviceAccount\"\n        ], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    const fromVeoTuningSpec = getValueByPath(fromObject, [\n        \"veoTuningSpec\"\n    ]);\n    if (fromVeoTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"veoTuningSpec\"\n        ], fromVeoTuningSpec);\n    }\n    return toObject;\n}\nfunction tuningJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, [\n        \"tunedModel\"\n    ]);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, [\n            \"tunedModel\"\n        ], tunedModelFromVertex(fromTunedModel));\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromSupervisedTuningSpec = getValueByPath(fromObject, [\n        \"supervisedTuningSpec\"\n    ]);\n    if (fromSupervisedTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"supervisedTuningSpec\"\n        ], fromSupervisedTuningSpec);\n    }\n    const fromTuningDataStats = getValueByPath(fromObject, [\n        \"tuningDataStats\"\n    ]);\n    if (fromTuningDataStats != null) {\n        setValueByPath(toObject, [\n            \"tuningDataStats\"\n        ], fromTuningDataStats);\n    }\n    const fromEncryptionSpec = getValueByPath(fromObject, [\n        \"encryptionSpec\"\n    ]);\n    if (fromEncryptionSpec != null) {\n        setValueByPath(toObject, [\n            \"encryptionSpec\"\n        ], fromEncryptionSpec);\n    }\n    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [\n        \"partnerModelTuningSpec\"\n    ]);\n    if (fromPartnerModelTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"partnerModelTuningSpec\"\n        ], fromPartnerModelTuningSpec);\n    }\n    const fromCustomBaseModel = getValueByPath(fromObject, [\n        \"customBaseModel\"\n    ]);\n    if (fromCustomBaseModel != null) {\n        setValueByPath(toObject, [\n            \"customBaseModel\"\n        ], fromCustomBaseModel);\n    }\n    const fromExperiment = getValueByPath(fromObject, [\n        \"experiment\"\n    ]);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, [\n            \"experiment\"\n        ], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromOutputUri = getValueByPath(fromObject, [\n        \"outputUri\"\n    ]);\n    if (fromOutputUri != null) {\n        setValueByPath(toObject, [\n            \"outputUri\"\n        ], fromOutputUri);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, [\n        \"pipelineJob\"\n    ]);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, [\n            \"pipelineJob\"\n        ], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        \"serviceAccount\"\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, [\n            \"serviceAccount\"\n        ], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    const fromVeoTuningSpec = getValueByPath(fromObject, [\n        \"veoTuningSpec\"\n    ]);\n    if (fromVeoTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"veoTuningSpec\"\n        ], fromVeoTuningSpec);\n    }\n    return toObject;\n}\nfunction tuningOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction tuningValidationDatasetToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"validationDatasetUri\"\n        ], fromGcsUri);\n    }\n    const fromVertexDatasetResource = getValueByPath(fromObject, [\n        \"vertexDatasetResource\"\n    ]);\n    if (parentObject !== undefined && fromVertexDatasetResource != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"trainingDatasetUri\"\n        ], fromVertexDatasetResource);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Tunings extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Gets a TuningJob.\n         *\n         * @param name - The resource name of the tuning job.\n         * @return - A TuningJob object.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.get = async (params)=>{\n            return await this.getInternal(params);\n        };\n        /**\n         * Lists tuning jobs.\n         *\n         * @param config - The configuration for the list request.\n         * @return - A list of tuning jobs.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n        /**\n         * Creates a supervised fine-tuning job.\n         *\n         * @param params - The parameters for the tuning job.\n         * @return - A TuningJob operation.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.tune = async (params)=>{\n            var _a;\n            if (this.apiClient.isVertexAI()) {\n                if (params.baseModel.startsWith(\"projects/\")) {\n                    const preTunedModel = {\n                        tunedModelName: params.baseModel\n                    };\n                    if ((_a = params.config) === null || _a === void 0 ? void 0 : _a.preTunedModelCheckpointId) {\n                        preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;\n                    }\n                    const paramsPrivate = Object.assign(Object.assign({}, params), {\n                        preTunedModel: preTunedModel\n                    });\n                    paramsPrivate.baseModel = undefined;\n                    return await this.tuneInternal(paramsPrivate);\n                } else {\n                    const paramsPrivate = Object.assign({}, params);\n                    return await this.tuneInternal(paramsPrivate);\n                }\n            } else {\n                const paramsPrivate = Object.assign({}, params);\n                const operation = await this.tuneMldevInternal(paramsPrivate);\n                let tunedModelName = \"\";\n                if (operation[\"metadata\"] !== undefined && operation[\"metadata\"][\"tunedModel\"] !== undefined) {\n                    tunedModelName = operation[\"metadata\"][\"tunedModel\"];\n                } else if (operation[\"name\"] !== undefined && operation[\"name\"].includes(\"/operations/\")) {\n                    tunedModelName = operation[\"name\"].split(\"/operations/\")[0];\n                }\n                const tuningJob = {\n                    name: tunedModelName,\n                    state: JobState.JOB_STATE_QUEUED\n                };\n                return tuningJob;\n            }\n        };\n    }\n    async getInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getTuningJobParametersToVertex(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getTuningJobParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listTuningJobsParametersToVertex(params);\n            path = formatMap(\"tuningJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listTuningJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listTuningJobsParametersToMldev(params);\n            path = formatMap(\"tunedModels\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listTuningJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Cancels a tuning job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelTuningJobParametersToVertex(params);\n            path = formatMap(\"{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n        } else {\n            const body = cancelTuningJobParametersToMldev(params);\n            path = formatMap(\"{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n        }\n    }\n    async tuneInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createTuningJobParametersPrivateToVertex(params);\n            path = formatMap(\"tuningJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    async tuneMldevInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createTuningJobParametersPrivateToMldev(params);\n            path = formatMap(\"tunedModels\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningOperationFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 8; // bytes\nconst MAX_RETRY_COUNT = 3;\nconst INITIAL_RETRY_DELAY_MS = 1000;\nconst DELAY_MULTIPLIER = 2;\nconst X_GOOG_UPLOAD_STATUS_HEADER_FIELD = \"x-goog-upload-status\";\nasync function uploadBlob(file, uploadUrl, apiClient) {\n    var _a, _b, _c;\n    let fileSize = 0;\n    let offset = 0;\n    let response = new HttpResponse(new Response());\n    let uploadCommand = \"upload\";\n    fileSize = file.size;\n    while(offset < fileSize){\n        const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n        const chunk = file.slice(offset, offset + chunkSize);\n        if (offset + chunkSize >= fileSize) {\n            uploadCommand += \", finalize\";\n        }\n        let retryCount = 0;\n        let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n        while(retryCount < MAX_RETRY_COUNT){\n            response = await apiClient.request({\n                path: \"\",\n                body: chunk,\n                httpMethod: \"POST\",\n                httpOptions: {\n                    apiVersion: \"\",\n                    baseUrl: uploadUrl,\n                    headers: {\n                        \"X-Goog-Upload-Command\": uploadCommand,\n                        \"X-Goog-Upload-Offset\": String(offset),\n                        \"Content-Length\": String(chunkSize)\n                    }\n                }\n            });\n            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                break;\n            }\n            retryCount++;\n            await sleep(currentDelayMs);\n            currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n        }\n        offset += chunkSize;\n        // The `x-goog-upload-status` header field can be `active`, `final` and\n        //`cancelled` in resposne.\n        if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"active\") {\n            break;\n        }\n        // TODO(b/401391430) Investigate why the upload status is not finalized\n        // even though all content has been uploaded.\n        if (fileSize <= offset) {\n            throw new Error(\"All content has been uploaded, but the upload status is not finalized.\");\n        }\n    }\n    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n    if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n        throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n    }\n    return responseJson[\"file\"];\n}\nasync function getBlobStat(file) {\n    const fileStat = {\n        size: file.size,\n        type: file.type\n    };\n    return fileStat;\n}\nfunction sleep(ms) {\n    return new Promise((resolvePromise)=>setTimeout(resolvePromise, ms));\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeUploader {\n    async stat(file) {\n        const fileStat = {\n            size: 0,\n            type: undefined\n        };\n        if (typeof file === \"string\") {\n            const originalStat = await fs_promises__WEBPACK_IMPORTED_MODULE_4__.stat(file);\n            fileStat.size = originalStat.size;\n            fileStat.type = this.inferMimeType(file);\n            return fileStat;\n        } else {\n            return await getBlobStat(file);\n        }\n    }\n    async upload(file, uploadUrl, apiClient) {\n        if (typeof file === \"string\") {\n            return await this.uploadFileFromPath(file, uploadUrl, apiClient);\n        } else {\n            return uploadBlob(file, uploadUrl, apiClient);\n        }\n    }\n    /**\n     * Infers the MIME type of a file based on its extension.\n     *\n     * @param filePath The path to the file.\n     * @returns The MIME type of the file, or undefined if it cannot be inferred.\n     */ inferMimeType(filePath) {\n        // Get the file extension.\n        const fileExtension = filePath.slice(filePath.lastIndexOf(\".\") + 1);\n        // Create a map of file extensions to MIME types.\n        const mimeTypes = {\n            \"aac\": \"audio/aac\",\n            \"abw\": \"application/x-abiword\",\n            \"arc\": \"application/x-freearc\",\n            \"avi\": \"video/x-msvideo\",\n            \"azw\": \"application/vnd.amazon.ebook\",\n            \"bin\": \"application/octet-stream\",\n            \"bmp\": \"image/bmp\",\n            \"bz\": \"application/x-bzip\",\n            \"bz2\": \"application/x-bzip2\",\n            \"csh\": \"application/x-csh\",\n            \"css\": \"text/css\",\n            \"csv\": \"text/csv\",\n            \"doc\": \"application/msword\",\n            \"docx\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n            \"eot\": \"application/vnd.ms-fontobject\",\n            \"epub\": \"application/epub+zip\",\n            \"gz\": \"application/gzip\",\n            \"gif\": \"image/gif\",\n            \"htm\": \"text/html\",\n            \"html\": \"text/html\",\n            \"ico\": \"image/vnd.microsoft.icon\",\n            \"ics\": \"text/calendar\",\n            \"jar\": \"application/java-archive\",\n            \"jpeg\": \"image/jpeg\",\n            \"jpg\": \"image/jpeg\",\n            \"js\": \"text/javascript\",\n            \"json\": \"application/json\",\n            \"jsonld\": \"application/ld+json\",\n            \"kml\": \"application/vnd.google-earth.kml+xml\",\n            \"kmz\": \"application/vnd.google-earth.kmz+xml\",\n            \"mjs\": \"text/javascript\",\n            \"mp3\": \"audio/mpeg\",\n            \"mp4\": \"video/mp4\",\n            \"mpeg\": \"video/mpeg\",\n            \"mpkg\": \"application/vnd.apple.installer+xml\",\n            \"odt\": \"application/vnd.oasis.opendocument.text\",\n            \"oga\": \"audio/ogg\",\n            \"ogv\": \"video/ogg\",\n            \"ogx\": \"application/ogg\",\n            \"opus\": \"audio/opus\",\n            \"otf\": \"font/otf\",\n            \"png\": \"image/png\",\n            \"pdf\": \"application/pdf\",\n            \"php\": \"application/x-httpd-php\",\n            \"ppt\": \"application/vnd.ms-powerpoint\",\n            \"pptx\": \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n            \"rar\": \"application/vnd.rar\",\n            \"rtf\": \"application/rtf\",\n            \"sh\": \"application/x-sh\",\n            \"svg\": \"image/svg+xml\",\n            \"swf\": \"application/x-shockwave-flash\",\n            \"tar\": \"application/x-tar\",\n            \"tif\": \"image/tiff\",\n            \"tiff\": \"image/tiff\",\n            \"ts\": \"video/mp2t\",\n            \"ttf\": \"font/ttf\",\n            \"txt\": \"text/plain\",\n            \"vsd\": \"application/vnd.visio\",\n            \"wav\": \"audio/wav\",\n            \"weba\": \"audio/webm\",\n            \"webm\": \"video/webm\",\n            \"webp\": \"image/webp\",\n            \"woff\": \"font/woff\",\n            \"woff2\": \"font/woff2\",\n            \"xhtml\": \"application/xhtml+xml\",\n            \"xls\": \"application/vnd.ms-excel\",\n            \"xlsx\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n            \"xml\": \"application/xml\",\n            \"xul\": \"application/vnd.mozilla.xul+xml\",\n            \"zip\": \"application/zip\",\n            \"3gp\": \"video/3gpp\",\n            \"3g2\": \"video/3gpp2\",\n            \"7z\": \"application/x-7z-compressed\"\n        };\n        // Look up the MIME type based on the file extension.\n        const mimeType = mimeTypes[fileExtension.toLowerCase()];\n        // Return the MIME type.\n        return mimeType;\n    }\n    async uploadFileFromPath(file, uploadUrl, apiClient) {\n        var _a, _b, _c;\n        let fileSize = 0;\n        let offset = 0;\n        let response = new HttpResponse(new Response());\n        let uploadCommand = \"upload\";\n        let fileHandle;\n        try {\n            fileHandle = await fs_promises__WEBPACK_IMPORTED_MODULE_4__.open(file, \"r\");\n            if (!fileHandle) {\n                throw new Error(`Failed to open file`);\n            }\n            fileSize = (await fileHandle.stat()).size;\n            while(offset < fileSize){\n                const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n                if (offset + chunkSize >= fileSize) {\n                    uploadCommand += \", finalize\";\n                }\n                const buffer = new Uint8Array(chunkSize);\n                const { bytesRead: bytesRead } = await fileHandle.read(buffer, 0, chunkSize, offset);\n                if (bytesRead !== chunkSize) {\n                    throw new Error(`Failed to read ${chunkSize} bytes from file at offset ${offset}. bytes actually read: ${bytesRead}`);\n                }\n                const chunk = new Blob([\n                    buffer\n                ]);\n                let retryCount = 0;\n                let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n                while(retryCount < MAX_RETRY_COUNT){\n                    response = await apiClient.request({\n                        path: \"\",\n                        body: chunk,\n                        httpMethod: \"POST\",\n                        httpOptions: {\n                            apiVersion: \"\",\n                            baseUrl: uploadUrl,\n                            headers: {\n                                \"X-Goog-Upload-Command\": uploadCommand,\n                                \"X-Goog-Upload-Offset\": String(offset),\n                                \"Content-Length\": String(bytesRead)\n                            }\n                        }\n                    });\n                    if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                        break;\n                    }\n                    retryCount++;\n                    await sleep(currentDelayMs);\n                    currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n                }\n                offset += bytesRead;\n                // The `x-goog-upload-status` header field can be `active`, `final` and\n                //`cancelled` in resposne.\n                if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"active\") {\n                    break;\n                }\n                if (fileSize <= offset) {\n                    throw new Error(\"All content has been uploaded, but the upload status is not finalized.\");\n                }\n            }\n            const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n            if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n                throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n            }\n            return responseJson[\"file\"];\n        } finally{\n            // Ensure the file handle is always closed\n            if (fileHandle) {\n                await fileHandle.close();\n            }\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const LANGUAGE_LABEL_PREFIX = \"gl-node/\";\n/**\n * The Google GenAI SDK.\n *\n * @remarks\n * Provides access to the GenAI features through either the {@link\n * https://cloud.google.com/vertex-ai/docs/reference/rest | Gemini API} or\n * the {@link https://cloud.google.com/vertex-ai/docs/reference/rest | Vertex AI\n * API}.\n *\n * The {@link GoogleGenAIOptions.vertexai} value determines which of the API\n * services to use.\n *\n * When using the Gemini API, a {@link GoogleGenAIOptions.apiKey} must also be\n * set. When using Vertex AI, both {@link GoogleGenAIOptions.project} and {@link\n * GoogleGenAIOptions.location} must be set, or a {@link\n * GoogleGenAIOptions.apiKey} must be set when using Express Mode.\n *\n * Explicitly passed in values in {@link GoogleGenAIOptions} will always take\n * precedence over environment variables. If both project/location and api_key\n * exist in the environment variables, the project/location will be used.\n *\n * @example\n * Initializing the SDK for using the Gemini API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n *\n * @example\n * Initializing the SDK for using the Vertex AI API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({\n *   vertexai: true,\n *   project: 'PROJECT_ID',\n *   location: 'PROJECT_LOCATION'\n * });\n * ```\n *\n */ class GoogleGenAI {\n    constructor(options){\n        var _a, _b, _c, _d, _e, _f;\n        // Validate explicitly set initializer values.\n        if ((options.project || options.location) && options.apiKey) {\n            throw new Error(\"Project/location and API key are mutually exclusive in the client initializer.\");\n        }\n        this.vertexai = (_b = (_a = options.vertexai) !== null && _a !== void 0 ? _a : getBooleanEnv(\"GOOGLE_GENAI_USE_VERTEXAI\")) !== null && _b !== void 0 ? _b : false;\n        const envApiKey = getApiKeyFromEnv();\n        const envProject = getEnv(\"GOOGLE_CLOUD_PROJECT\");\n        const envLocation = getEnv(\"GOOGLE_CLOUD_LOCATION\");\n        this.apiKey = (_c = options.apiKey) !== null && _c !== void 0 ? _c : envApiKey;\n        this.project = (_d = options.project) !== null && _d !== void 0 ? _d : envProject;\n        this.location = (_e = options.location) !== null && _e !== void 0 ? _e : envLocation;\n        // Handle when to use Vertex AI in express mode (api key)\n        if (options.vertexai) {\n            if ((_f = options.googleAuthOptions) === null || _f === void 0 ? void 0 : _f.credentials) {\n                // Explicit credentials take precedence over implicit api_key.\n                console.debug(\"The user provided Google Cloud credentials will take precedence\" + \" over the API key from the environment variable.\");\n                this.apiKey = undefined;\n            }\n            // Explicit api_key and explicit project/location already handled above.\n            if ((envProject || envLocation) && options.apiKey) {\n                // Explicit api_key takes precedence over implicit project/location.\n                console.debug(\"The user provided Vertex AI API key will take precedence over\" + \" the project/location from the environment variables.\");\n                this.project = undefined;\n                this.location = undefined;\n            } else if ((options.project || options.location) && envApiKey) {\n                // Explicit project/location takes precedence over implicit api_key.\n                console.debug(\"The user provided project/location will take precedence over\" + \" the API key from the environment variables.\");\n                this.apiKey = undefined;\n            } else if ((envProject || envLocation) && envApiKey) {\n                // Implicit project/location takes precedence over implicit api_key.\n                console.debug(\"The project/location from the environment variables will take\" + \" precedence over the API key from the environment variables.\");\n                this.apiKey = undefined;\n            }\n        }\n        const baseUrl = getBaseUrl(options.httpOptions, options.vertexai, getEnv(\"GOOGLE_VERTEX_BASE_URL\"), getEnv(\"GOOGLE_GEMINI_BASE_URL\"));\n        if (baseUrl) {\n            if (options.httpOptions) {\n                options.httpOptions.baseUrl = baseUrl;\n            } else {\n                options.httpOptions = {\n                    baseUrl: baseUrl\n                };\n            }\n        }\n        this.apiVersion = options.apiVersion;\n        const auth = new NodeAuth({\n            apiKey: this.apiKey,\n            googleAuthOptions: options.googleAuthOptions\n        });\n        this.apiClient = new ApiClient({\n            auth: auth,\n            project: this.project,\n            location: this.location,\n            apiVersion: this.apiVersion,\n            apiKey: this.apiKey,\n            vertexai: this.vertexai,\n            httpOptions: options.httpOptions,\n            userAgentExtra: LANGUAGE_LABEL_PREFIX + process.version,\n            uploader: new NodeUploader(),\n            downloader: new NodeDownloader()\n        });\n        this.models = new Models(this.apiClient);\n        this.live = new Live(this.apiClient, auth, new NodeWebSocketFactory());\n        this.batches = new Batches(this.apiClient);\n        this.chats = new Chats(this.models, this.apiClient);\n        this.caches = new Caches(this.apiClient);\n        this.files = new Files(this.apiClient);\n        this.operations = new Operations(this.apiClient);\n        this.authTokens = new Tokens(this.apiClient);\n        this.tunings = new Tunings(this.apiClient);\n    }\n}\nfunction getEnv(env) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : undefined;\n}\nfunction getBooleanEnv(env) {\n    return stringToBoolean(getEnv(env));\n}\nfunction stringToBoolean(str) {\n    if (str === undefined) {\n        return false;\n    }\n    return str.toLowerCase() === \"true\";\n}\nfunction getApiKeyFromEnv() {\n    const envGoogleApiKey = getEnv(\"GOOGLE_API_KEY\");\n    const envGeminiApiKey = getEnv(\"GEMINI_API_KEY\");\n    if (envGoogleApiKey && envGeminiApiKey) {\n        console.warn(\"Both GOOGLE_API_KEY and GEMINI_API_KEY are set. Using GOOGLE_API_KEY.\");\n    }\n    return envGoogleApiKey || envGeminiApiKey || undefined;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L25vZGUvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNDO0FBQ1g7QUFDVjtBQUNLO0FBRWxDOzs7O0NBSUMsR0FDRCxJQUFJTSx3QkFBd0JDO0FBQzVCLElBQUlDLHdCQUF3QkQ7QUFDNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDRCxTQUFTRSxtQkFBbUJDLGFBQWE7SUFDckNKLHdCQUF3QkksY0FBY0MsU0FBUztJQUMvQ0gsd0JBQXdCRSxjQUFjRSxTQUFTO0FBQ25EO0FBQ0E7O0NBRUMsR0FDRCxTQUFTQztJQUNMLE9BQU87UUFDSEYsV0FBV0w7UUFDWE0sV0FBV0o7SUFDZjtBQUNKO0FBQ0E7Ozs7O0NBS0MsR0FDRCxTQUFTTSxXQUFXQyxXQUFXLEVBQUVDLFFBQVEsRUFBRUMsb0JBQW9CLEVBQUVDLG9CQUFvQjtJQUNqRixJQUFJQyxJQUFJQztJQUNSLElBQUksQ0FBRUwsQ0FBQUEsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLElBQUksS0FBSyxJQUFJQSxZQUFZTSxPQUFPLEdBQUc7UUFDbEYsTUFBTUMsa0JBQWtCVDtRQUN4QixJQUFJRyxVQUFVO1lBQ1YsT0FBTyxDQUFDRyxLQUFLRyxnQkFBZ0JWLFNBQVMsTUFBTSxRQUFRTyxPQUFPLEtBQUssSUFBSUEsS0FBS0Y7UUFDN0UsT0FDSztZQUNELE9BQU8sQ0FBQ0csS0FBS0UsZ0JBQWdCWCxTQUFTLE1BQU0sUUFBUVMsT0FBTyxLQUFLLElBQUlBLEtBQUtGO1FBQzdFO0lBQ0o7SUFDQSxPQUFPSCxZQUFZTSxPQUFPO0FBQzlCO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1FO0FBQ047QUFDQSxTQUFT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SUFBSW5NLFdBQVcsSUFBSSxDQUFDdDJDLFNBQVM7UUFDL0MsSUFBSSxDQUFDMGlELFVBQVUsR0FBRyxJQUFJNUksT0FBTyxJQUFJLENBQUM5NUMsU0FBUztRQUMzQyxJQUFJLENBQUMyaUQsT0FBTyxHQUFHLElBQUloRSxRQUFRLElBQUksQ0FBQzMrQyxTQUFTO0lBQzdDO0FBQ0o7QUFDQSxTQUFTOGhELE9BQU9jLEdBQUc7SUFDZixJQUFJbnlELElBQUlDLElBQUkwSztJQUNaLE9BQU8sQ0FBQ0EsS0FBSyxDQUFDMUssS0FBSyxDQUFDRCxLQUFLeXhELFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRVSxHQUFHLE1BQU0sUUFBUW55RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQ215RCxJQUFJLE1BQU0sUUFBUWx5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd3M0MsSUFBSSxFQUFDLE1BQU8sUUFBUTlzQyxPQUFPLEtBQUssSUFBSUEsS0FBS3ZMO0FBQzNOO0FBQ0EsU0FBUzZ4RCxjQUFja0IsR0FBRztJQUN0QixPQUFPQyxnQkFBZ0JmLE9BQU9jO0FBQ2xDO0FBQ0EsU0FBU0MsZ0JBQWdCQyxHQUFHO0lBQ3hCLElBQUlBLFFBQVFqekQsV0FBVztRQUNuQixPQUFPO0lBQ1g7SUFDQSxPQUFPaXpELElBQUkzQixXQUFXLE9BQU87QUFDakM7QUFDQSxTQUFTUztJQUNMLE1BQU1tQixrQkFBa0JqQixPQUFPO0lBQy9CLE1BQU1rQixrQkFBa0JsQixPQUFPO0lBQy9CLElBQUlpQixtQkFBbUJDLGlCQUFpQjtRQUNwQ3BuRCxRQUFRQyxJQUFJLENBQUM7SUFDakI7SUFDQSxPQUFPa25ELG1CQUFtQkMsbUJBQW1CbnpEO0FBQ2pEO0FBRStsRSxDQUMvbEUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWF0aC1wcm9ibGVtLWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dlbmFpL2Rpc3Qvbm9kZS9pbmRleC5tanM/MmQ3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHb29nbGVBdXRoIH0gZnJvbSAnZ29vZ2xlLWF1dGgtbGlicmFyeSc7XG5pbXBvcnQgeyBjcmVhdGVXcml0ZVN0cmVhbSwgd3JpdGVGaWxlIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHsgUmVhZGFibGUgfSBmcm9tICdub2RlOnN0cmVhbSc7XG5pbXBvcnQgKiBhcyBOb2RlV3MgZnJvbSAnd3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMvcHJvbWlzZXMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5sZXQgX2RlZmF1bHRCYXNlR2VtaW5pVXJsID0gdW5kZWZpbmVkO1xubGV0IF9kZWZhdWx0QmFzZVZlcnRleFVybCA9IHVuZGVmaW5lZDtcbi8qKlxuICogT3ZlcnJpZGVzIHRoZSBiYXNlIFVSTHMgZm9yIHRoZSBHZW1pbmkgQVBJIGFuZCBWZXJ0ZXggQUkgQVBJLlxuICpcbiAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgaW5pdGlhbGl6aW5nIHRoZSBTREsuIElmIHRoZVxuICogYmFzZSBVUkxzIGFyZSBzZXQgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBTREssIHRoZSBiYXNlIFVSTHMgd2lsbCBub3QgYmVcbiAqIHVwZGF0ZWQuIEJhc2UgVVJMcyBwcm92aWRlZCBpbiB0aGUgSHR0cE9wdGlvbnMgd2lsbCBhbHNvIHRha2UgcHJlY2VkZW5jZSBvdmVyXG4gKiBVUkxzIHNldCBoZXJlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHtHb29nbGVHZW5BSSwgc2V0RGVmYXVsdEJhc2VVcmxzfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIC8vIE92ZXJyaWRlIHRoZSBiYXNlIFVSTCBmb3IgdGhlIEdlbWluaSBBUEkuXG4gKiBzZXREZWZhdWx0QmFzZVVybHMoe2dlbWluaVVybDonaHR0cHM6Ly9nZW1pbmkuZ29vZ2xlLmNvbSd9KTtcbiAqXG4gKiAvLyBPdmVycmlkZSB0aGUgYmFzZSBVUkwgZm9yIHRoZSBWZXJ0ZXggQUkgQVBJLlxuICogc2V0RGVmYXVsdEJhc2VVcmxzKHt2ZXJ0ZXhVcmw6ICdodHRwczovL3ZlcnRleGFpLmdvb2dsZWFwaXMuY29tJ30pO1xuICpcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6ICdHRU1JTklfQVBJX0tFWSd9KTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBzZXREZWZhdWx0QmFzZVVybHMoYmFzZVVybFBhcmFtcykge1xuICAgIF9kZWZhdWx0QmFzZUdlbWluaVVybCA9IGJhc2VVcmxQYXJhbXMuZ2VtaW5pVXJsO1xuICAgIF9kZWZhdWx0QmFzZVZlcnRleFVybCA9IGJhc2VVcmxQYXJhbXMudmVydGV4VXJsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGJhc2UgVVJMcyBmb3IgdGhlIEdlbWluaSBBUEkgYW5kIFZlcnRleCBBSSBBUEkuXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRCYXNlVXJscygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW1pbmlVcmw6IF9kZWZhdWx0QmFzZUdlbWluaVVybCxcbiAgICAgICAgdmVydGV4VXJsOiBfZGVmYXVsdEJhc2VWZXJ0ZXhVcmwsXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBiYXNlIFVSTCBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIHByaW9yaXR5OlxuICogICAxLiBCYXNlIFVSTHMgc2V0IHZpYSBIdHRwT3B0aW9ucy5cbiAqICAgMi4gQmFzZSBVUkxzIHNldCB2aWEgdGhlIGxhdGVzdCBjYWxsIHRvIHNldERlZmF1bHRCYXNlVXJscy5cbiAqICAgMy4gQmFzZSBVUkxzIHNldCB2aWEgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5mdW5jdGlvbiBnZXRCYXNlVXJsKGh0dHBPcHRpb25zLCB2ZXJ0ZXhhaSwgdmVydGV4QmFzZVVybEZyb21FbnYsIGdlbWluaUJhc2VVcmxGcm9tRW52KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIShodHRwT3B0aW9ucyA9PT0gbnVsbCB8fCBodHRwT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cE9wdGlvbnMuYmFzZVVybCkpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdEJhc2VVcmxzID0gZ2V0RGVmYXVsdEJhc2VVcmxzKCk7XG4gICAgICAgIGlmICh2ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IGRlZmF1bHRCYXNlVXJscy52ZXJ0ZXhVcmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZlcnRleEJhc2VVcmxGcm9tRW52O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChfYiA9IGRlZmF1bHRCYXNlVXJscy5nZW1pbmlVcmwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGdlbWluaUJhc2VVcmxGcm9tRW52O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodHRwT3B0aW9ucy5iYXNlVXJsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBCYXNlTW9kdWxlIHtcbn1cbmZ1bmN0aW9uIGZvcm1hdE1hcCh0ZW1wbGF0ZVN0cmluZywgdmFsdWVNYXApIHtcbiAgICAvLyBVc2UgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gZmluZCBhbGwgcGxhY2Vob2xkZXJzIGluIHRoZSB0ZW1wbGF0ZSBzdHJpbmdcbiAgICBjb25zdCByZWdleCA9IC9cXHsoW159XSspXFx9L2c7XG4gICAgLy8gUmVwbGFjZSBlYWNoIHBsYWNlaG9sZGVyIHdpdGggaXRzIGNvcnJlc3BvbmRpbmcgdmFsdWUgZnJvbSB0aGUgdmFsdWVNYXBcbiAgICByZXR1cm4gdGVtcGxhdGVTdHJpbmcucmVwbGFjZShyZWdleCwgKG1hdGNoLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZU1hcCwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZU1hcFtrZXldO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBzdHJpbmcgaWYgaXQncyBub3QgYSBzdHJpbmcgYWxyZWFkeVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgPyBTdHJpbmcodmFsdWUpIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgbWlzc2luZyBrZXlzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAnJHtrZXl9JyBub3QgZm91bmQgaW4gdmFsdWVNYXAuYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlQnlQYXRoKGRhdGEsIGtleXMsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5LmVuZHNXaXRoKCdbXScpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgICAgIGlmICghKGtleU5hbWUgaW4gZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrZXlOYW1lXSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHZhbHVlLmxlbmd0aCB9LCAoKSA9PiAoe30pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgbXVzdCBiZSBhIGxpc3QgZ2l2ZW4gYW4gYXJyYXkgcGF0aCAke2tleX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleU5hbWVdKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5RGF0YSA9IGRhdGFba2V5TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJyYXlEYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGFycmF5RGF0YVtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKGVudHJ5LCBrZXlzLnNsaWNlKGkgKyAxKSwgdmFsdWVbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGQgb2YgYXJyYXlEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChkLCBrZXlzLnNsaWNlKGkgKyAxKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleS5lbmRzV2l0aCgnWzBdJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTMpO1xuICAgICAgICAgICAgaWYgKCEoa2V5TmFtZSBpbiBkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGFba2V5TmFtZV0gPSBbe31dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJyYXlEYXRhID0gZGF0YVtrZXlOYW1lXTtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKGFycmF5RGF0YVswXSwga2V5cy5zbGljZShpICsgMSksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFba2V5XSB8fCB0eXBlb2YgZGF0YVtrZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZGF0YVtrZXldID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGRhdGFba2V5XTtcbiAgICB9XG4gICAgY29uc3Qga2V5VG9TZXQgPSBrZXlzW2tleXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgZXhpc3RpbmdEYXRhID0gZGF0YVtrZXlUb1NldF07XG4gICAgaWYgKGV4aXN0aW5nRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghdmFsdWUgfHxcbiAgICAgICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBleGlzdGluZ0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGV4aXN0aW5nRGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGV4aXN0aW5nRGF0YSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZXhpc3RpbmdEYXRhLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzZXQgdmFsdWUgZm9yIGFuIGV4aXN0aW5nIGtleS4gS2V5OiAke2tleVRvU2V0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoa2V5VG9TZXQgPT09ICdfc2VsZicgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlQXNSZWNvcmQgPSB2YWx1ZTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YSwgdmFsdWVBc1JlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhW2tleVRvU2V0XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VmFsdWVCeVBhdGgoZGF0YSwga2V5cykge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAnX3NlbGYnKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGtleS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlOYW1lIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlEYXRhID0gZGF0YVtrZXlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5RGF0YS5tYXAoKGQpID0+IGdldFZhbHVlQnlQYXRoKGQsIGtleXMuc2xpY2UoaSArIDEpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiB0Qnl0ZXMkMShmcm9tQnl0ZXMpIHtcbiAgICBpZiAodHlwZW9mIGZyb21CeXRlcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tSW1hZ2VCeXRlcyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIC8vIFRPRE8oYi8zODkxMzM5MTQpOiBSZW1vdmUgZHVtbXkgYnl0ZXMgY29udmVydGVyLlxuICAgIHJldHVybiBmcm9tQnl0ZXM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG5mdW5jdGlvbiBmZXRjaFByZWRpY3RPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU9wZXJhdGlvbk5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9wZXJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvcGVyYXRpb25OYW1lJ10sIGZyb21PcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc291cmNlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzb3VyY2VOYW1lJ10pO1xuICAgIGlmIChmcm9tUmVzb3VyY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdyZXNvdXJjZU5hbWUnXSwgZnJvbVJlc291cmNlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZScsXG4gICAgICAgICdnZW5lcmF0ZVZpZGVvUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0ZWRTYW1wbGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRWaWRlb3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkQ291bnQnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlb3MnXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbU1sZGV2JDEoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbVZlcnRleCQxKGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3BlcmF0aW9uTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ29wZXJhdGlvbk5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3BlcmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnb3BlcmF0aW9uTmFtZSddLCBmcm9tT3BlcmF0aW9uTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3BlcmF0aW9uTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ29wZXJhdGlvbk5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3BlcmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnb3BlcmF0aW9uTmFtZSddLCBmcm9tT3BlcmF0aW9uTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nLCAndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvJyxcbiAgICAgICAgJ2VuY29kZWRWaWRlbycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9CeXRlcyddLCB0Qnl0ZXMkMShmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kaW5nJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0Zyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYnl0ZXNCYXNlNjRFbmNvZGVkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyQxKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqIFJlcXVpcmVkLiBPdXRjb21lIG9mIHRoZSBjb2RlIGV4ZWN1dGlvbi4gKi9cbnZhciBPdXRjb21lO1xuKGZ1bmN0aW9uIChPdXRjb21lKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgc3RhdHVzLiBUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9VTlNQRUNJRklFRFwiXSA9IFwiT1VUQ09NRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIENvZGUgZXhlY3V0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfT0tcIl0gPSBcIk9VVENPTUVfT0tcIjtcbiAgICAvKipcbiAgICAgKiBDb2RlIGV4ZWN1dGlvbiBmaW5pc2hlZCBidXQgd2l0aCBhIGZhaWx1cmUuIGBzdGRlcnJgIHNob3VsZCBjb250YWluIHRoZSByZWFzb24uXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfRkFJTEVEXCJdID0gXCJPVVRDT01FX0ZBSUxFRFwiO1xuICAgIC8qKlxuICAgICAqIENvZGUgZXhlY3V0aW9uIHJhbiBmb3IgdG9vIGxvbmcsIGFuZCB3YXMgY2FuY2VsbGVkLiBUaGVyZSBtYXkgb3IgbWF5IG5vdCBiZSBhIHBhcnRpYWwgb3V0cHV0IHByZXNlbnQuXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfREVBRExJTkVfRVhDRUVERURcIl0gPSBcIk9VVENPTUVfREVBRExJTkVfRVhDRUVERURcIjtcbn0pKE91dGNvbWUgfHwgKE91dGNvbWUgPSB7fSkpO1xuLyoqIFJlcXVpcmVkLiBQcm9ncmFtbWluZyBsYW5ndWFnZSBvZiB0aGUgYGNvZGVgLiAqL1xudmFyIExhbmd1YWdlO1xuKGZ1bmN0aW9uIChMYW5ndWFnZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIGxhbmd1YWdlLiBUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBMYW5ndWFnZVtcIkxBTkdVQUdFX1VOU1BFQ0lGSUVEXCJdID0gXCJMQU5HVUFHRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFB5dGhvbiA+PSAzLjEwLCB3aXRoIG51bXB5IGFuZCBzaW1weSBhdmFpbGFibGUuXG4gICAgICovXG4gICAgTGFuZ3VhZ2VbXCJQWVRIT05cIl0gPSBcIlBZVEhPTlwiO1xufSkoTGFuZ3VhZ2UgfHwgKExhbmd1YWdlID0ge30pKTtcbi8qKiBPcHRpb25hbC4gVGhlIHR5cGUgb2YgdGhlIGRhdGEuICovXG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIC8qKlxuICAgICAqIE5vdCBzcGVjaWZpZWQsIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBUeXBlW1wiVFlQRV9VTlNQRUNJRklFRFwiXSA9IFwiVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgc3RyaW5nIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiU1RSSU5HXCJdID0gXCJTVFJJTkdcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIG51bWJlciB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIk5VTUJFUlwiXSA9IFwiTlVNQkVSXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBpbnRlZ2VyIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiSU5URUdFUlwiXSA9IFwiSU5URUdFUlwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgYm9vbGVhbiB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIkJPT0xFQU5cIl0gPSBcIkJPT0xFQU5cIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIGFycmF5IHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiQVJSQVlcIl0gPSBcIkFSUkFZXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBvYmplY3QgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJPQkpFQ1RcIl0gPSBcIk9CSkVDVFwiO1xuICAgIC8qKlxuICAgICAqIE51bGwgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJOVUxMXCJdID0gXCJOVUxMXCI7XG59KShUeXBlIHx8IChUeXBlID0ge30pKTtcbi8qKiBSZXF1aXJlZC4gSGFybSBjYXRlZ29yeS4gKi9cbnZhciBIYXJtQ2F0ZWdvcnk7XG4oZnVuY3Rpb24gKEhhcm1DYXRlZ29yeSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fQ0FURUdPUllfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBoYXRlIHNwZWVjaC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCJdID0gXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgZGFuZ2Vyb3VzIGNvbnRlbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGhhcmFzc21lbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9IQVJBU1NNRU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBzZXh1YWxseSBleHBsaWNpdCBjb250ZW50LlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIl0gPSBcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIjtcbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkOiBFbGVjdGlvbiBmaWx0ZXIgaXMgbm90IGxvbmdlciBzdXBwb3J0ZWQuIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGNpdmljIGludGVncml0eS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0NJVklDX0lOVEVHUklUWVwiXSA9IFwiSEFSTV9DQVRFR09SWV9DSVZJQ19JTlRFR1JJVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBpbWFnZSBoYXRlLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSU1BR0VfSEFURVwiXSA9IFwiSEFSTV9DQVRFR09SWV9JTUFHRV9IQVRFXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaW1hZ2UgZGFuZ2Vyb3VzIGNvbnRlbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9EQU5HRVJPVVNfQ09OVEVOVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9JTUFHRV9EQU5HRVJPVVNfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIGhhcmFzc21lbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9IQVJBU1NNRU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBUkFTU01FTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBpbWFnZSBzZXh1YWxseSBleHBsaWNpdCBjb250ZW50LlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSU1BR0VfU0VYVUFMTFlfRVhQTElDSVRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSU1BR0VfU0VYVUFMTFlfRVhQTElDSVRcIjtcbn0pKEhhcm1DYXRlZ29yeSB8fCAoSGFybUNhdGVnb3J5ID0ge30pKTtcbi8qKiBPcHRpb25hbC4gU3BlY2lmeSBpZiB0aGUgdGhyZXNob2xkIGlzIHVzZWQgZm9yIHByb2JhYmlsaXR5IG9yIHNldmVyaXR5IHNjb3JlLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGhyZXNob2xkIGlzIHVzZWQgZm9yIHByb2JhYmlsaXR5IHNjb3JlLiAqL1xudmFyIEhhcm1CbG9ja01ldGhvZDtcbihmdW5jdGlvbiAoSGFybUJsb2NrTWV0aG9kKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gYmxvY2sgbWV0aG9kIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja01ldGhvZFtcIkhBUk1fQkxPQ0tfTUVUSE9EX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX0JMT0NLX01FVEhPRF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGJsb2NrIG1ldGhvZCB1c2VzIGJvdGggcHJvYmFiaWxpdHkgYW5kIHNldmVyaXR5IHNjb3Jlcy5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tNZXRob2RbXCJTRVZFUklUWVwiXSA9IFwiU0VWRVJJVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBibG9jayBtZXRob2QgdXNlcyB0aGUgcHJvYmFiaWxpdHkgc2NvcmUuXG4gICAgICovXG4gICAgSGFybUJsb2NrTWV0aG9kW1wiUFJPQkFCSUxJVFlcIl0gPSBcIlBST0JBQklMSVRZXCI7XG59KShIYXJtQmxvY2tNZXRob2QgfHwgKEhhcm1CbG9ja01ldGhvZCA9IHt9KSk7XG4vKiogUmVxdWlyZWQuIFRoZSBoYXJtIGJsb2NrIHRocmVzaG9sZC4gKi9cbnZhciBIYXJtQmxvY2tUaHJlc2hvbGQ7XG4oZnVuY3Rpb24gKEhhcm1CbG9ja1RocmVzaG9sZCkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIGhhcm0gYmxvY2sgdGhyZXNob2xkLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkhBUk1fQkxPQ0tfVEhSRVNIT0xEX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX0JMT0NLX1RIUkVTSE9MRF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGxvdyB0aHJlc2hvbGQgYW5kIGFib3ZlIChpLmUuIGJsb2NrIG1vcmUpLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX0xPV19BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX0xPV19BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9jayBtZWRpdW0gdGhyZXNob2xkIGFuZCBhYm92ZS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2sgb25seSBoaWdoIHRocmVzaG9sZCAoaS5lLiBibG9jayBsZXNzKS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19PTkxZX0hJR0hcIl0gPSBcIkJMT0NLX09OTFlfSElHSFwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIG5vbmUuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTk9ORVwiXSA9IFwiQkxPQ0tfTk9ORVwiO1xuICAgIC8qKlxuICAgICAqIFR1cm4gb2ZmIHRoZSBzYWZldHkgZmlsdGVyLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIk9GRlwiXSA9IFwiT0ZGXCI7XG59KShIYXJtQmxvY2tUaHJlc2hvbGQgfHwgKEhhcm1CbG9ja1RocmVzaG9sZCA9IHt9KSk7XG4vKiogVGhlIG1vZGUgb2YgdGhlIHByZWRpY3RvciB0byBiZSB1c2VkIGluIGR5bmFtaWMgcmV0cmlldmFsLiAqL1xudmFyIE1vZGU7XG4oZnVuY3Rpb24gKE1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBBbHdheXMgdHJpZ2dlciByZXRyaWV2YWwuXG4gICAgICovXG4gICAgTW9kZVtcIk1PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBSdW4gcmV0cmlldmFsIG9ubHkgd2hlbiBzeXN0ZW0gZGVjaWRlcyBpdCBpcyBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgTW9kZVtcIk1PREVfRFlOQU1JQ1wiXSA9IFwiTU9ERV9EWU5BTUlDXCI7XG59KShNb2RlIHx8IChNb2RlID0ge30pKTtcbi8qKiBUeXBlIG9mIGF1dGggc2NoZW1lLiAqL1xudmFyIEF1dGhUeXBlO1xuKGZ1bmN0aW9uIChBdXRoVHlwZSkge1xuICAgIEF1dGhUeXBlW1wiQVVUSF9UWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJBVVRIX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBObyBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiTk9fQVVUSFwiXSA9IFwiTk9fQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIEFQSSBLZXkgQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIkFQSV9LRVlfQVVUSFwiXSA9IFwiQVBJX0tFWV9BVVRIXCI7XG4gICAgLyoqXG4gICAgICogSFRUUCBCYXNpYyBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiSFRUUF9CQVNJQ19BVVRIXCJdID0gXCJIVFRQX0JBU0lDX0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBHb29nbGUgU2VydmljZSBBY2NvdW50IEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJHT09HTEVfU0VSVklDRV9BQ0NPVU5UX0FVVEhcIl0gPSBcIkdPT0dMRV9TRVJWSUNFX0FDQ09VTlRfQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIE9BdXRoIGF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJPQVVUSFwiXSA9IFwiT0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuSUQgQ29ubmVjdCAoT0lEQykgQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIk9JRENfQVVUSFwiXSA9IFwiT0lEQ19BVVRIXCI7XG59KShBdXRoVHlwZSB8fCAoQXV0aFR5cGUgPSB7fSkpO1xuLyoqIFRoZSBBUEkgc3BlYyB0aGF0IHRoZSBleHRlcm5hbCBBUEkgaW1wbGVtZW50cy4gKi9cbnZhciBBcGlTcGVjO1xuKGZ1bmN0aW9uIChBcGlTcGVjKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgQVBJIHNwZWMuIFRoaXMgdmFsdWUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIEFwaVNwZWNbXCJBUElfU1BFQ19VTlNQRUNJRklFRFwiXSA9IFwiQVBJX1NQRUNfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBTaW1wbGUgc2VhcmNoIEFQSSBzcGVjLlxuICAgICAqL1xuICAgIEFwaVNwZWNbXCJTSU1QTEVfU0VBUkNIXCJdID0gXCJTSU1QTEVfU0VBUkNIXCI7XG4gICAgLyoqXG4gICAgICogRWxhc3RpYyBzZWFyY2ggQVBJIHNwZWMuXG4gICAgICovXG4gICAgQXBpU3BlY1tcIkVMQVNUSUNfU0VBUkNIXCJdID0gXCJFTEFTVElDX1NFQVJDSFwiO1xufSkoQXBpU3BlYyB8fCAoQXBpU3BlYyA9IHt9KSk7XG4vKiogU3RhdHVzIG9mIHRoZSB1cmwgcmV0cmlldmFsLiAqL1xudmFyIFVybFJldHJpZXZhbFN0YXR1cztcbihmdW5jdGlvbiAoVXJsUmV0cmlldmFsU3RhdHVzKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZS4gVGhpcyB2YWx1ZSBpcyB1bnVzZWRcbiAgICAgKi9cbiAgICBVcmxSZXRyaWV2YWxTdGF0dXNbXCJVUkxfUkVUUklFVkFMX1NUQVRVU19VTlNQRUNJRklFRFwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfU1VDQ0VTU1wiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfU1VDQ0VTU1wiO1xuICAgIC8qKlxuICAgICAqIFVybCByZXRyaWV2YWwgaXMgZmFpbGVkIGR1ZSB0byBlcnJvci5cbiAgICAgKi9cbiAgICBVcmxSZXRyaWV2YWxTdGF0dXNbXCJVUkxfUkVUUklFVkFMX1NUQVRVU19FUlJPUlwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfRVJST1JcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIGZhaWxlZCBiZWNhdXNlIHRoZSBjb250ZW50IGlzIGJlaGluZCBwYXl3YWxsLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1BBWVdBTExcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1BBWVdBTExcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIGZhaWxlZCBiZWNhdXNlIHRoZSBjb250ZW50IGlzIHVuc2FmZS5cbiAgICAgKi9cbiAgICBVcmxSZXRyaWV2YWxTdGF0dXNbXCJVUkxfUkVUUklFVkFMX1NUQVRVU19VTlNBRkVcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU0FGRVwiO1xufSkoVXJsUmV0cmlldmFsU3RhdHVzIHx8IChVcmxSZXRyaWV2YWxTdGF0dXMgPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBUaGUgcmVhc29uIHdoeSB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy5cblxuICBJZiBlbXB0eSwgdGhlIG1vZGVsIGhhcyBub3Qgc3RvcHBlZCBnZW5lcmF0aW5nIHRoZSB0b2tlbnMuXG4gICAqL1xudmFyIEZpbmlzaFJlYXNvbjtcbihmdW5jdGlvbiAoRmluaXNoUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmlzaCByZWFzb24gaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiRklOSVNIX1JFQVNPTl9VTlNQRUNJRklFRFwiXSA9IFwiRklOSVNIX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gcmVhY2hlZCBhIG5hdHVyYWwgc3RvcHBpbmcgcG9pbnQgb3IgYSBjb25maWd1cmVkIHN0b3Agc2VxdWVuY2UuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiU1RPUFwiXSA9IFwiU1RPUFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gcmVhY2hlZCB0aGUgY29uZmlndXJlZCBtYXhpbXVtIG91dHB1dCB0b2tlbnMuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTUFYX1RPS0VOU1wiXSA9IFwiTUFYX1RPS0VOU1wiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IHBvdGVudGlhbGx5IGNvbnRhaW5zIHNhZmV0eSB2aW9sYXRpb25zLiBOT1RFOiBXaGVuIHN0cmVhbWluZywgW2NvbnRlbnRdW10gaXMgZW1wdHkgaWYgY29udGVudCBmaWx0ZXJzIGJsb2NrcyB0aGUgb3V0cHV0LlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlNBRkVUWVwiXSA9IFwiU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIG9mIHBvdGVudGlhbCByZWNpdGF0aW9uLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlJFQ0lUQVRJT05cIl0gPSBcIlJFQ0lUQVRJT05cIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2Ugb2YgdXNpbmcgYW4gdW5zdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTEFOR1VBR0VcIl0gPSBcIkxBTkdVQUdFXCI7XG4gICAgLyoqXG4gICAgICogQWxsIG90aGVyIHJlYXNvbnMgdGhhdCBzdG9wcGVkIHRoZSB0b2tlbiBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIk9USEVSXCJdID0gXCJPVEhFUlwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IGNvbnRhaW5zIGZvcmJpZGRlbiB0ZXJtcy5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJCTE9DS0xJU1RcIl0gPSBcIkJMT0NLTElTVFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBmb3IgcG90ZW50aWFsbHkgY29udGFpbmluZyBwcm9oaWJpdGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJQUk9ISUJJVEVEX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSB0aGUgY29udGVudCBwb3RlbnRpYWxseSBjb250YWlucyBTZW5zaXRpdmUgUGVyc29uYWxseSBJZGVudGlmaWFibGUgSW5mb3JtYXRpb24gKFNQSUkpLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlNQSUlcIl0gPSBcIlNQSUlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbCBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIl0gPSBcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgZ2VuZXJhdGVkIGltYWdlcyBoYXZlIHNhZmV0eSB2aW9sYXRpb25zLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIklNQUdFX1NBRkVUWVwiXSA9IFwiSU1BR0VfU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRvb2wgY2FsbCBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiVU5FWFBFQ1RFRF9UT09MX0NBTExcIl0gPSBcIlVORVhQRUNURURfVE9PTF9DQUxMXCI7XG4gICAgLyoqXG4gICAgICogSW1hZ2UgZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgdGhlIGdlbmVyYXRlZCBpbWFnZXMgaGF2ZSBwcm9oaWJpdGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiSU1BR0VfUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJJTUFHRV9QUk9ISUJJVEVEX0NPTlRFTlRcIjtcbn0pKEZpbmlzaFJlYXNvbiB8fCAoRmluaXNoUmVhc29uID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gSGFybSBwcm9iYWJpbGl0eSBsZXZlbHMgaW4gdGhlIGNvbnRlbnQuICovXG52YXIgSGFybVByb2JhYmlsaXR5O1xuKGZ1bmN0aW9uIChIYXJtUHJvYmFiaWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBIYXJtIHByb2JhYmlsaXR5IHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIkhBUk1fUFJPQkFCSUxJVFlfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fUFJPQkFCSUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBOZWdsaWdpYmxlIGxldmVsIG9mIGhhcm0uXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiTkVHTElHSUJMRVwiXSA9IFwiTkVHTElHSUJMRVwiO1xuICAgIC8qKlxuICAgICAqIExvdyBsZXZlbCBvZiBoYXJtLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIkxPV1wiXSA9IFwiTE9XXCI7XG4gICAgLyoqXG4gICAgICogTWVkaXVtIGxldmVsIG9mIGhhcm0uXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiTUVESVVNXCJdID0gXCJNRURJVU1cIjtcbiAgICAvKipcbiAgICAgKiBIaWdoIGxldmVsIG9mIGhhcm0uXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiSElHSFwiXSA9IFwiSElHSFwiO1xufSkoSGFybVByb2JhYmlsaXR5IHx8IChIYXJtUHJvYmFiaWxpdHkgPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBIYXJtIHNldmVyaXR5IGxldmVscyBpbiB0aGUgY29udGVudC4gKi9cbnZhciBIYXJtU2V2ZXJpdHk7XG4oZnVuY3Rpb24gKEhhcm1TZXZlcml0eSkge1xuICAgIC8qKlxuICAgICAqIEhhcm0gc2V2ZXJpdHkgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9TRVZFUklUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE5lZ2xpZ2libGUgbGV2ZWwgb2YgaGFybSBzZXZlcml0eS5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX05FR0xJR0lCTEVcIl0gPSBcIkhBUk1fU0VWRVJJVFlfTkVHTElHSUJMRVwiO1xuICAgIC8qKlxuICAgICAqIExvdyBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfTE9XXCJdID0gXCJIQVJNX1NFVkVSSVRZX0xPV1wiO1xuICAgIC8qKlxuICAgICAqIE1lZGl1bSBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfTUVESVVNXCJdID0gXCJIQVJNX1NFVkVSSVRZX01FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgb2YgaGFybSBzZXZlcml0eS5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX0hJR0hcIl0gPSBcIkhBUk1fU0VWRVJJVFlfSElHSFwiO1xufSkoSGFybVNldmVyaXR5IHx8IChIYXJtU2V2ZXJpdHkgPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBCbG9ja2VkIHJlYXNvbi4gKi9cbnZhciBCbG9ja2VkUmVhc29uO1xuKGZ1bmN0aW9uIChCbG9ja2VkUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgYmxvY2tlZCByZWFzb24uXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIkJMT0NLRURfUkVBU09OX1VOU1BFQ0lGSUVEXCJdID0gXCJCTE9DS0VEX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIENhbmRpZGF0ZXMgYmxvY2tlZCBkdWUgdG8gc2FmZXR5LlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJTQUZFVFlcIl0gPSBcIlNBRkVUWVwiO1xuICAgIC8qKlxuICAgICAqIENhbmRpZGF0ZXMgYmxvY2tlZCBkdWUgdG8gb3RoZXIgcmVhc29uLlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJPVEhFUlwiXSA9IFwiT1RIRVJcIjtcbiAgICAvKipcbiAgICAgKiBDYW5kaWRhdGVzIGJsb2NrZWQgZHVlIHRvIHRoZSB0ZXJtcyB3aGljaCBhcmUgaW5jbHVkZWQgZnJvbSB0aGUgdGVybWlub2xvZ3kgYmxvY2tsaXN0LlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJCTE9DS0xJU1RcIl0gPSBcIkJMT0NLTElTVFwiO1xuICAgIC8qKlxuICAgICAqIENhbmRpZGF0ZXMgYmxvY2tlZCBkdWUgdG8gcHJvaGliaXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJQUk9ISUJJVEVEX0NPTlRFTlRcIl0gPSBcIlBST0hJQklURURfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIENhbmRpZGF0ZXMgYmxvY2tlZCBkdWUgdG8gdW5zYWZlIGltYWdlIGdlbmVyYXRpb24gY29udGVudC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiSU1BR0VfU0FGRVRZXCJdID0gXCJJTUFHRV9TQUZFVFlcIjtcbn0pKEJsb2NrZWRSZWFzb24gfHwgKEJsb2NrZWRSZWFzb24gPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBUcmFmZmljIHR5cGUuIFRoaXMgc2hvd3Mgd2hldGhlciBhIHJlcXVlc3QgY29uc3VtZXMgUGF5LUFzLVlvdS1HbyBvciBQcm92aXNpb25lZCBUaHJvdWdocHV0IHF1b3RhLiAqL1xudmFyIFRyYWZmaWNUeXBlO1xuKGZ1bmN0aW9uIChUcmFmZmljVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIHJlcXVlc3QgdHJhZmZpYyB0eXBlLlxuICAgICAqL1xuICAgIFRyYWZmaWNUeXBlW1wiVFJBRkZJQ19UWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJUUkFGRklDX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUeXBlIGZvciBQYXktQXMtWW91LUdvIHRyYWZmaWMuXG4gICAgICovXG4gICAgVHJhZmZpY1R5cGVbXCJPTl9ERU1BTkRcIl0gPSBcIk9OX0RFTUFORFwiO1xuICAgIC8qKlxuICAgICAqIFR5cGUgZm9yIFByb3Zpc2lvbmVkIFRocm91Z2hwdXQgdHJhZmZpYy5cbiAgICAgKi9cbiAgICBUcmFmZmljVHlwZVtcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIl0gPSBcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIjtcbn0pKFRyYWZmaWNUeXBlIHx8IChUcmFmZmljVHlwZSA9IHt9KSk7XG4vKiogU2VydmVyIGNvbnRlbnQgbW9kYWxpdGllcy4gKi9cbnZhciBNb2RhbGl0eTtcbihmdW5jdGlvbiAoTW9kYWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kYWxpdHkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiTU9EQUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gdGV4dFxuICAgICAqL1xuICAgIE1vZGFsaXR5W1wiVEVYVFwiXSA9IFwiVEVYVFwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgbW9kZWwgc2hvdWxkIHJldHVybiBpbWFnZXMuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJJTUFHRVwiXSA9IFwiSU1BR0VcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gYXVkaW8uXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJBVURJT1wiXSA9IFwiQVVESU9cIjtcbn0pKE1vZGFsaXR5IHx8IChNb2RhbGl0eSA9IHt9KSk7XG4vKiogVGhlIG1lZGlhIHJlc29sdXRpb24gdG8gdXNlLiAqL1xudmFyIE1lZGlhUmVzb2x1dGlvbjtcbihmdW5jdGlvbiAoTWVkaWFSZXNvbHV0aW9uKSB7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBoYXMgbm90IGJlZW4gc2V0XG4gICAgICovXG4gICAgTWVkaWFSZXNvbHV0aW9uW1wiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGxvdyAoNjQgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9MT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBtZWRpdW0gKDI1NiB0b2tlbnMpLlxuICAgICAqL1xuICAgIE1lZGlhUmVzb2x1dGlvbltcIk1FRElBX1JFU09MVVRJT05fTUVESVVNXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX01FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGhpZ2ggKHpvb21lZCByZWZyYW1pbmcgd2l0aCAyNTYgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0hJR0hcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fSElHSFwiO1xufSkoTWVkaWFSZXNvbHV0aW9uIHx8IChNZWRpYVJlc29sdXRpb24gPSB7fSkpO1xuLyoqIEpvYiBzdGF0ZS4gKi9cbnZhciBKb2JTdGF0ZTtcbihmdW5jdGlvbiAoSm9iU3RhdGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIHN0YXRlIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1VOU1BFQ0lGSUVEXCJdID0gXCJKT0JfU1RBVEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBiZWVuIGp1c3QgY3JlYXRlZCBvciByZXN1bWVkIGFuZCBwcm9jZXNzaW5nIGhhcyBub3QgeWV0IGJlZ3VuLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1FVRVVFRFwiXSA9IFwiSk9CX1NUQVRFX1FVRVVFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2aWNlIGlzIHByZXBhcmluZyB0byBydW4gdGhlIGpvYi5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9QRU5ESU5HXCJdID0gXCJKT0JfU1RBVEVfUEVORElOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfUlVOTklOR1wiXSA9IFwiSk9CX1NUQVRFX1JVTk5JTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfU1VDQ0VFREVEXCJdID0gXCJKT0JfU1RBVEVfU1VDQ0VFREVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBmYWlsZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfRkFJTEVEXCJdID0gXCJKT0JfU1RBVEVfRkFJTEVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBiZWluZyBjYW5jZWxsZWQuIEZyb20gdGhpcyBzdGF0ZSB0aGUgam9iIG1heSBvbmx5IGdvIHRvIGVpdGhlciBgSk9CX1NUQVRFX1NVQ0NFRURFRGAsIGBKT0JfU1RBVEVfRkFJTEVEYCBvciBgSk9CX1NUQVRFX0NBTkNFTExFRGAuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfQ0FOQ0VMTElOR1wiXSA9IFwiSk9CX1NUQVRFX0NBTkNFTExJTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBiZWVuIGNhbmNlbGxlZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9DQU5DRUxMRURcIl0gPSBcIkpPQl9TVEFURV9DQU5DRUxMRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBiZWVuIHN0b3BwZWQsIGFuZCBjYW4gYmUgcmVzdW1lZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9QQVVTRURcIl0gPSBcIkpPQl9TVEFURV9QQVVTRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBleHBpcmVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX0VYUElSRURcIl0gPSBcIkpPQl9TVEFURV9FWFBJUkVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBiZWluZyB1cGRhdGVkLiBPbmx5IGpvYnMgaW4gdGhlIGBKT0JfU1RBVEVfUlVOTklOR2Agc3RhdGUgY2FuIGJlIHVwZGF0ZWQuIEFmdGVyIHVwZGF0aW5nLCB0aGUgam9iIGdvZXMgYmFjayB0byB0aGUgYEpPQl9TVEFURV9SVU5OSU5HYCBzdGF0ZS5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9VUERBVElOR1wiXSA9IFwiSk9CX1NUQVRFX1VQREFUSU5HXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBwYXJ0aWFsbHkgc3VjY2VlZGVkLCBzb21lIHJlc3VsdHMgbWF5IGJlIG1pc3NpbmcgZHVlIHRvIGVycm9ycy5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9QQVJUSUFMTFlfU1VDQ0VFREVEXCJdID0gXCJKT0JfU1RBVEVfUEFSVElBTExZX1NVQ0NFRURFRFwiO1xufSkoSm9iU3RhdGUgfHwgKEpvYlN0YXRlID0ge30pKTtcbi8qKiBUdW5pbmcgbW9kZS4gKi9cbnZhciBUdW5pbmdNb2RlO1xuKGZ1bmN0aW9uIChUdW5pbmdNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVHVuaW5nIG1vZGUgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgVHVuaW5nTW9kZVtcIlRVTklOR19NT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJUVU5JTkdfTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEZ1bGwgZmluZS10dW5pbmcgbW9kZS5cbiAgICAgKi9cbiAgICBUdW5pbmdNb2RlW1wiVFVOSU5HX01PREVfRlVMTFwiXSA9IFwiVFVOSU5HX01PREVfRlVMTFwiO1xuICAgIC8qKlxuICAgICAqIFBFRlQgYWRhcHRlciB0dW5pbmcgbW9kZS5cbiAgICAgKi9cbiAgICBUdW5pbmdNb2RlW1wiVFVOSU5HX01PREVfUEVGVF9BREFQVEVSXCJdID0gXCJUVU5JTkdfTU9ERV9QRUZUX0FEQVBURVJcIjtcbn0pKFR1bmluZ01vZGUgfHwgKFR1bmluZ01vZGUgPSB7fSkpO1xuLyoqIE9wdGlvbmFsLiBBZGFwdGVyIHNpemUgZm9yIHR1bmluZy4gKi9cbnZhciBBZGFwdGVyU2l6ZTtcbihmdW5jdGlvbiAoQWRhcHRlclNpemUpIHtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfVU5TUEVDSUZJRURcIl0gPSBcIkFEQVBURVJfU0laRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSAxLlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX09ORVwiXSA9IFwiQURBUFRFUl9TSVpFX09ORVwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSAyLlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX1RXT1wiXSA9IFwiQURBUFRFUl9TSVpFX1RXT1wiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSA0LlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX0ZPVVJcIl0gPSBcIkFEQVBURVJfU0laRV9GT1VSXCI7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIDguXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfRUlHSFRcIl0gPSBcIkFEQVBURVJfU0laRV9FSUdIVFwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSAxNi5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9TSVhURUVOXCJdID0gXCJBREFQVEVSX1NJWkVfU0lYVEVFTlwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSAzMi5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9USElSVFlfVFdPXCJdID0gXCJBREFQVEVSX1NJWkVfVEhJUlRZX1RXT1wiO1xufSkoQWRhcHRlclNpemUgfHwgKEFkYXB0ZXJTaXplID0ge30pKTtcbi8qKiBPcHRpb25hbC4gVGhlIHR1bmluZyB0YXNrLiBFaXRoZXIgSTJWIG9yIFQyVi4gKi9cbnZhciBUdW5pbmdUYXNrO1xuKGZ1bmN0aW9uIChUdW5pbmdUYXNrKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZS4gVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgVHVuaW5nVGFza1tcIlRVTklOR19UQVNLX1VOU1BFQ0lGSUVEXCJdID0gXCJUVU5JTkdfVEFTS19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFR1bmluZyB0YXNrIGZvciBpbWFnZSB0byB2aWRlby5cbiAgICAgKi9cbiAgICBUdW5pbmdUYXNrW1wiVFVOSU5HX1RBU0tfSTJWXCJdID0gXCJUVU5JTkdfVEFTS19JMlZcIjtcbiAgICAvKipcbiAgICAgKiBUdW5pbmcgdGFzayBmb3IgdGV4dCB0byB2aWRlby5cbiAgICAgKi9cbiAgICBUdW5pbmdUYXNrW1wiVFVOSU5HX1RBU0tfVDJWXCJdID0gXCJUVU5JTkdfVEFTS19UMlZcIjtcbn0pKFR1bmluZ1Rhc2sgfHwgKFR1bmluZ1Rhc2sgPSB7fSkpO1xuLyoqIE9wdGlvbnMgZm9yIGZlYXR1cmUgc2VsZWN0aW9uIHByZWZlcmVuY2UuICovXG52YXIgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2U7XG4oZnVuY3Rpb24gKEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlKSB7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJGRUFUVVJFX1NFTEVDVElPTl9QUkVGRVJFTkNFX1VOU1BFQ0lGSUVEXCJdID0gXCJGRUFUVVJFX1NFTEVDVElPTl9QUkVGRVJFTkNFX1VOU1BFQ0lGSUVEXCI7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJQUklPUklUSVpFX1FVQUxJVFlcIl0gPSBcIlBSSU9SSVRJWkVfUVVBTElUWVwiO1xuICAgIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlW1wiQkFMQU5DRURcIl0gPSBcIkJBTEFOQ0VEXCI7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJQUklPUklUSVpFX0NPU1RcIl0gPSBcIlBSSU9SSVRJWkVfQ09TVFwiO1xufSkoRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UgfHwgKEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlID0ge30pKTtcbi8qKiBEZWZpbmVzIHRoZSBmdW5jdGlvbiBiZWhhdmlvci4gRGVmYXVsdHMgdG8gYEJMT0NLSU5HYC4gKi9cbnZhciBCZWhhdmlvcjtcbihmdW5jdGlvbiAoQmVoYXZpb3IpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBCZWhhdmlvcltcIlVOU1BFQ0lGSUVEXCJdID0gXCJVTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIElmIHNldCwgdGhlIHN5c3RlbSB3aWxsIHdhaXQgdG8gcmVjZWl2ZSB0aGUgZnVuY3Rpb24gcmVzcG9uc2UgYmVmb3JlIGNvbnRpbnVpbmcgdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKi9cbiAgICBCZWhhdmlvcltcIkJMT0NLSU5HXCJdID0gXCJCTE9DS0lOR1wiO1xuICAgIC8qKlxuICAgICAqIElmIHNldCwgdGhlIHN5c3RlbSB3aWxsIG5vdCB3YWl0IHRvIHJlY2VpdmUgdGhlIGZ1bmN0aW9uIHJlc3BvbnNlLiBJbnN0ZWFkLCBpdCB3aWxsIGF0dGVtcHQgdG8gaGFuZGxlIGZ1bmN0aW9uIHJlc3BvbnNlcyBhcyB0aGV5IGJlY29tZSBhdmFpbGFibGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGNvbnZlcnNhdGlvbiBiZXR3ZWVuIHRoZSB1c2VyIGFuZCB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgQmVoYXZpb3JbXCJOT05fQkxPQ0tJTkdcIl0gPSBcIk5PTl9CTE9DS0lOR1wiO1xufSkoQmVoYXZpb3IgfHwgKEJlaGF2aW9yID0ge30pKTtcbi8qKiBDb25maWcgZm9yIHRoZSBkeW5hbWljIHJldHJpZXZhbCBjb25maWcgbW9kZS4gKi9cbnZhciBEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZTtcbihmdW5jdGlvbiAoRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUpIHtcbiAgICAvKipcbiAgICAgKiBBbHdheXMgdHJpZ2dlciByZXRyaWV2YWwuXG4gICAgICovXG4gICAgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGVbXCJNT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogUnVuIHJldHJpZXZhbCBvbmx5IHdoZW4gc3lzdGVtIGRlY2lkZXMgaXQgaXMgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlW1wiTU9ERV9EWU5BTUlDXCJdID0gXCJNT0RFX0RZTkFNSUNcIjtcbn0pKER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlIHx8IChEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSA9IHt9KSk7XG4vKiogVGhlIGVudmlyb25tZW50IGJlaW5nIG9wZXJhdGVkLiAqL1xudmFyIEVudmlyb25tZW50O1xuKGZ1bmN0aW9uIChFbnZpcm9ubWVudCkge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHRzIHRvIGJyb3dzZXIuXG4gICAgICovXG4gICAgRW52aXJvbm1lbnRbXCJFTlZJUk9OTUVOVF9VTlNQRUNJRklFRFwiXSA9IFwiRU5WSVJPTk1FTlRfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBPcGVyYXRlcyBpbiBhIHdlYiBicm93c2VyLlxuICAgICAqL1xuICAgIEVudmlyb25tZW50W1wiRU5WSVJPTk1FTlRfQlJPV1NFUlwiXSA9IFwiRU5WSVJPTk1FTlRfQlJPV1NFUlwiO1xufSkoRW52aXJvbm1lbnQgfHwgKEVudmlyb25tZW50ID0ge30pKTtcbi8qKiBDb25maWcgZm9yIHRoZSBmdW5jdGlvbiBjYWxsaW5nIGNvbmZpZyBtb2RlLiAqL1xudmFyIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGU7XG4oZnVuY3Rpb24gKEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGluZyBjb25maWcgbW9kZSBpcyB1bnNwZWNpZmllZC4gU2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJNT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBtb2RlbCBiZWhhdmlvciwgbW9kZWwgZGVjaWRlcyB0byBwcmVkaWN0IGVpdGhlciBmdW5jdGlvbiBjYWxscyBvciBuYXR1cmFsIGxhbmd1YWdlIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJBVVRPXCJdID0gXCJBVVRPXCI7XG4gICAgLyoqXG4gICAgICogTW9kZWwgaXMgY29uc3RyYWluZWQgdG8gYWx3YXlzIHByZWRpY3RpbmcgZnVuY3Rpb24gY2FsbHMgb25seS4gSWYgXCJhbGxvd2VkX2Z1bmN0aW9uX25hbWVzXCIgYXJlIHNldCwgdGhlIHByZWRpY3RlZCBmdW5jdGlvbiBjYWxscyB3aWxsIGJlIGxpbWl0ZWQgdG8gYW55IG9uZSBvZiBcImFsbG93ZWRfZnVuY3Rpb25fbmFtZXNcIiwgZWxzZSB0aGUgcHJlZGljdGVkIGZ1bmN0aW9uIGNhbGxzIHdpbGwgYmUgYW55IG9uZSBvZiB0aGUgcHJvdmlkZWQgXCJmdW5jdGlvbl9kZWNsYXJhdGlvbnNcIi5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiQU5ZXCJdID0gXCJBTllcIjtcbiAgICAvKipcbiAgICAgKiBNb2RlbCB3aWxsIG5vdCBwcmVkaWN0IGFueSBmdW5jdGlvbiBjYWxscy4gTW9kZWwgYmVoYXZpb3IgaXMgc2FtZSBhcyB3aGVuIG5vdCBwYXNzaW5nIGFueSBmdW5jdGlvbiBkZWNsYXJhdGlvbnMuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIk5PTkVcIl0gPSBcIk5PTkVcIjtcbiAgICAvKipcbiAgICAgKiBNb2RlbCBkZWNpZGVzIHRvIHByZWRpY3QgZWl0aGVyIGEgZnVuY3Rpb24gY2FsbCBvciBhIG5hdHVyYWwgbGFuZ3VhZ2UgcmVzcG9uc2UsIGJ1dCB3aWxsIHZhbGlkYXRlIGZ1bmN0aW9uIGNhbGxzIHdpdGggY29uc3RyYWluZWQgZGVjb2RpbmcuIElmIFwiYWxsb3dlZF9mdW5jdGlvbl9uYW1lc1wiIGFyZSBzZXQsIHRoZSBwcmVkaWN0ZWQgZnVuY3Rpb24gY2FsbCB3aWxsIGJlIGxpbWl0ZWQgdG8gYW55IG9uZSBvZiBcImFsbG93ZWRfZnVuY3Rpb25fbmFtZXNcIiwgZWxzZSB0aGUgcHJlZGljdGVkIGZ1bmN0aW9uIGNhbGwgd2lsbCBiZSBhbnkgb25lIG9mIHRoZSBwcm92aWRlZCBcImZ1bmN0aW9uX2RlY2xhcmF0aW9uc1wiLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJWQUxJREFURURcIl0gPSBcIlZBTElEQVRFRFwiO1xufSkoRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSB8fCAoRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSA9IHt9KSk7XG4vKiogRW51bSB0aGF0IGNvbnRyb2xzIHRoZSBzYWZldHkgZmlsdGVyIGxldmVsIGZvciBvYmplY3Rpb25hYmxlIGNvbnRlbnQuICovXG52YXIgU2FmZXR5RmlsdGVyTGV2ZWw7XG4oZnVuY3Rpb24gKFNhZmV0eUZpbHRlckxldmVsKSB7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCI7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCI7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19PTkxZX0hJR0hcIl0gPSBcIkJMT0NLX09OTFlfSElHSFwiO1xuICAgIFNhZmV0eUZpbHRlckxldmVsW1wiQkxPQ0tfTk9ORVwiXSA9IFwiQkxPQ0tfTk9ORVwiO1xufSkoU2FmZXR5RmlsdGVyTGV2ZWwgfHwgKFNhZmV0eUZpbHRlckxldmVsID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgY29udHJvbHMgdGhlIGdlbmVyYXRpb24gb2YgcGVvcGxlLiAqL1xudmFyIFBlcnNvbkdlbmVyYXRpb247XG4oZnVuY3Rpb24gKFBlcnNvbkdlbmVyYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBCbG9jayBnZW5lcmF0aW9uIG9mIGltYWdlcyBvZiBwZW9wbGUuXG4gICAgICovXG4gICAgUGVyc29uR2VuZXJhdGlvbltcIkRPTlRfQUxMT1dcIl0gPSBcIkRPTlRfQUxMT1dcIjtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBpbWFnZXMgb2YgYWR1bHRzLCBidXQgbm90IGNoaWxkcmVuLlxuICAgICAqL1xuICAgIFBlcnNvbkdlbmVyYXRpb25bXCJBTExPV19BRFVMVFwiXSA9IFwiQUxMT1dfQURVTFRcIjtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBpbWFnZXMgdGhhdCBpbmNsdWRlIGFkdWx0cyBhbmQgY2hpbGRyZW4uXG4gICAgICovXG4gICAgUGVyc29uR2VuZXJhdGlvbltcIkFMTE9XX0FMTFwiXSA9IFwiQUxMT1dfQUxMXCI7XG59KShQZXJzb25HZW5lcmF0aW9uIHx8IChQZXJzb25HZW5lcmF0aW9uID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgc3BlY2lmaWVzIHRoZSBsYW5ndWFnZSBvZiB0aGUgdGV4dCBpbiB0aGUgcHJvbXB0LiAqL1xudmFyIEltYWdlUHJvbXB0TGFuZ3VhZ2U7XG4oZnVuY3Rpb24gKEltYWdlUHJvbXB0TGFuZ3VhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBBdXRvLWRldGVjdCB0aGUgbGFuZ3VhZ2UuXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImF1dG9cIl0gPSBcImF1dG9cIjtcbiAgICAvKipcbiAgICAgKiBFbmdsaXNoXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImVuXCJdID0gXCJlblwiO1xuICAgIC8qKlxuICAgICAqIEphcGFuZXNlXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImphXCJdID0gXCJqYVwiO1xuICAgIC8qKlxuICAgICAqIEtvcmVhblxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJrb1wiXSA9IFwia29cIjtcbiAgICAvKipcbiAgICAgKiBIaW5kaVxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJoaVwiXSA9IFwiaGlcIjtcbiAgICAvKipcbiAgICAgKiBDaGluZXNlXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcInpoXCJdID0gXCJ6aFwiO1xuICAgIC8qKlxuICAgICAqIFBvcnR1Z3Vlc2VcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wicHRcIl0gPSBcInB0XCI7XG4gICAgLyoqXG4gICAgICogU3BhbmlzaFxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJlc1wiXSA9IFwiZXNcIjtcbn0pKEltYWdlUHJvbXB0TGFuZ3VhZ2UgfHwgKEltYWdlUHJvbXB0TGFuZ3VhZ2UgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBtYXNrIG1vZGUgb2YgYSBtYXNrIHJlZmVyZW5jZSBpbWFnZS4gKi9cbnZhciBNYXNrUmVmZXJlbmNlTW9kZTtcbihmdW5jdGlvbiAoTWFza1JlZmVyZW5jZU1vZGUpIHtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9ERUZBVUxUXCJdID0gXCJNQVNLX01PREVfREVGQVVMVFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX1VTRVJfUFJPVklERURcIl0gPSBcIk1BU0tfTU9ERV9VU0VSX1BST1ZJREVEXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfQkFDS0dST1VORFwiXSA9IFwiTUFTS19NT0RFX0JBQ0tHUk9VTkRcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9GT1JFR1JPVU5EXCJdID0gXCJNQVNLX01PREVfRk9SRUdST1VORFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX1NFTUFOVElDXCJdID0gXCJNQVNLX01PREVfU0VNQU5USUNcIjtcbn0pKE1hc2tSZWZlcmVuY2VNb2RlIHx8IChNYXNrUmVmZXJlbmNlTW9kZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIGNvbnRyb2wgdHlwZSBvZiBhIGNvbnRyb2wgcmVmZXJlbmNlIGltYWdlLiAqL1xudmFyIENvbnRyb2xSZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChDb250cm9sUmVmZXJlbmNlVHlwZSkge1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX0RFRkFVTFRcIl0gPSBcIkNPTlRST0xfVFlQRV9ERUZBVUxUXCI7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfQ0FOTllcIl0gPSBcIkNPTlRST0xfVFlQRV9DQU5OWVwiO1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX1NDUklCQkxFXCJdID0gXCJDT05UUk9MX1RZUEVfU0NSSUJCTEVcIjtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9GQUNFX01FU0hcIl0gPSBcIkNPTlRST0xfVFlQRV9GQUNFX01FU0hcIjtcbn0pKENvbnRyb2xSZWZlcmVuY2VUeXBlIHx8IChDb250cm9sUmVmZXJlbmNlVHlwZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIHN1YmplY3QgdHlwZSBvZiBhIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLiAqL1xudmFyIFN1YmplY3RSZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChTdWJqZWN0UmVmZXJlbmNlVHlwZSkge1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX0RFRkFVTFRcIl0gPSBcIlNVQkpFQ1RfVFlQRV9ERUZBVUxUXCI7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfUEVSU09OXCJdID0gXCJTVUJKRUNUX1RZUEVfUEVSU09OXCI7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfQU5JTUFMXCJdID0gXCJTVUJKRUNUX1RZUEVfQU5JTUFMXCI7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfUFJPRFVDVFwiXSA9IFwiU1VCSkVDVF9UWVBFX1BST0RVQ1RcIjtcbn0pKFN1YmplY3RSZWZlcmVuY2VUeXBlIHx8IChTdWJqZWN0UmVmZXJlbmNlVHlwZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIGVkaXRpbmcgbW9kZS4gKi9cbnZhciBFZGl0TW9kZTtcbihmdW5jdGlvbiAoRWRpdE1vZGUpIHtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9ERUZBVUxUXCJdID0gXCJFRElUX01PREVfREVGQVVMVFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0lOUEFJTlRfUkVNT1ZBTFwiXSA9IFwiRURJVF9NT0RFX0lOUEFJTlRfUkVNT1ZBTFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0lOUEFJTlRfSU5TRVJUSU9OXCJdID0gXCJFRElUX01PREVfSU5QQUlOVF9JTlNFUlRJT05cIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9PVVRQQUlOVFwiXSA9IFwiRURJVF9NT0RFX09VVFBBSU5UXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfQ09OVFJPTExFRF9FRElUSU5HXCJdID0gXCJFRElUX01PREVfQ09OVFJPTExFRF9FRElUSU5HXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfU1RZTEVcIl0gPSBcIkVESVRfTU9ERV9TVFlMRVwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0JHU1dBUFwiXSA9IFwiRURJVF9NT0RFX0JHU1dBUFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX1BST0RVQ1RfSU1BR0VcIl0gPSBcIkVESVRfTU9ERV9QUk9EVUNUX0lNQUdFXCI7XG59KShFZGl0TW9kZSB8fCAoRWRpdE1vZGUgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCByZXByZXNlbnRzIHRoZSBzZWdtZW50YXRpb24gbW9kZS4gKi9cbnZhciBTZWdtZW50TW9kZTtcbihmdW5jdGlvbiAoU2VnbWVudE1vZGUpIHtcbiAgICBTZWdtZW50TW9kZVtcIkZPUkVHUk9VTkRcIl0gPSBcIkZPUkVHUk9VTkRcIjtcbiAgICBTZWdtZW50TW9kZVtcIkJBQ0tHUk9VTkRcIl0gPSBcIkJBQ0tHUk9VTkRcIjtcbiAgICBTZWdtZW50TW9kZVtcIlBST01QVFwiXSA9IFwiUFJPTVBUXCI7XG4gICAgU2VnbWVudE1vZGVbXCJTRU1BTlRJQ1wiXSA9IFwiU0VNQU5USUNcIjtcbiAgICBTZWdtZW50TW9kZVtcIklOVEVSQUNUSVZFXCJdID0gXCJJTlRFUkFDVElWRVwiO1xufSkoU2VnbWVudE1vZGUgfHwgKFNlZ21lbnRNb2RlID0ge30pKTtcbi8qKiBFbnVtIGZvciB0aGUgcmVmZXJlbmNlIHR5cGUgb2YgYSB2aWRlbyBnZW5lcmF0aW9uIHJlZmVyZW5jZSBpbWFnZS4gKi9cbnZhciBWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlKSB7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgaW1hZ2UgdGhhdCBwcm92aWRlcyBhc3NldHMgdG8gdGhlIGdlbmVyYXRlZCB2aWRlbyxcbiAgICAgICAgc3VjaCBhcyB0aGUgc2NlbmUsIGFuIG9iamVjdCwgYSBjaGFyYWN0ZXIsIGV0Yy5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlW1wiQVNTRVRcIl0gPSBcIkFTU0VUXCI7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgaW1hZ2UgdGhhdCBwcm92aWRlcyBhZXN0aGV0aWNzIGluY2x1ZGluZyBjb2xvcnMsXG4gICAgICAgIGxpZ2h0aW5nLCB0ZXh0dXJlLCBldGMuLCB0byBiZSB1c2VkIGFzIHRoZSBzdHlsZSBvZiB0aGUgZ2VuZXJhdGVkIHZpZGVvLFxuICAgICAgICBzdWNoIGFzICdhbmltZScsICdwaG90b2dyYXBoeScsICdvcmlnYW1pJywgZXRjLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGVbXCJTVFlMRVwiXSA9IFwiU1RZTEVcIjtcbn0pKFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGUgfHwgKFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGUgPSB7fSkpO1xuLyoqIEVudW0gZm9yIHRoZSBtYXNrIG1vZGUgb2YgYSB2aWRlbyBnZW5lcmF0aW9uIG1hc2suICovXG52YXIgVmlkZW9HZW5lcmF0aW9uTWFza01vZGU7XG4oZnVuY3Rpb24gKFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlIG1hc2sgY29udGFpbnMgYSBtYXNrZWQgcmVjdGFuZ3VsYXIgcmVnaW9uIHdoaWNoIGlzXG4gICAgICAgIGFwcGxpZWQgb24gdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBpbnB1dCB2aWRlby4gVGhlIG9iamVjdCBkZXNjcmliZWQgaW5cbiAgICAgICAgdGhlIHByb21wdCBpcyBpbnNlcnRlZCBpbnRvIHRoaXMgcmVnaW9uIGFuZCB3aWxsIGFwcGVhciBpbiBzdWJzZXF1ZW50XG4gICAgICAgIGZyYW1lcy5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZVtcIklOU0VSVFwiXSA9IFwiSU5TRVJUXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlIG1hc2sgaXMgdXNlZCB0byBkZXRlcm1pbmUgYW4gb2JqZWN0IGluIHRoZVxuICAgICAgICBmaXJzdCB2aWRlbyBmcmFtZSB0byB0cmFjay4gVGhpcyBvYmplY3QgaXMgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlby5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZVtcIlJFTU9WRVwiXSA9IFwiUkVNT1ZFXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlIG1hc2sgaXMgdXNlZCB0byBkZXRlcm1pbmUgYSByZWdpb24gaW4gdGhlXG4gICAgICAgIHZpZGVvLiBPYmplY3RzIGluIHRoaXMgcmVnaW9uIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZVtcIlJFTU9WRV9TVEFUSUNcIl0gPSBcIlJFTU9WRV9TVEFUSUNcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaW1hZ2UgbWFzayBjb250YWlucyBhIG1hc2tlZCByZWN0YW5ndWxhciByZWdpb24gd2hlcmVcbiAgICAgICAgdGhlIGlucHV0IHZpZGVvIHdpbGwgZ28uIFRoZSByZW1haW5pbmcgYXJlYSB3aWxsIGJlIGdlbmVyYXRlZC4gVmlkZW9cbiAgICAgICAgbWFza3MgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uTWFza01vZGVbXCJPVVRQQUlOVFwiXSA9IFwiT1VUUEFJTlRcIjtcbn0pKFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlIHx8IChWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSA9IHt9KSk7XG4vKiogRW51bSB0aGF0IGNvbnRyb2xzIHRoZSBjb21wcmVzc2lvbiBxdWFsaXR5IG9mIHRoZSBnZW5lcmF0ZWQgdmlkZW9zLiAqL1xudmFyIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5O1xuKGZ1bmN0aW9uIChWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSkge1xuICAgIC8qKlxuICAgICAqIE9wdGltaXplZCB2aWRlbyBjb21wcmVzc2lvbiBxdWFsaXR5LiBUaGlzIHdpbGwgcHJvZHVjZSB2aWRlb3NcbiAgICAgICAgd2l0aCBhIGNvbXByZXNzZWQsIHNtYWxsZXIgZmlsZSBzaXplLlxuICAgICAqL1xuICAgIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5W1wiT1BUSU1JWkVEXCJdID0gXCJPUFRJTUlaRURcIjtcbiAgICAvKipcbiAgICAgKiBMb3NzbGVzcyB2aWRlbyBjb21wcmVzc2lvbiBxdWFsaXR5LiBUaGlzIHdpbGwgcHJvZHVjZSB2aWRlb3NcbiAgICAgICAgd2l0aCBhIGxhcmdlciBmaWxlIHNpemUuXG4gICAgICovXG4gICAgVmlkZW9Db21wcmVzc2lvblF1YWxpdHlbXCJMT1NTTEVTU1wiXSA9IFwiTE9TU0xFU1NcIjtcbn0pKFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5IHx8IChWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSA9IHt9KSk7XG4vKiogU3RhdGUgZm9yIHRoZSBsaWZlY3ljbGUgb2YgYSBGaWxlLiAqL1xudmFyIEZpbGVTdGF0ZTtcbihmdW5jdGlvbiAoRmlsZVN0YXRlKSB7XG4gICAgRmlsZVN0YXRlW1wiU1RBVEVfVU5TUEVDSUZJRURcIl0gPSBcIlNUQVRFX1VOU1BFQ0lGSUVEXCI7XG4gICAgRmlsZVN0YXRlW1wiUFJPQ0VTU0lOR1wiXSA9IFwiUFJPQ0VTU0lOR1wiO1xuICAgIEZpbGVTdGF0ZVtcIkFDVElWRVwiXSA9IFwiQUNUSVZFXCI7XG4gICAgRmlsZVN0YXRlW1wiRkFJTEVEXCJdID0gXCJGQUlMRURcIjtcbn0pKEZpbGVTdGF0ZSB8fCAoRmlsZVN0YXRlID0ge30pKTtcbi8qKiBTb3VyY2Ugb2YgdGhlIEZpbGUuICovXG52YXIgRmlsZVNvdXJjZTtcbihmdW5jdGlvbiAoRmlsZVNvdXJjZSkge1xuICAgIEZpbGVTb3VyY2VbXCJTT1VSQ0VfVU5TUEVDSUZJRURcIl0gPSBcIlNPVVJDRV9VTlNQRUNJRklFRFwiO1xuICAgIEZpbGVTb3VyY2VbXCJVUExPQURFRFwiXSA9IFwiVVBMT0FERURcIjtcbiAgICBGaWxlU291cmNlW1wiR0VORVJBVEVEXCJdID0gXCJHRU5FUkFURURcIjtcbn0pKEZpbGVTb3VyY2UgfHwgKEZpbGVTb3VyY2UgPSB7fSkpO1xuLyoqIFRoZSByZWFzb24gd2h5IHRoZSB0dXJuIGlzIGNvbXBsZXRlLiAqL1xudmFyIFR1cm5Db21wbGV0ZVJlYXNvbjtcbihmdW5jdGlvbiAoVHVybkNvbXBsZXRlUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZS4gUmVhc29uIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIFR1cm5Db21wbGV0ZVJlYXNvbltcIlRVUk5fQ09NUExFVEVfUkVBU09OX1VOU1BFQ0lGSUVEXCJdID0gXCJUVVJOX0NPTVBMRVRFX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBUdXJuQ29tcGxldGVSZWFzb25bXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiXSA9IFwiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVzcG9uc2UgaXMgcmVqZWN0ZWQgYnkgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIFR1cm5Db21wbGV0ZVJlYXNvbltcIlJFU1BPTlNFX1JFSkVDVEVEXCJdID0gXCJSRVNQT05TRV9SRUpFQ1RFRFwiO1xuICAgIC8qKlxuICAgICAqIE5lZWRzIG1vcmUgaW5wdXQgZnJvbSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBUdXJuQ29tcGxldGVSZWFzb25bXCJORUVEX01PUkVfSU5QVVRcIl0gPSBcIk5FRURfTU9SRV9JTlBVVFwiO1xufSkoVHVybkNvbXBsZXRlUmVhc29uIHx8IChUdXJuQ29tcGxldGVSZWFzb24gPSB7fSkpO1xuLyoqIFNlcnZlciBjb250ZW50IG1vZGFsaXRpZXMuICovXG52YXIgTWVkaWFNb2RhbGl0eTtcbihmdW5jdGlvbiAoTWVkaWFNb2RhbGl0eSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RhbGl0eSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiTU9EQUxJVFlfVU5TUEVDSUZJRURcIl0gPSBcIk1PREFMSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogUGxhaW4gdGV4dC5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiVEVYVFwiXSA9IFwiVEVYVFwiO1xuICAgIC8qKlxuICAgICAqIEltYWdlcy5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiSU1BR0VcIl0gPSBcIklNQUdFXCI7XG4gICAgLyoqXG4gICAgICogVmlkZW8uXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIlZJREVPXCJdID0gXCJWSURFT1wiO1xuICAgIC8qKlxuICAgICAqIEF1ZGlvLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJBVURJT1wiXSA9IFwiQVVESU9cIjtcbiAgICAvKipcbiAgICAgKiBEb2N1bWVudCwgZS5nLiBQREYuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIkRPQ1VNRU5UXCJdID0gXCJET0NVTUVOVFwiO1xufSkoTWVkaWFNb2RhbGl0eSB8fCAoTWVkaWFNb2RhbGl0eSA9IHt9KSk7XG4vKiogU3RhcnQgb2Ygc3BlZWNoIHNlbnNpdGl2aXR5LiAqL1xudmFyIFN0YXJ0U2Vuc2l0aXZpdHk7XG4oZnVuY3Rpb24gKFN0YXJ0U2Vuc2l0aXZpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBTVEFSVF9TRU5TSVRJVklUWV9MT1cuXG4gICAgICovXG4gICAgU3RhcnRTZW5zaXRpdml0eVtcIlNUQVJUX1NFTlNJVElWSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJTVEFSVF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IG9mIHNwZWVjaCBtb3JlIG9mdGVuLlxuICAgICAqL1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9ISUdIXCJdID0gXCJTVEFSVF9TRU5TSVRJVklUWV9ISUdIXCI7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGRldGVjdGlvbiB3aWxsIGRldGVjdCB0aGUgc3RhcnQgb2Ygc3BlZWNoIGxlc3Mgb2Z0ZW4uXG4gICAgICovXG4gICAgU3RhcnRTZW5zaXRpdml0eVtcIlNUQVJUX1NFTlNJVElWSVRZX0xPV1wiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfTE9XXCI7XG59KShTdGFydFNlbnNpdGl2aXR5IHx8IChTdGFydFNlbnNpdGl2aXR5ID0ge30pKTtcbi8qKiBFbmQgb2Ygc3BlZWNoIHNlbnNpdGl2aXR5LiAqL1xudmFyIEVuZFNlbnNpdGl2aXR5O1xuKGZ1bmN0aW9uIChFbmRTZW5zaXRpdml0eSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGlzIEVORF9TRU5TSVRJVklUWV9MT1cuXG4gICAgICovXG4gICAgRW5kU2Vuc2l0aXZpdHlbXCJFTkRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIl0gPSBcIkVORF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gZW5kcyBzcGVlY2ggbW9yZSBvZnRlbi5cbiAgICAgKi9cbiAgICBFbmRTZW5zaXRpdml0eVtcIkVORF9TRU5TSVRJVklUWV9ISUdIXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfSElHSFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gZW5kcyBzcGVlY2ggbGVzcyBvZnRlbi5cbiAgICAgKi9cbiAgICBFbmRTZW5zaXRpdml0eVtcIkVORF9TRU5TSVRJVklUWV9MT1dcIl0gPSBcIkVORF9TRU5TSVRJVklUWV9MT1dcIjtcbn0pKEVuZFNlbnNpdGl2aXR5IHx8IChFbmRTZW5zaXRpdml0eSA9IHt9KSk7XG4vKiogVGhlIGRpZmZlcmVudCB3YXlzIG9mIGhhbmRsaW5nIHVzZXIgYWN0aXZpdHkuICovXG52YXIgQWN0aXZpdHlIYW5kbGluZztcbihmdW5jdGlvbiAoQWN0aXZpdHlIYW5kbGluZykge1xuICAgIC8qKlxuICAgICAqIElmIHVuc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBgU1RBUlRfT0ZfQUNUSVZJVFlfSU5URVJSVVBUU2AuXG4gICAgICovXG4gICAgQWN0aXZpdHlIYW5kbGluZ1tcIkFDVElWSVRZX0hBTkRMSU5HX1VOU1BFQ0lGSUVEXCJdID0gXCJBQ1RJVklUWV9IQU5ETElOR19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHN0YXJ0IG9mIGFjdGl2aXR5IHdpbGwgaW50ZXJydXB0IHRoZSBtb2RlbCdzIHJlc3BvbnNlIChhbHNvIGNhbGxlZCBcImJhcmdlIGluXCIpLiBUaGUgbW9kZWwncyBjdXJyZW50IHJlc3BvbnNlIHdpbGwgYmUgY3V0LW9mZiBpbiB0aGUgbW9tZW50IG9mIHRoZSBpbnRlcnJ1cHRpb24uIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICovXG4gICAgQWN0aXZpdHlIYW5kbGluZ1tcIlNUQVJUX09GX0FDVElWSVRZX0lOVEVSUlVQVFNcIl0gPSBcIlNUQVJUX09GX0FDVElWSVRZX0lOVEVSUlVQVFNcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwncyByZXNwb25zZSB3aWxsIG5vdCBiZSBpbnRlcnJ1cHRlZC5cbiAgICAgKi9cbiAgICBBY3Rpdml0eUhhbmRsaW5nW1wiTk9fSU5URVJSVVBUSU9OXCJdID0gXCJOT19JTlRFUlJVUFRJT05cIjtcbn0pKEFjdGl2aXR5SGFuZGxpbmcgfHwgKEFjdGl2aXR5SGFuZGxpbmcgPSB7fSkpO1xuLyoqIE9wdGlvbnMgYWJvdXQgd2hpY2ggaW5wdXQgaXMgaW5jbHVkZWQgaW4gdGhlIHVzZXIncyB0dXJuLiAqL1xudmFyIFR1cm5Db3ZlcmFnZTtcbihmdW5jdGlvbiAoVHVybkNvdmVyYWdlKSB7XG4gICAgLyoqXG4gICAgICogSWYgdW5zcGVjaWZpZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIGBUVVJOX0lOQ0xVREVTX09OTFlfQUNUSVZJVFlgLlxuICAgICAqL1xuICAgIFR1cm5Db3ZlcmFnZVtcIlRVUk5fQ09WRVJBR0VfVU5TUEVDSUZJRURcIl0gPSBcIlRVUk5fQ09WRVJBR0VfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdXNlcnMgdHVybiBvbmx5IGluY2x1ZGVzIGFjdGl2aXR5IHNpbmNlIHRoZSBsYXN0IHR1cm4sIGV4Y2x1ZGluZyBpbmFjdGl2aXR5IChlLmcuIHNpbGVuY2Ugb24gdGhlIGF1ZGlvIHN0cmVhbSkuIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICovXG4gICAgVHVybkNvdmVyYWdlW1wiVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZXCJdID0gXCJUVVJOX0lOQ0xVREVTX09OTFlfQUNUSVZJVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdXNlcnMgdHVybiBpbmNsdWRlcyBhbGwgcmVhbHRpbWUgaW5wdXQgc2luY2UgdGhlIGxhc3QgdHVybiwgaW5jbHVkaW5nIGluYWN0aXZpdHkgKGUuZy4gc2lsZW5jZSBvbiB0aGUgYXVkaW8gc3RyZWFtKS5cbiAgICAgKi9cbiAgICBUdXJuQ292ZXJhZ2VbXCJUVVJOX0lOQ0xVREVTX0FMTF9JTlBVVFwiXSA9IFwiVFVSTl9JTkNMVURFU19BTExfSU5QVVRcIjtcbn0pKFR1cm5Db3ZlcmFnZSB8fCAoVHVybkNvdmVyYWdlID0ge30pKTtcbi8qKiBTcGVjaWZpZXMgaG93IHRoZSByZXNwb25zZSBzaG91bGQgYmUgc2NoZWR1bGVkIGluIHRoZSBjb252ZXJzYXRpb24uICovXG52YXIgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmc7XG4oZnVuY3Rpb24gKEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmdbXCJTQ0hFRFVMSU5HX1VOU1BFQ0lGSUVEXCJdID0gXCJTQ0hFRFVMSU5HX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogT25seSBhZGQgdGhlIHJlc3VsdCB0byB0aGUgY29udmVyc2F0aW9uIGNvbnRleHQsIGRvIG5vdCBpbnRlcnJ1cHQgb3IgdHJpZ2dlciBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiU0lMRU5UXCJdID0gXCJTSUxFTlRcIjtcbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHJlc3VsdCB0byB0aGUgY29udmVyc2F0aW9uIGNvbnRleHQsIGFuZCBwcm9tcHQgdG8gZ2VuZXJhdGUgb3V0cHV0IHdpdGhvdXQgaW50ZXJydXB0aW5nIG9uZ29pbmcgZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZ1tcIldIRU5fSURMRVwiXSA9IFwiV0hFTl9JRExFXCI7XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSByZXN1bHQgdG8gdGhlIGNvbnZlcnNhdGlvbiBjb250ZXh0LCBpbnRlcnJ1cHQgb25nb2luZyBnZW5lcmF0aW9uIGFuZCBwcm9tcHQgdG8gZ2VuZXJhdGUgb3V0cHV0LlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiSU5URVJSVVBUXCJdID0gXCJJTlRFUlJVUFRcIjtcbn0pKEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nIHx8IChGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZyA9IHt9KSk7XG4vKiogU2NhbGUgb2YgdGhlIGdlbmVyYXRlZCBtdXNpYy4gKi9cbnZhciBTY2FsZTtcbihmdW5jdGlvbiAoU2NhbGUpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBTY2FsZVtcIlNDQUxFX1VOU1BFQ0lGSUVEXCJdID0gXCJTQ0FMRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEMgbWFqb3Igb3IgQSBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkNfTUFKT1JfQV9NSU5PUlwiXSA9IFwiQ19NQUpPUl9BX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRGIgbWFqb3Igb3IgQmIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJEX0ZMQVRfTUFKT1JfQl9GTEFUX01JTk9SXCJdID0gXCJEX0ZMQVRfTUFKT1JfQl9GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRCBtYWpvciBvciBCIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRF9NQUpPUl9CX01JTk9SXCJdID0gXCJEX01BSk9SX0JfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBFYiBtYWpvciBvciBDIG1pbm9yXG4gICAgICovXG4gICAgU2NhbGVbXCJFX0ZMQVRfTUFKT1JfQ19NSU5PUlwiXSA9IFwiRV9GTEFUX01BSk9SX0NfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBFIG1ham9yIG9yIERiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRV9NQUpPUl9EX0ZMQVRfTUlOT1JcIl0gPSBcIkVfTUFKT1JfRF9GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRiBtYWpvciBvciBEIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRl9NQUpPUl9EX01JTk9SXCJdID0gXCJGX01BSk9SX0RfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBHYiBtYWpvciBvciBFYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkdfRkxBVF9NQUpPUl9FX0ZMQVRfTUlOT1JcIl0gPSBcIkdfRkxBVF9NQUpPUl9FX0ZMQVRfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBHIG1ham9yIG9yIEUgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJHX01BSk9SX0VfTUlOT1JcIl0gPSBcIkdfTUFKT1JfRV9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEFiIG1ham9yIG9yIEYgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJBX0ZMQVRfTUFKT1JfRl9NSU5PUlwiXSA9IFwiQV9GTEFUX01BSk9SX0ZfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBBIG1ham9yIG9yIEdiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQV9NQUpPUl9HX0ZMQVRfTUlOT1JcIl0gPSBcIkFfTUFKT1JfR19GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogQmIgbWFqb3Igb3IgRyBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkJfRkxBVF9NQUpPUl9HX01JTk9SXCJdID0gXCJCX0ZMQVRfTUFKT1JfR19NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEIgbWFqb3Igb3IgQWIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJCX01BSk9SX0FfRkxBVF9NSU5PUlwiXSA9IFwiQl9NQUpPUl9BX0ZMQVRfTUlOT1JcIjtcbn0pKFNjYWxlIHx8IChTY2FsZSA9IHt9KSk7XG4vKiogVGhlIG1vZGUgb2YgbXVzaWMgZ2VuZXJhdGlvbi4gKi9cbnZhciBNdXNpY0dlbmVyYXRpb25Nb2RlO1xuKGZ1bmN0aW9uIChNdXNpY0dlbmVyYXRpb25Nb2RlKSB7XG4gICAgLyoqXG4gICAgICogUmVseSBvbiB0aGUgc2VydmVyIGRlZmF1bHQgZ2VuZXJhdGlvbiBtb2RlLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJNVVNJQ19HRU5FUkFUSU9OX01PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1VU0lDX0dFTkVSQVRJT05fTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFN0ZWVyIHRleHQgcHJvbXB0cyB0byByZWdpb25zIG9mIGxhdGVudCBzcGFjZSB3aXRoIGhpZ2hlciBxdWFsaXR5XG4gICAgICAgIG11c2ljLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJRVUFMSVRZXCJdID0gXCJRVUFMSVRZXCI7XG4gICAgLyoqXG4gICAgICogU3RlZXIgdGV4dCBwcm9tcHRzIHRvIHJlZ2lvbnMgb2YgbGF0ZW50IHNwYWNlIHdpdGggYSBsYXJnZXJcbiAgICAgICAgZGl2ZXJzaXR5IG9mIG11c2ljLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJESVZFUlNJVFlcIl0gPSBcIkRJVkVSU0lUWVwiO1xuICAgIC8qKlxuICAgICAqIFN0ZWVyIHRleHQgcHJvbXB0cyB0byByZWdpb25zIG9mIGxhdGVudCBzcGFjZSBtb3JlIGxpa2VseSB0b1xuICAgICAgICBnZW5lcmF0ZSBtdXNpYyB3aXRoIHZvY2Fscy5cbiAgICAgKi9cbiAgICBNdXNpY0dlbmVyYXRpb25Nb2RlW1wiVk9DQUxJWkFUSU9OXCJdID0gXCJWT0NBTElaQVRJT05cIjtcbn0pKE11c2ljR2VuZXJhdGlvbk1vZGUgfHwgKE11c2ljR2VuZXJhdGlvbk1vZGUgPSB7fSkpO1xuLyoqIFRoZSBwbGF5YmFjayBjb250cm9sIHNpZ25hbCB0byBhcHBseSB0byB0aGUgbXVzaWMgZ2VuZXJhdGlvbi4gKi9cbnZhciBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2w7XG4oZnVuY3Rpb24gKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlBMQVlCQUNLX0NPTlRST0xfVU5TUEVDSUZJRURcIl0gPSBcIlBMQVlCQUNLX0NPTlRST0xfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBTdGFydCBnZW5lcmF0aW5nIHRoZSBtdXNpYy5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJQTEFZXCJdID0gXCJQTEFZXCI7XG4gICAgLyoqXG4gICAgICogSG9sZCB0aGUgbXVzaWMgZ2VuZXJhdGlvbi4gVXNlIFBMQVkgdG8gcmVzdW1lIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiUEFVU0VcIl0gPSBcIlBBVVNFXCI7XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgbXVzaWMgZ2VuZXJhdGlvbiBhbmQgcmVzZXQgdGhlIGNvbnRleHQgKHByb21wdHMgcmV0YWluZWQpLlxuICAgICAgICBVc2UgUExBWSB0byByZXN0YXJ0IHRoZSBtdXNpYyBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlNUT1BcIl0gPSBcIlNUT1BcIjtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgY29udGV4dCBvZiB0aGUgbXVzaWMgZ2VuZXJhdGlvbiB3aXRob3V0IHN0b3BwaW5nIGl0LlxuICAgICAgICBSZXRhaW5zIHRoZSBjdXJyZW50IHByb21wdHMgYW5kIGNvbmZpZy5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJSRVNFVF9DT05URVhUXCJdID0gXCJSRVNFVF9DT05URVhUXCI7XG59KShMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wgfHwgKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCA9IHt9KSk7XG4vKiogUmF3IG1lZGlhIGJ5dGVzIGZvciBmdW5jdGlvbiByZXNwb25zZS5cblxuICBUZXh0IHNob3VsZCBub3QgYmUgc2VudCBhcyByYXcgYnl0ZXMsIHVzZSB0aGUgRnVuY3Rpb25SZXNwb25zZS5yZXNwb25zZVxuICBmaWVsZC5cbiAgICovXG5jbGFzcyBGdW5jdGlvblJlc3BvbnNlQmxvYiB7XG59XG4vKiogVVJJIGJhc2VkIGRhdGEgZm9yIGZ1bmN0aW9uIHJlc3BvbnNlLiAqL1xuY2xhc3MgRnVuY3Rpb25SZXNwb25zZUZpbGVEYXRhIHtcbn1cbi8qKiBBIGRhdGF0eXBlIGNvbnRhaW5pbmcgbWVkaWEgdGhhdCBpcyBwYXJ0IG9mIGEgYEZ1bmN0aW9uUmVzcG9uc2VgIG1lc3NhZ2UuXG5cbiAgQSBgRnVuY3Rpb25SZXNwb25zZVBhcnRgIGNvbnNpc3RzIG9mIGRhdGEgd2hpY2ggaGFzIGFuIGFzc29jaWF0ZWQgZGF0YXR5cGUuIEFcbiAgYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0YCBjYW4gb25seSBjb250YWluIG9uZSBvZiB0aGUgYWNjZXB0ZWQgdHlwZXMgaW5cbiAgYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0LmRhdGFgLlxuXG4gIEEgYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0YCBtdXN0IGhhdmUgYSBmaXhlZCBJQU5BIE1JTUUgdHlwZSBpZGVudGlmeWluZyB0aGVcbiAgdHlwZSBhbmQgc3VidHlwZSBvZiB0aGUgbWVkaWEgaWYgdGhlIGBpbmxpbmVfZGF0YWAgZmllbGQgaXMgZmlsbGVkIHdpdGggcmF3XG4gIGJ5dGVzLlxuICAgKi9cbmNsYXNzIEZ1bmN0aW9uUmVzcG9uc2VQYXJ0IHtcbn1cbi8qKiBBIGZ1bmN0aW9uIHJlc3BvbnNlLiAqL1xuY2xhc3MgRnVuY3Rpb25SZXNwb25zZSB7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgVVJJYCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tVXJpKHVyaSwgbWltZVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWxlRGF0YToge1xuICAgICAgICAgICAgZmlsZVVyaTogdXJpLFxuICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgdGV4dGAgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbVRleHQodGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBGdW5jdGlvbkNhbGxgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21GdW5jdGlvbkNhbGwobmFtZSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZ1bmN0aW9uQ2FsbDoge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBGdW5jdGlvblJlc3BvbnNlYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25SZXNwb25zZShpZCwgbmFtZSwgcmVzcG9uc2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmdW5jdGlvblJlc3BvbnNlOiB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgYmFzZTY0YCBlbmNvZGVkIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUJhc2U2NChkYXRhLCBtaW1lVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlubGluZURhdGE6IHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSB0aGUgYG91dGNvbWVgIGFuZCBgb3V0cHV0YCBvZiBhIGBDb2RlRXhlY3V0aW9uUmVzdWx0YCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tQ29kZUV4ZWN1dGlvblJlc3VsdChvdXRjb21lLCBvdXRwdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlRXhlY3V0aW9uUmVzdWx0OiB7XG4gICAgICAgICAgICBvdXRjb21lOiBvdXRjb21lLFxuICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSB0aGUgYGNvZGVgIGFuZCBgbGFuZ3VhZ2VgIG9mIGFuIGBFeGVjdXRhYmxlQ29kZWAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUV4ZWN1dGFibGVDb2RlKGNvZGUsIGxhbmd1YWdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXhlY3V0YWJsZUNvZGU6IHtcbiAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9pc1BhcnQob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gKCdmaWxlRGF0YScgaW4gb2JqIHx8XG4gICAgICAgICAgICAndGV4dCcgaW4gb2JqIHx8XG4gICAgICAgICAgICAnZnVuY3Rpb25DYWxsJyBpbiBvYmogfHxcbiAgICAgICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyBpbiBvYmogfHxcbiAgICAgICAgICAgICdpbmxpbmVEYXRhJyBpbiBvYmogfHxcbiAgICAgICAgICAgICd2aWRlb01ldGFkYXRhJyBpbiBvYmogfHxcbiAgICAgICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyBpbiBvYmogfHxcbiAgICAgICAgICAgICdleGVjdXRhYmxlQ29kZScgaW4gb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gX3RvUGFydHMocGFydE9yU3RyaW5nKSB7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBpZiAodHlwZW9mIHBhcnRPclN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFydHMucHVzaChjcmVhdGVQYXJ0RnJvbVRleHQocGFydE9yU3RyaW5nKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc1BhcnQocGFydE9yU3RyaW5nKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhcnRPclN0cmluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFydE9yU3RyaW5nKSkge1xuICAgICAgICBpZiAocGFydE9yU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0T3JTdHJpbmcgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRPclN0cmluZykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goY3JlYXRlUGFydEZyb21UZXh0KHBhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF9pc1BhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IGluIFBhcnRVbmlvbiBtdXN0IGJlIGEgUGFydCBvYmplY3Qgb3Igc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydE9yU3RyaW5nIG11c3QgYmUgYSBQYXJ0IG9iamVjdCwgc3RyaW5nLCBvciBhcnJheScpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgQ29udGVudGAgb2JqZWN0IHdpdGggYSB1c2VyIHJvbGUgZnJvbSBhIGBQYXJ0TGlzdFVuaW9uYCBvYmplY3Qgb3IgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVzZXJDb250ZW50KHBhcnRPclN0cmluZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgcGFydHM6IF90b1BhcnRzKHBhcnRPclN0cmluZyksXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBDb250ZW50YCBvYmplY3Qgd2l0aCBhIG1vZGVsIHJvbGUgZnJvbSBhIGBQYXJ0TGlzdFVuaW9uYCBvYmplY3Qgb3IgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vZGVsQ29udGVudChwYXJ0T3JTdHJpbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAnbW9kZWwnLFxuICAgICAgICBwYXJ0czogX3RvUGFydHMocGFydE9yU3RyaW5nKSxcbiAgICB9O1xufVxuLyoqIEEgd3JhcHBlciBjbGFzcyBmb3IgdGhlIGh0dHAgcmVzcG9uc2UuICovXG5jbGFzcyBIdHRwUmVzcG9uc2Uge1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGhlYWRlcnMuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHJlc3BvbnNlLmhlYWRlcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBoZWFkZXJzW3BhaXJbMF1dID0gcGFpclsxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAvLyBLZWVwIHRoZSBvcmlnaW5hbCByZXNwb25zZS5cbiAgICAgICAgdGhpcy5yZXNwb25zZUludGVybmFsID0gcmVzcG9uc2U7XG4gICAgfVxuICAgIGpzb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlSW50ZXJuYWwuanNvbigpO1xuICAgIH1cbn1cbi8qKiBDb250ZW50IGZpbHRlciByZXN1bHRzIGZvciBhIHByb21wdCBzZW50IGluIHRoZSByZXF1ZXN0LiAqL1xuY2xhc3MgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VQcm9tcHRGZWVkYmFjayB7XG59XG4vKiogVXNhZ2UgbWV0YWRhdGEgYWJvdXQgcmVzcG9uc2UocykuICovXG5jbGFzcyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVVzYWdlTWV0YWRhdGEge1xufVxuLyoqIFJlc3BvbnNlIG1lc3NhZ2UgZm9yIFByZWRpY3Rpb25TZXJ2aWNlLkdlbmVyYXRlQ29udGVudC4gKi9cbmNsYXNzIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIHRleHQgZnJvbSB0aGUgZmlyc3RcbiAgICAgKiBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm9uLXRleHQgcGFydHMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dFxuICAgICAqIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZCBhIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIHRob3VnaHQgcGFydHMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dFxuICAgICAqIHBhcnRzIGV4Y2x1ZGluZyB0aGUgdGhvdWdodCBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaHkgaXMgdGhlIHNreSBibHVlPycsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmRlYnVnKHJlc3BvbnNlLnRleHQpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIHRleHQgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGxldCBhbnlUZXh0UGFydFRleHQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9uVGV4dFBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSAndGV4dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lICE9PSAndGhvdWdodCcgJiZcbiAgICAgICAgICAgICAgICAgICAgKGZpZWxkVmFsdWUgIT09IG51bGwgfHwgZmllbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICBub25UZXh0UGFydHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50aG91Z2h0ID09PSAnYm9vbGVhbicgJiYgcGFydC50aG91Z2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlUZXh0UGFydFRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25UZXh0UGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLXRleHQgcGFydHMgJHtub25UZXh0UGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIHRleHQgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhcnQudGV4dCA9PT0gJycgaXMgZGlmZmVyZW50IGZyb20gcGFydC50ZXh0IGlzIG51bGxcbiAgICAgICAgcmV0dXJuIGFueVRleHRQYXJ0VGV4dCA/IHRleHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZVxuICAgICAqIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgaW5saW5lIGRhdGEgZnJvbSB0aGVcbiAgICAgKiBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC4gSWYgdGhlcmUgYXJlIG5vbi1pbmxpbmUgZGF0YSBwYXJ0cyBpbiB0aGVcbiAgICAgKiByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZFxuICAgICAqIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBkYXRhIGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9ICcnO1xuICAgICAgICBjb25zdCBub25EYXRhUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICdpbmxpbmVEYXRhJyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmllbGRWYWx1ZSAhPT0gbnVsbCB8fCBmaWVsZFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vbkRhdGFQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnQuaW5saW5lRGF0YSAmJiB0eXBlb2YgcGFydC5pbmxpbmVEYXRhLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSArPSBhdG9iKHBhcnQuaW5saW5lRGF0YS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uRGF0YVBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi1kYXRhIHBhcnRzICR7bm9uRGF0YVBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCBkYXRhIHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiBkYXRhIHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGggPiAwID8gYnRvYShkYXRhKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZnVuY3Rpb24gY2FsbHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgZnVuY3Rpb24gY2FsbHMgZnJvbVxuICAgICAqIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gZnVuY3Rpb24gY2FsbHMgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb250cm9sTGlnaHRGdW5jdGlvbkRlY2xhcmF0aW9uOiBGdW5jdGlvbkRlY2xhcmF0aW9uID0ge1xuICAgICAqICAgbmFtZTogJ2NvbnRyb2xMaWdodCcsXG4gICAgICogICBwYXJhbWV0ZXJzOiB7XG4gICAgICogICB0eXBlOiBUeXBlLk9CSkVDVCxcbiAgICAgKiAgIGRlc2NyaXB0aW9uOiAnU2V0IHRoZSBicmlnaHRuZXNzIGFuZCBjb2xvciB0ZW1wZXJhdHVyZSBvZiBhIHJvb20gbGlnaHQuJyxcbiAgICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICAgKiAgICAgYnJpZ2h0bmVzczoge1xuICAgICAqICAgICAgIHR5cGU6IFR5cGUuTlVNQkVSLFxuICAgICAqICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAqICAgICAgICAgJ0xpZ2h0IGxldmVsIGZyb20gMCB0byAxMDAuIFplcm8gaXMgb2ZmIGFuZCAxMDAgaXMgZnVsbCBicmlnaHRuZXNzLicsXG4gICAgICogICAgIH0sXG4gICAgICogICAgIGNvbG9yVGVtcGVyYXR1cmU6IHtcbiAgICAgKiAgICAgICB0eXBlOiBUeXBlLlNUUklORyxcbiAgICAgKiAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgKiAgICAgICAgICdDb2xvciB0ZW1wZXJhdHVyZSBvZiB0aGUgbGlnaHQgZml4dHVyZSB3aGljaCBjYW4gYmUgYGRheWxpZ2h0YCwgYGNvb2xgIG9yIGB3YXJtYC4nLFxuICAgICAqICAgICB9LFxuICAgICAqICAgfSxcbiAgICAgKiAgIHJlcXVpcmVkOiBbJ2JyaWdodG5lc3MnLCAnY29sb3JUZW1wZXJhdHVyZSddLFxuICAgICAqICB9O1xuICAgICAqICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgICBjb250ZW50czogJ0RpbSB0aGUgbGlnaHRzIHNvIHRoZSByb29tIGZlZWxzIGNvenkgYW5kIHdhcm0uJyxcbiAgICAgKiAgICAgY29uZmlnOiB7XG4gICAgICogICAgICAgdG9vbHM6IFt7ZnVuY3Rpb25EZWNsYXJhdGlvbnM6IFtjb250cm9sTGlnaHRGdW5jdGlvbkRlY2xhcmF0aW9uXX1dLFxuICAgICAqICAgICAgIHRvb2xDb25maWc6IHtcbiAgICAgKiAgICAgICAgIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZzoge1xuICAgICAqICAgICAgICAgICBtb2RlOiBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlLkFOWSxcbiAgICAgKiAgICAgICAgICAgYWxsb3dlZEZ1bmN0aW9uTmFtZXM6IFsnY29udHJvbExpZ2h0J10sXG4gICAgICogICAgICAgICB9LFxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgIH0sXG4gICAgICogICB9KTtcbiAgICAgKiAgY29uc29sZS5kZWJ1ZyhKU09OLnN0cmluZ2lmeShyZXNwb25zZS5mdW5jdGlvbkNhbGxzKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGZ1bmN0aW9uQ2FsbHMoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgZnVuY3Rpb24gY2FsbHMgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbHMgPSAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmZpbHRlcigocGFydCkgPT4gcGFydC5mdW5jdGlvbkNhbGwpLm1hcCgocGFydCkgPT4gcGFydC5mdW5jdGlvbkNhbGwpLmZpbHRlcigoZnVuY3Rpb25DYWxsKSA9PiBmdW5jdGlvbkNhbGwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICgoZnVuY3Rpb25DYWxscyA9PT0gbnVsbCB8fCBmdW5jdGlvbkNhbGxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmdW5jdGlvbkNhbGxzLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQ2FsbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGV4ZWN1dGFibGUgY29kZSBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGUgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBleGVjdXRhYmxlIGNvZGUgZnJvbVxuICAgICAqIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gZXhlY3V0YWJsZSBjb2RlIGluIHRoZSByZXNwb25zZSwgdW5kZWZpbmVkIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgIGNvbnRlbnRzOlxuICAgICAqICAgICAnV2hhdCBpcyB0aGUgc3VtIG9mIHRoZSBmaXJzdCA1MCBwcmltZSBudW1iZXJzPyBHZW5lcmF0ZSBhbmQgcnVuIGNvZGUgZm9yIHRoZSBjYWxjdWxhdGlvbiwgYW5kIG1ha2Ugc3VyZSB5b3UgZ2V0IGFsbCA1MC4nXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgdG9vbHM6IFt7Y29kZUV4ZWN1dGlvbjoge319XSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmRlYnVnKHJlc3BvbnNlLmV4ZWN1dGFibGVDb2RlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZXhlY3V0YWJsZUNvZGUoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGV4ZWN1dGFibGUgY29kZSBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhlY3V0YWJsZUNvZGUgPSAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmZpbHRlcigocGFydCkgPT4gcGFydC5leGVjdXRhYmxlQ29kZSkubWFwKChwYXJ0KSA9PiBwYXJ0LmV4ZWN1dGFibGVDb2RlKS5maWx0ZXIoKGV4ZWN1dGFibGVDb2RlKSA9PiBleGVjdXRhYmxlQ29kZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKChleGVjdXRhYmxlQ29kZSA9PT0gbnVsbCB8fCBleGVjdXRhYmxlQ29kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhlY3V0YWJsZUNvZGUubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9qID0gZXhlY3V0YWJsZUNvZGUgPT09IG51bGwgfHwgZXhlY3V0YWJsZUNvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4ZWN1dGFibGVDb2RlWzBdKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouY29kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgY29kZSBleGVjdXRpb24gcmVzdWx0IGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgIGNvbnRlbnRzOlxuICAgICAqICAgICAnV2hhdCBpcyB0aGUgc3VtIG9mIHRoZSBmaXJzdCA1MCBwcmltZSBudW1iZXJzPyBHZW5lcmF0ZSBhbmQgcnVuIGNvZGUgZm9yIHRoZSBjYWxjdWxhdGlvbiwgYW5kIG1ha2Ugc3VyZSB5b3UgZ2V0IGFsbCA1MC4nXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgdG9vbHM6IFt7Y29kZUV4ZWN1dGlvbjoge319XSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmRlYnVnKHJlc3BvbnNlLmNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBjb2RlRXhlY3V0aW9uUmVzdWx0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVFeGVjdXRpb25SZXN1bHQgPSAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmZpbHRlcigocGFydCkgPT4gcGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0KS5tYXAoKHBhcnQpID0+IHBhcnQuY29kZUV4ZWN1dGlvblJlc3VsdCkuZmlsdGVyKChjb2RlRXhlY3V0aW9uUmVzdWx0KSA9PiBjb2RlRXhlY3V0aW9uUmVzdWx0ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoKGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IG51bGwgfHwgY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29kZUV4ZWN1dGlvblJlc3VsdC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2ogPSBjb2RlRXhlY3V0aW9uUmVzdWx0ID09PSBudWxsIHx8IGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvZGVFeGVjdXRpb25SZXN1bHRbMF0pID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5vdXRwdXQ7XG4gICAgfVxufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgZW1iZWRfY29udGVudCBtZXRob2QuICovXG5jbGFzcyBFbWJlZENvbnRlbnRSZXNwb25zZSB7XG59XG4vKiogVGhlIG91dHB1dCBpbWFnZXMgcmVzcG9uc2UuICovXG5jbGFzcyBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIHJlcXVlc3QgdG8gZWRpdCBhbiBpbWFnZS4gKi9cbmNsYXNzIEVkaXRJbWFnZVJlc3BvbnNlIHtcbn1cbmNsYXNzIFVwc2NhbGVJbWFnZVJlc3BvbnNlIHtcbn1cbi8qKiBUaGUgb3V0cHV0IGltYWdlcyByZXNwb25zZS4gKi9cbmNsYXNzIFJlY29udGV4dEltYWdlUmVzcG9uc2Uge1xufVxuLyoqIFRoZSBvdXRwdXQgaW1hZ2VzIHJlc3BvbnNlLiAqL1xuY2xhc3MgU2VnbWVudEltYWdlUmVzcG9uc2Uge1xufVxuY2xhc3MgTGlzdE1vZGVsc1Jlc3BvbnNlIHtcbn1cbmNsYXNzIERlbGV0ZU1vZGVsUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciBjb3VudGluZyB0b2tlbnMuICovXG5jbGFzcyBDb3VudFRva2Vuc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgY29tcHV0aW5nIHRva2Vucy4gKi9cbmNsYXNzIENvbXB1dGVUb2tlbnNSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2Ugd2l0aCBnZW5lcmF0ZWQgdmlkZW9zLiAqL1xuY2xhc3MgR2VuZXJhdGVWaWRlb3NSZXNwb25zZSB7XG59XG4vKiogQSB2aWRlbyBnZW5lcmF0aW9uIG9wZXJhdGlvbi4gKi9cbmNsYXNzIEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gT3BlcmF0aW9uIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIG9uZSBiZWluZyBjYWxsZWQgd2l0aCB0aGUgZmllbGRzIHNldCBmcm9tIHRoZSBBUEkgcmVzcG9uc2UuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2Zyb21BUElSZXNwb25zZSh7IGFwaVJlc3BvbnNlLCBpc1ZlcnRleEFJLCB9KSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG5ldyBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbigpO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IG9wID0gYXBpUmVzcG9uc2U7XG4gICAgICAgIGlmIChpc1ZlcnRleEFJKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleCQxKG9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYkMShvcCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcGVyYXRpb24sIHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbjtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBsaXN0IHR1bmluZyBqb2JzIG1ldGhvZC4gKi9cbmNsYXNzIExpc3RUdW5pbmdKb2JzUmVzcG9uc2Uge1xufVxuLyoqIEVtcHR5IHJlc3BvbnNlIGZvciBjYWNoZXMuZGVsZXRlIG1ldGhvZC4gKi9cbmNsYXNzIERlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSB7XG59XG5jbGFzcyBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBsaXN0IGZpbGVzIG1ldGhvZC4gKi9cbmNsYXNzIExpc3RGaWxlc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGNyZWF0ZSBmaWxlIG1ldGhvZC4gKi9cbmNsYXNzIENyZWF0ZUZpbGVSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBkZWxldGUgZmlsZSBtZXRob2QuICovXG5jbGFzcyBEZWxldGVGaWxlUmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgYGlubGluZWRfcmVzcG9uc2VzYCBwYXJhbWV0ZXIuICovXG5jbGFzcyBJbmxpbmVkUmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgYHJlc3BvbnNlYCBwYXJhbWV0ZXIuICovXG5jbGFzcyBTaW5nbGVFbWJlZENvbnRlbnRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgaW5saW5lZF9lbWJlZGRpbmdfcmVzcG9uc2VzYCBwYXJhbWV0ZXIuICovXG5jbGFzcyBJbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgYmF0Y2hlcy5saXN0IHJldHVybiB2YWx1ZS4gKi9cbmNsYXNzIExpc3RCYXRjaEpvYnNSZXNwb25zZSB7XG59XG4vKiogUmVwcmVzZW50cyBhIHNpbmdsZSByZXNwb25zZSBpbiBhIHJlcGxheS4gKi9cbmNsYXNzIFJlcGxheVJlc3BvbnNlIHtcbn1cbi8qKiBBIHJhdyByZWZlcmVuY2UgaW1hZ2UuXG5cbiAgQSByYXcgcmVmZXJlbmNlIGltYWdlIHJlcHJlc2VudHMgdGhlIGJhc2UgaW1hZ2UgdG8gZWRpdCwgcHJvdmlkZWQgYnkgdGhlIHVzZXIuXG4gIEl0IGNhbiBvcHRpb25hbGx5IGJlIHByb3ZpZGVkIGluIGFkZGl0aW9uIHRvIGEgbWFzayByZWZlcmVuY2UgaW1hZ2Ugb3JcbiAgYSBzdHlsZSByZWZlcmVuY2UgaW1hZ2UuXG4gICAqL1xuY2xhc3MgUmF3UmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX1JBVycsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgbWFzayByZWZlcmVuY2UgaW1hZ2UuXG5cbiAgVGhpcyBlbmNhcHN1bGF0ZXMgZWl0aGVyIGEgbWFzayBpbWFnZSBwcm92aWRlZCBieSB0aGUgdXNlciBhbmQgY29uZmlncyBmb3JcbiAgdGhlIHVzZXIgcHJvdmlkZWQgbWFzaywgb3Igb25seSBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIG1vZGVsIHRvIGdlbmVyYXRlXG4gIGEgbWFzay5cblxuICBBIG1hc2sgaW1hZ2UgaXMgYW4gaW1hZ2Ugd2hvc2Ugbm9uLXplcm8gdmFsdWVzIGluZGljYXRlIHdoZXJlIHRvIGVkaXQgdGhlIGJhc2VcbiAgaW1hZ2UuIElmIHRoZSB1c2VyIHByb3ZpZGVzIGEgbWFzayBpbWFnZSwgdGhlIG1hc2sgbXVzdCBiZSBpbiB0aGUgc2FtZVxuICBkaW1lbnNpb25zIGFzIHRoZSByYXcgaW1hZ2UuXG4gICAqL1xuY2xhc3MgTWFza1JlZmVyZW5jZUltYWdlIHtcbiAgICAvKiogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9NQVNLJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBtYXNrSW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgY29udHJvbCByZWZlcmVuY2UgaW1hZ2UuXG5cbiAgVGhlIGltYWdlIG9mIHRoZSBjb250cm9sIHJlZmVyZW5jZSBpbWFnZSBpcyBlaXRoZXIgYSBjb250cm9sIGltYWdlIHByb3ZpZGVkXG4gIGJ5IHRoZSB1c2VyLCBvciBhIHJlZ3VsYXIgaW1hZ2Ugd2hpY2ggdGhlIGJhY2tlbmQgd2lsbCB1c2UgdG8gZ2VuZXJhdGUgYVxuICBjb250cm9sIGltYWdlIG9mLiBJbiB0aGUgY2FzZSBvZiB0aGUgbGF0dGVyLCB0aGVcbiAgZW5hYmxlX2NvbnRyb2xfaW1hZ2VfY29tcHV0YXRpb24gZmllbGQgaW4gdGhlIGNvbmZpZyBzaG91bGQgYmUgc2V0IHRvIFRydWUuXG5cbiAgQSBjb250cm9sIGltYWdlIGlzIGFuIGltYWdlIHRoYXQgcmVwcmVzZW50cyBhIHNrZXRjaCBpbWFnZSBvZiBhcmVhcyBmb3IgdGhlXG4gIG1vZGVsIHRvIGZpbGwgaW4gYmFzZWQgb24gdGhlIHByb21wdC5cbiAgICovXG5jbGFzcyBDb250cm9sUmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX0NPTlRST0wnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgICAgIGNvbnRyb2xJbWFnZUNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogQSBzdHlsZSByZWZlcmVuY2UgaW1hZ2UuXG5cbiAgVGhpcyBlbmNhcHN1bGF0ZXMgYSBzdHlsZSByZWZlcmVuY2UgaW1hZ2UgcHJvdmlkZWQgYnkgdGhlIHVzZXIsIGFuZFxuICBhZGRpdGlvbmFsbHkgb3B0aW9uYWwgY29uZmlnIHBhcmFtZXRlcnMgZm9yIHRoZSBzdHlsZSByZWZlcmVuY2UgaW1hZ2UuXG5cbiAgQSByYXcgcmVmZXJlbmNlIGltYWdlIGNhbiBhbHNvIGJlIHByb3ZpZGVkIGFzIGEgZGVzdGluYXRpb24gZm9yIHRoZSBzdHlsZSB0b1xuICBiZSBhcHBsaWVkIHRvLlxuICAgKi9cbmNsYXNzIFN0eWxlUmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX1NUWUxFJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBzdHlsZUltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLlxuXG4gIFRoaXMgZW5jYXBzdWxhdGVzIGEgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UgcHJvdmlkZWQgYnkgdGhlIHVzZXIsIGFuZFxuICBhZGRpdGlvbmFsbHkgb3B0aW9uYWwgY29uZmlnIHBhcmFtZXRlcnMgZm9yIHRoZSBzdWJqZWN0IHJlZmVyZW5jZSBpbWFnZS5cblxuICBBIHJhdyByZWZlcmVuY2UgaW1hZ2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgYXMgYSBkZXN0aW5hdGlvbiBmb3IgdGhlIHN1YmplY3QgdG9cbiAgYmUgYXBwbGllZCB0by5cbiAgICovXG5jbGFzcyBTdWJqZWN0UmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfU1VCSkVDVCcsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgc3ViamVjdEltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIGNvbnRlbnQgcmVmZXJlbmNlIGltYWdlLlxuXG4gIEEgY29udGVudCByZWZlcmVuY2UgaW1hZ2UgcmVwcmVzZW50cyBhIHN1YmplY3QgdG8gcmVmZXJlbmNlIChleC4gcGVyc29uLFxuICBwcm9kdWN0LCBhbmltYWwpIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLiBJdCBjYW4gb3B0aW9uYWxseSBiZSBwcm92aWRlZCBpblxuICBhZGRpdGlvbiB0byBhIHN0eWxlIHJlZmVyZW5jZSBpbWFnZSAoZXguIGJhY2tncm91bmQsIHN0eWxlIHJlZmVyZW5jZSkuXG4gICAqL1xuY2xhc3MgQ29udGVudFJlZmVyZW5jZUltYWdlIHtcbiAgICAvKiogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9DT05URU5UJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgbWVzc2FnZSBmb3IgQVBJIGNhbGwuICovXG5jbGFzcyBMaXZlU2VydmVyTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dCBwYXJ0cyBmcm9tIHRoZSBzZXJ2ZXIgY29udGVudCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbm9uLXRleHQgcGFydHMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dFxuICAgICAqIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZCBhIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQuXG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgdGV4dCA9ICcnO1xuICAgICAgICBsZXQgYW55VGV4dFBhcnRGb3VuZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBub25UZXh0UGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfYyA9IChfYiA9IChfYSA9IHRoaXMuc2VydmVyQ29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vZGVsVHVybikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcnRzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICd0ZXh0JyAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWUgIT09ICd0aG91Z2h0JyAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vblRleHRQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LnRob3VnaHQgPT09ICdib29sZWFuJyAmJiBwYXJ0LnRob3VnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFueVRleHRQYXJ0Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25UZXh0UGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLXRleHQgcGFydHMgJHtub25UZXh0UGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIHRleHQgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhcnQudGV4dCA9PT0gJycgaXMgZGlmZmVyZW50IGZyb20gcGFydC50ZXh0IGlzIG51bGxcbiAgICAgICAgcmV0dXJuIGFueVRleHRQYXJ0Rm91bmQgPyB0ZXh0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCBpbmxpbmUgZGF0YSBwYXJ0cyBmcm9tIHRoZSBzZXJ2ZXIgY29udGVudCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbm9uLWlubGluZSBkYXRhIHBhcnRzIGluIHRoZVxuICAgICAqIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kXG4gICAgICogYSB3YXJuaW5nIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGdldCBkYXRhKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgbGV0IGRhdGEgPSAnJztcbiAgICAgICAgY29uc3Qgbm9uRGF0YVBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnNlcnZlckNvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RlbFR1cm4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJ0cykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSAnaW5saW5lRGF0YScgJiYgZmllbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBub25EYXRhUGFydHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0LmlubGluZURhdGEgJiYgdHlwZW9mIHBhcnQuaW5saW5lRGF0YS5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRhdGEgKz0gYXRvYihwYXJ0LmlubGluZURhdGEuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vbkRhdGFQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHRoZXJlIGFyZSBub24tZGF0YSBwYXJ0cyAke25vbkRhdGFQYXJ0c30gaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29uY2F0ZW5hdGlvbiBvZiBhbGwgZGF0YSBwYXJ0cy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBub24gZGF0YSBwYXJ0cyBmb3IgYSBmdWxsIHJlc3BvbnNlIGZyb20gbW9kZWwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoID4gMCA/IGJ0b2EoZGF0YSkgOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqIENsaWVudCBnZW5lcmF0ZWQgcmVzcG9uc2UgdG8gYSBgVG9vbENhbGxgIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cblxuICBJbmRpdmlkdWFsIGBGdW5jdGlvblJlc3BvbnNlYCBvYmplY3RzIGFyZSBtYXRjaGVkIHRvIHRoZSByZXNwZWN0aXZlXG4gIGBGdW5jdGlvbkNhbGxgIG9iamVjdHMgYnkgdGhlIGBpZGAgZmllbGQuXG5cbiAgTm90ZSB0aGF0IGluIHRoZSB1bmFyeSBhbmQgc2VydmVyLXN0cmVhbWluZyBHZW5lcmF0ZUNvbnRlbnQgQVBJcyBmdW5jdGlvblxuICBjYWxsaW5nIGhhcHBlbnMgYnkgZXhjaGFuZ2luZyB0aGUgYENvbnRlbnRgIHBhcnRzLCB3aGlsZSBpbiB0aGUgYmlkaVxuICBHZW5lcmF0ZUNvbnRlbnQgQVBJcyBmdW5jdGlvbiBjYWxsaW5nIGhhcHBlbnMgb3ZlciB0aGlzIGRlZGljYXRlZCBzZXQgb2ZcbiAgbWVzc2FnZXMuXG4gICAqL1xuY2xhc3MgTGl2ZUNsaWVudFRvb2xSZXNwb25zZSB7XG59XG4vKiogUGFyYW1ldGVycyBmb3Igc2VuZGluZyB0b29sIHJlc3BvbnNlcyB0byB0aGUgbGl2ZSBBUEkuICovXG5jbGFzcyBMaXZlU2VuZFRvb2xSZXNwb25zZVBhcmFtZXRlcnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiogVG9vbCByZXNwb25zZXMgdG8gc2VuZCB0byB0aGUgc2Vzc2lvbi4gKi9cbiAgICAgICAgdGhpcy5mdW5jdGlvblJlc3BvbnNlcyA9IFtdO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBtZXNzYWdlIGZvciB0aGUgTGl2ZU11c2ljQ2xpZW50TWVzc2FnZSBjYWxsLiAqL1xuY2xhc3MgTGl2ZU11c2ljU2VydmVyTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgYXVkaW8gY2h1bmsgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBubyBhdWRpbyBjaHVua3MgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXQgYXVkaW9DaHVuaygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyQ29udGVudCAmJlxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJDb250ZW50LmF1ZGlvQ2h1bmtzICYmXG4gICAgICAgICAgICB0aGlzLnNlcnZlckNvbnRlbnQuYXVkaW9DaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyQ29udGVudC5hdWRpb0NodW5rc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gdE1vZGVsKGFwaUNsaWVudCwgbW9kZWwpIHtcbiAgICBpZiAoIW1vZGVsIHx8IHR5cGVvZiBtb2RlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlbCBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgncHVibGlzaGVycy8nKSB8fFxuICAgICAgICAgICAgbW9kZWwuc3RhcnRzV2l0aCgncHJvamVjdHMvJykgfHxcbiAgICAgICAgICAgIG1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJy8nKSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IG1vZGVsLnNwbGl0KCcvJywgMik7XG4gICAgICAgICAgICByZXR1cm4gYHB1Ymxpc2hlcnMvJHtwYXJ0c1swXX0vbW9kZWxzLyR7cGFydHNbMV19YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgcHVibGlzaGVycy9nb29nbGUvbW9kZWxzLyR7bW9kZWx9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSB8fCBtb2RlbC5zdGFydHNXaXRoKCd0dW5lZE1vZGVscy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBtb2RlbHMvJHttb2RlbH1gO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdENhY2hlc01vZGVsKGFwaUNsaWVudCwgbW9kZWwpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZE1vZGVsID0gdE1vZGVsKGFwaUNsaWVudCwgbW9kZWwpO1xuICAgIGlmICghdHJhbnNmb3JtZWRNb2RlbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1lZE1vZGVsLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvJykgJiYgYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAvLyB2ZXJ0ZXggY2FjaGVzIG9ubHkgc3VwcG9ydCBtb2RlbCBuYW1lIHN0YXJ0IHdpdGggcHJvamVjdHMuXG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHthcGlDbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHthcGlDbGllbnQuZ2V0TG9jYXRpb24oKX0vJHt0cmFuc2Zvcm1lZE1vZGVsfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybWVkTW9kZWwuc3RhcnRzV2l0aCgnbW9kZWxzLycpICYmIGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke2FwaUNsaWVudC5nZXRQcm9qZWN0KCl9L2xvY2F0aW9ucy8ke2FwaUNsaWVudC5nZXRMb2NhdGlvbigpfS9wdWJsaXNoZXJzL2dvb2dsZS8ke3RyYW5zZm9ybWVkTW9kZWx9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZE1vZGVsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRCbG9icyhibG9icykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJsb2JzKSkge1xuICAgICAgICByZXR1cm4gYmxvYnMubWFwKChibG9iKSA9PiB0QmxvYihibG9iKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW3RCbG9iKGJsb2JzKV07XG4gICAgfVxufVxuZnVuY3Rpb24gdEJsb2IoYmxvYikge1xuICAgIGlmICh0eXBlb2YgYmxvYiA9PT0gJ29iamVjdCcgJiYgYmxvYiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgaW5wdXQgYXMgQmxvYi4gVW5zdXBwb3J0ZWQgYmxvYiB0eXBlOiAke3R5cGVvZiBibG9ifWApO1xufVxuZnVuY3Rpb24gdEltYWdlQmxvYihibG9iKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCbG9iID0gdEJsb2IoYmxvYik7XG4gICAgaWYgKHRyYW5zZm9ybWVkQmxvYi5taW1lVHlwZSAmJlxuICAgICAgICB0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkQmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtaW1lIHR5cGU6ICR7dHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlfWApO1xufVxuZnVuY3Rpb24gdEF1ZGlvQmxvYihibG9iKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCbG9iID0gdEJsb2IoYmxvYik7XG4gICAgaWYgKHRyYW5zZm9ybWVkQmxvYi5taW1lVHlwZSAmJlxuICAgICAgICB0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUuc3RhcnRzV2l0aCgnYXVkaW8vJykpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkQmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtaW1lIHR5cGU6ICR7dHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlfWApO1xufVxuZnVuY3Rpb24gdFBhcnQob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fCBvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnRVbmlvbiBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IG9yaWdpbiB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQgdHlwZTogJHt0eXBlb2Ygb3JpZ2lufWApO1xufVxuZnVuY3Rpb24gdFBhcnRzKG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHxcbiAgICAgICAgb3JpZ2luID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkob3JpZ2luKSAmJiBvcmlnaW4ubGVuZ3RoID09PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnRMaXN0VW5pb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLm1hcCgoaXRlbSkgPT4gdFBhcnQoaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gW3RQYXJ0KG9yaWdpbildO1xufVxuZnVuY3Rpb24gX2lzQ29udGVudChvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAncGFydHMnIGluIG9yaWdpbiAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KG9yaWdpbi5wYXJ0cykpO1xufVxuZnVuY3Rpb24gX2lzRnVuY3Rpb25DYWxsUGFydChvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnZnVuY3Rpb25DYWxsJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gX2lzRnVuY3Rpb25SZXNwb25zZVBhcnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiB0Q29udGVudChvcmlnaW4pIHtcbiAgICBpZiAob3JpZ2luID09PSBudWxsIHx8IG9yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudFVuaW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChfaXNDb250ZW50KG9yaWdpbikpIHtcbiAgICAgICAgLy8gX2lzQ29udGVudCBpcyBhIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlXG4gICAgICAgIC8vIG9yaWdpbiBpcyBhIENvbnRlbnQuXG4gICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgcGFydHM6IHRQYXJ0cyhvcmlnaW4pLFxuICAgIH07XG59XG5mdW5jdGlvbiB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIG9yaWdpbikge1xuICAgIGlmICghb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiYgQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW4uZmxhdE1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRDb250ZW50KGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQucGFydHMgJiZcbiAgICAgICAgICAgICAgICBjb250ZW50LnBhcnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBjb250ZW50LnBhcnRzWzBdLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbY29udGVudC5wYXJ0c1swXS50ZXh0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRDb250ZW50KG9yaWdpbik7XG4gICAgICAgIGlmIChjb250ZW50LnBhcnRzICYmXG4gICAgICAgICAgICBjb250ZW50LnBhcnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIGNvbnRlbnQucGFydHNbMF0udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbnRlbnQucGFydHNbMF0udGV4dF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW4ubWFwKChpdGVtKSA9PiB0Q29udGVudChpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiBbdENvbnRlbnQob3JpZ2luKV07XG59XG5mdW5jdGlvbiB0Q29udGVudHMob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fFxuICAgICAgICBvcmlnaW4gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShvcmlnaW4pICYmIG9yaWdpbi5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udGVudHMgYXJlIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IGFuIGFycmF5LCBpdCdzIGEgc2luZ2xlIGNvbnRlbnQgb3IgYSBzaW5nbGUgUGFydFVuaW9uLlxuICAgICAgICBpZiAoX2lzRnVuY3Rpb25DYWxsUGFydChvcmlnaW4pIHx8IF9pc0Z1bmN0aW9uUmVzcG9uc2VQYXJ0KG9yaWdpbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gc3BlY2lmeSBmdW5jdGlvbkNhbGwgb3IgZnVuY3Rpb25SZXNwb25zZSBwYXJ0cywgcGxlYXNlIHdyYXAgdGhlbSBpbiBhIENvbnRlbnQgb2JqZWN0LCBzcGVjaWZ5aW5nIHRoZSByb2xlIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0Q29udGVudChvcmlnaW4pXTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgYWNjdW11bGF0ZWRQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IGlzQ29udGVudEFycmF5ID0gX2lzQ29udGVudChvcmlnaW5bMF0pO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgaXNDb250ZW50ID0gX2lzQ29udGVudChpdGVtKTtcbiAgICAgICAgaWYgKGlzQ29udGVudCAhPSBpc0NvbnRlbnRBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXhpbmcgQ29udGVudCBhbmQgUGFydHMgaXMgbm90IHN1cHBvcnRlZCwgcGxlYXNlIGdyb3VwIHRoZSBwYXJ0cyBpbnRvIGEgdGhlIGFwcHJvcHJpYXRlIENvbnRlbnQgb2JqZWN0cyBhbmQgc3BlY2lmeSB0aGUgcm9sZXMgZm9yIHRoZW0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb250ZW50KSB7XG4gICAgICAgICAgICAvLyBgaXNDb250ZW50YCBjb250YWlucyB0aGUgcmVzdWx0IG9mIF9pc0NvbnRlbnQsIHdoaWNoIGlzIGEgdXRpbGl0eVxuICAgICAgICAgICAgLy8gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGl0ZW0gaXMgYSBDb250ZW50LlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX2lzRnVuY3Rpb25DYWxsUGFydChpdGVtKSB8fCBfaXNGdW5jdGlvblJlc3BvbnNlUGFydChpdGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUbyBzcGVjaWZ5IGZ1bmN0aW9uQ2FsbCBvciBmdW5jdGlvblJlc3BvbnNlIHBhcnRzLCBwbGVhc2Ugd3JhcCB0aGVtLCBhbmQgYW55IG90aGVyIHBhcnRzLCBpbiBDb250ZW50IG9iamVjdHMgYXMgYXBwcm9wcmlhdGUsIHNwZWNpZnlpbmcgdGhlIHJvbGUgZm9yIHRoZW0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzQ29udGVudEFycmF5KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgcm9sZTogJ3VzZXInLCBwYXJ0czogdFBhcnRzKGFjY3VtdWxhdGVkUGFydHMpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLypcblRyYW5zZm9ybSB0aGUgdHlwZSBmaWVsZCBmcm9tIGFuIGFycmF5IG9mIHR5cGVzIHRvIGFuIGFycmF5IG9mIGFueU9mIGZpZWxkcy5cbkV4YW1wbGU6XG4gIHt0eXBlOiBbJ1NUUklORycsICdOVU1CRVInXX1cbndpbGwgYmUgdHJhbnNmb3JtZWQgdG9cbiAge2FueU9mOiBbe3R5cGU6ICdTVFJJTkcnfSwge3R5cGU6ICdOVU1CRVInfV19XG4qL1xuZnVuY3Rpb24gZmxhdHRlblR5cGVBcnJheVRvQW55T2YodHlwZUxpc3QsIHJlc3VsdGluZ1NjaGVtYSkge1xuICAgIGlmICh0eXBlTGlzdC5pbmNsdWRlcygnbnVsbCcpKSB7XG4gICAgICAgIHJlc3VsdGluZ1NjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGxpc3RXaXRob3V0TnVsbCA9IHR5cGVMaXN0LmZpbHRlcigodHlwZSkgPT4gdHlwZSAhPT0gJ251bGwnKTtcbiAgICBpZiAobGlzdFdpdGhvdXROdWxsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ3R5cGUnXSA9IE9iamVjdC52YWx1ZXMoVHlwZSkuaW5jbHVkZXMobGlzdFdpdGhvdXROdWxsWzBdLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICA/IGxpc3RXaXRob3V0TnVsbFswXS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICA6IFR5cGUuVFlQRV9VTlNQRUNJRklFRDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdGluZ1NjaGVtYVsnYW55T2YnXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgbGlzdFdpdGhvdXROdWxsKSB7XG4gICAgICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ2FueU9mJ10ucHVzaCh7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiBPYmplY3QudmFsdWVzKFR5cGUpLmluY2x1ZGVzKGkudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgICAgICAgICAgPyBpLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgOiBUeXBlLlRZUEVfVU5TUEVDSUZJRUQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NKc29uU2NoZW1hKF9qc29uU2NoZW1hKSB7XG4gICAgY29uc3QgZ2VuQUlTY2hlbWEgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFGaWVsZE5hbWVzID0gWydpdGVtcyddO1xuICAgIGNvbnN0IGxpc3RTY2hlbWFGaWVsZE5hbWVzID0gWydhbnlPZiddO1xuICAgIGNvbnN0IGRpY3RTY2hlbWFGaWVsZE5hbWVzID0gWydwcm9wZXJ0aWVzJ107XG4gICAgaWYgKF9qc29uU2NoZW1hWyd0eXBlJ10gJiYgX2pzb25TY2hlbWFbJ2FueU9mJ10pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIGFuZCBhbnlPZiBjYW5ub3QgYmUgYm90aCBwb3B1bGF0ZWQuJyk7XG4gICAgfVxuICAgIC8qXG4gICAgVGhpcyBpcyB0byBoYW5kbGUgdGhlIG51bGxhYmxlIGFycmF5IG9yIG9iamVjdC4gVGhlIF9qc29uU2NoZW1hIHdpbGxcbiAgICBiZSBpbiB0aGUgZm9ybWF0IG9mIHthbnlPZjogW3t0eXBlOiAnbnVsbCd9LCB7dHlwZTogJ29iamVjdCd9XX0uIFRoZVxuICAgIGxvZ2ljIGlzIHRvIGNoZWNrIGlmIGFueU9mIGhhcyAyIGVsZW1lbnRzIGFuZCBvbmUgb2YgdGhlIGVsZW1lbnQgaXMgbnVsbCxcbiAgICBpZiBzbywgdGhlIGFueU9mIGZpZWxkIGlzIHVubmVjZXNzYXJ5LCBzbyB3ZSBuZWVkIHRvIGdldCByaWQgb2YgdGhlIGFueU9mXG4gICAgZmllbGQgYW5kIG1ha2UgdGhlIHNjaGVtYSBudWxsYWJsZS4gVGhlbiB1c2UgdGhlIG90aGVyIGVsZW1lbnQgYXMgdGhlIG5ld1xuICAgIF9qc29uU2NoZW1hIGZvciBwcm9jZXNzaW5nLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGJhY2tlbmQgZG9lc24ndCBoYXZlIGEgbnVsbFxuICAgIHR5cGUuXG4gICAgVGhpcyBoYXMgdG8gYmUgY2hlY2tlZCBiZWZvcmUgd2UgcHJvY2VzcyBhbnkgb3RoZXIgZmllbGRzLlxuICAgIEZvciBleGFtcGxlOlxuICAgICAgY29uc3Qgb2JqZWN0TnVsbGFibGUgPSB6Lm9iamVjdCh7XG4gICAgICAgIG51bGxhYmxlQXJyYXk6IHouYXJyYXkoei5zdHJpbmcoKSkubnVsbGFibGUoKSxcbiAgICAgIH0pO1xuICAgIFdpbGwgaGF2ZSB0aGUgcmF3IF9qc29uU2NoZW1hIGFzOlxuICAgIHtcbiAgICAgIHR5cGU6ICdPQkpFQ1QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIG51bGxhYmxlQXJyYXk6IHtcbiAgICAgICAgICAgICBhbnlPZjogW1xuICAgICAgICAgICAgICAgIHt0eXBlOiAnbnVsbCd9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICBpdGVtczoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogWyAnbnVsbGFibGVBcnJheScgXSxcbiAgICB9XG4gICAgV2lsbCByZXN1bHQgaW4gZm9sbG93aW5nIHNjaGVtYSBjb21wYXRpYmxlIHdpdGggR2VtaW5pIEFQSTpcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ09CSkVDVCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgbnVsbGFibGVBcnJheToge1xuICAgICAgICAgICAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogJ0FSUkFZJyxcbiAgICAgICAgICAgICAgaXRlbXM6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZWQ6IFsgJ251bGxhYmxlQXJyYXknIF0sXG4gICAgICB9XG4gICAgKi9cbiAgICBjb25zdCBpbmNvbWluZ0FueU9mID0gX2pzb25TY2hlbWFbJ2FueU9mJ107XG4gICAgaWYgKGluY29taW5nQW55T2YgIT0gbnVsbCAmJiBpbmNvbWluZ0FueU9mLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGlmIChpbmNvbWluZ0FueU9mWzBdWyd0eXBlJ10gPT09ICdudWxsJykge1xuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgICAgICAgICAgX2pzb25TY2hlbWEgPSBpbmNvbWluZ0FueU9mWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluY29taW5nQW55T2ZbMV1bJ3R5cGUnXSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgICAgICAgICBfanNvblNjaGVtYSA9IGluY29taW5nQW55T2ZbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9qc29uU2NoZW1hWyd0eXBlJ10gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBmbGF0dGVuVHlwZUFycmF5VG9BbnlPZihfanNvblNjaGVtYVsndHlwZSddLCBnZW5BSVNjaGVtYSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoX2pzb25TY2hlbWEpKSB7XG4gICAgICAgIC8vIFNraXAgaWYgdGhlIGZpZWxkdmFsdWUgaXMgdW5kZWZpbmVkIG9yIG51bGwuXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZE5hbWUgPT0gJ3R5cGUnKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlOiBudWxsIGNhbiBub3QgYmUgdGhlIG9ubHkgcG9zc2libGUgdHlwZSBmb3IgdGhlIGZpZWxkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIHRoZSB0eXBlIGZpZWxkIHdpdGggYXJyYXkgb2YgdHlwZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVsndHlwZSddID0gT2JqZWN0LnZhbHVlcyhUeXBlKS5pbmNsdWRlcyhmaWVsZFZhbHVlLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgPyBmaWVsZFZhbHVlLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICA6IFR5cGUuVFlQRV9VTlNQRUNJRklFRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIHByb2Nlc3NKc29uU2NoZW1hKGZpZWxkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpc3RTY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RTY2hlbWFGaWVsZFZhbHVlID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtWyd0eXBlJ10gPT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbkFJU2NoZW1hWydudWxsYWJsZSddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3RTY2hlbWFGaWVsZFZhbHVlLnB1c2gocHJvY2Vzc0pzb25TY2hlbWEoaXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbZmllbGROYW1lXSA9XG4gICAgICAgICAgICAgICAgbGlzdFNjaGVtYUZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGljdFNjaGVtYUZpZWxkTmFtZXMuaW5jbHVkZXMoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgZGljdFNjaGVtYUZpZWxkVmFsdWUgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZGljdFNjaGVtYUZpZWxkVmFsdWVba2V5XSA9IHByb2Nlc3NKc29uU2NoZW1hKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIGRpY3RTY2hlbWFGaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYWRkaXRpb25hbFByb3BlcnRpZXMgaXMgbm90IGluY2x1ZGVkIGluIEpTT05TY2hlbWEsIHNraXBwaW5nIGl0LlxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbZmllbGROYW1lXSA9IGZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlbkFJU2NoZW1hO1xufVxuLy8gd2UgdGFrZSB0aGUgdW5rbm93biBpbiB0aGUgc2NoZW1hIGZpZWxkIGJlY2F1c2Ugd2Ugd2FudCBlbmFibGUgdXNlciB0byBwYXNzXG4vLyB0aGUgb3V0cHV0IG9mIG1ham9yIHNjaGVtYSBkZWNsYXJhdGlvbiB0b29scyB3aXRob3V0IGNhc3RpbmcuIFRvb2xzIHN1Y2ggYXNcbi8vIHpvZFRvSnNvblNjaGVtYSwgdHlwZWJveCwgem9kVG9Kc29uU2NoZW1hIGZ1bmN0aW9uIGNhbiByZXR1cm4gSnNvblNjaGVtYTdUeXBlXG4vLyBvciBvYmplY3QsIHNlZSBkZXRhaWxzIGluXG4vLyBodHRwczovL2dpdGh1Yi5jb20vU3RlZmFuVGVyZGVsbC96b2QtdG8tanNvbi1zY2hlbWEvYmxvYi83MDUyNWVmZTU1NWNkMjI2NjkxZTA5M2QxNzEzNzBhM2IxMDkyMWQxL3NyYy96b2RUb0pzb25TY2hlbWEudHMjTDdcbi8vIHR5cGVib3ggY2FuIHJldHVybiB1bmtub3duLCBzZWUgZGV0YWlscyBpblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmNsYWlyeng4MS90eXBlYm94L2Jsb2IvNWE1NDMxNDM5ZjdkNWNhNmI0OTRkMGQxOGZiZmQ3YjFhMzU2ZDY3Yy9zcmMvdHlwZS9jcmVhdGUvdHlwZS50cyNMMzVcbi8vIE5vdGU6IHByb3BlciBqc29uIHNjaGVtYXMgd2l0aCB0aGUgJHNjaGVtYSBmaWVsZCBzZXQgbmV2ZXIgYXJyaXZlIHRvIHRoaXNcbi8vIHRyYW5zZm9ybWVyLiBTY2hlbWFzIHdpdGggJHNjaGVtYSBhcmUgcm91dGVkIHRvIHRoZSBlcXVpdmFsZW50IEFQSSBqc29uXG4vLyBzY2hlbWEgZmllbGQuXG5mdW5jdGlvbiB0U2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBwcm9jZXNzSnNvblNjaGVtYShzY2hlbWEpO1xufVxuZnVuY3Rpb24gdFNwZWVjaENvbmZpZyhzcGVlY2hDb25maWcpIHtcbiAgICBpZiAodHlwZW9mIHNwZWVjaENvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHNwZWVjaENvbmZpZztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNwZWVjaENvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZvaWNlQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgcHJlYnVpbHRWb2ljZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICB2b2ljZU5hbWU6IHNwZWVjaENvbmZpZyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc3BlZWNoQ29uZmlnIHR5cGU6ICR7dHlwZW9mIHNwZWVjaENvbmZpZ31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0TGl2ZVNwZWVjaENvbmZpZyhzcGVlY2hDb25maWcpIHtcbiAgICBpZiAoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJyBpbiBzcGVlY2hDb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBsaXZlIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWVjaENvbmZpZztcbn1cbmZ1bmN0aW9uIHRUb29sKHRvb2wpIHtcbiAgICBpZiAodG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb24gb2YgdG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzKS5pbmNsdWRlcygnJHNjaGVtYScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycyA9IHByb2Nlc3NKc29uU2NoZW1hKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVyc0pzb25TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVyc0pzb25TY2hlbWEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSkuaW5jbHVkZXMoJyRzY2hlbWEnKSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlID0gcHJvY2Vzc0pzb25TY2hlbWEoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2VKc29uU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlSnNvblNjaGVtYSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b29sO1xufVxuZnVuY3Rpb24gdFRvb2xzKHRvb2xzKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGluY29taW5nIHR5cGUgaXMgZGVmaW5lZC5cbiAgICBpZiAodG9vbHMgPT09IHVuZGVmaW5lZCB8fCB0b29scyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rvb2xzIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0b29scykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29scyBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhbiBhcnJheSBvZiBUb29scycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9vbCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFByZXBlbmRzIHJlc291cmNlIG5hbWUgd2l0aCBwcm9qZWN0LCBsb2NhdGlvbiwgcmVzb3VyY2VfcHJlZml4IGlmIG5lZWRlZC5cbiAqXG4gKiBAcGFyYW0gY2xpZW50IFRoZSBBUEkgY2xpZW50LlxuICogQHBhcmFtIHJlc291cmNlTmFtZSBUaGUgcmVzb3VyY2UgbmFtZS5cbiAqIEBwYXJhbSByZXNvdXJjZVByZWZpeCBUaGUgcmVzb3VyY2UgcHJlZml4LlxuICogQHBhcmFtIHNwbGl0c0FmdGVyUHJlZml4IFRoZSBudW1iZXIgb2Ygc3BsaXRzIGFmdGVyIHRoZSBwcmVmaXguXG4gKiBAcmV0dXJucyBUaGUgY29tcGxldGVkIHJlc291cmNlIG5hbWUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9iYXIvbG9jYXRpb25zL3VzLXdlc3QxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICcxMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqIF9yZXNvdXJjZV9uYW1lKGNsaWVudCwgcmVzb3VyY2VfbmFtZSwgcmVzb3VyY2VfcHJlZml4LCBzcGxpdHNfYWZ0ZXJfcHJlZml4KVxuICogcmV0dXJucyAnY2FjaGVkQ29udGVudHMvMTIzJ1xuICogYGBgXG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJ3NvbWUvd3JvbmcvY2FjaGVkQ29udGVudHMvcmVzb3VyY2UvbmFtZS8xMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqICMgY2xpZW50LnZlcnRleGFpID0gVHJ1ZVxuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiAtPiAnc29tZS93cm9uZy9yZXNvdXJjZS9uYW1lLzEyMydcbiAqIGBgYFxuICovXG5mdW5jdGlvbiByZXNvdXJjZU5hbWUoY2xpZW50LCByZXNvdXJjZU5hbWUsIHJlc291cmNlUHJlZml4LCBzcGxpdHNBZnRlclByZWZpeCA9IDEpIHtcbiAgICBjb25zdCBzaG91bGRBcHBlbmRQcmVmaXggPSAhcmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoYCR7cmVzb3VyY2VQcmVmaXh9L2ApICYmXG4gICAgICAgIHJlc291cmNlTmFtZS5zcGxpdCgnLycpLmxlbmd0aCA9PT0gc3BsaXRzQWZ0ZXJQcmVmaXg7XG4gICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKHJlc291cmNlTmFtZS5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aCgnbG9jYXRpb25zLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7Y2xpZW50LmdldFByb2plY3QoKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aChgJHtyZXNvdXJjZVByZWZpeH0vYCkpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaG91bGRBcHBlbmRQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZVByZWZpeH0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEFwcGVuZFByZWZpeCkge1xuICAgICAgICByZXR1cm4gYCR7cmVzb3VyY2VQcmVmaXh9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG59XG5mdW5jdGlvbiB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb3VyY2VOYW1lKGFwaUNsaWVudCwgbmFtZSwgJ2NhY2hlZENvbnRlbnRzJyk7XG59XG5mdW5jdGlvbiB0VHVuaW5nSm9iU3RhdHVzKHN0YXR1cykge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgJ1NUQVRFX1VOU1BFQ0lGSUVEJzpcbiAgICAgICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1VOU1BFQ0lGSUVEJztcbiAgICAgICAgY2FzZSAnQ1JFQVRJTkcnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfUlVOTklORyc7XG4gICAgICAgIGNhc2UgJ0FDVElWRSc6XG4gICAgICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9TVUNDRUVERUQnO1xuICAgICAgICBjYXNlICdGQUlMRUQnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfRkFJTEVEJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxufVxuZnVuY3Rpb24gdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSB7XG4gICAgcmV0dXJuIHRCeXRlcyQxKGZyb21JbWFnZUJ5dGVzKTtcbn1cbmZ1bmN0aW9uIF9pc0ZpbGUob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ25hbWUnIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRlZFZpZGVvKG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICd2aWRlbycgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIGlzVmlkZW8ob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3VyaScgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIHRGaWxlTmFtZShmcm9tTmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgbmFtZTtcbiAgICBpZiAoX2lzRmlsZShmcm9tTmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lLm5hbWU7XG4gICAgfVxuICAgIGlmIChpc1ZpZGVvKGZyb21OYW1lKSkge1xuICAgICAgICBuYW1lID0gZnJvbU5hbWUudXJpO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0dlbmVyYXRlZFZpZGVvKGZyb21OYW1lKSkge1xuICAgICAgICBuYW1lID0gKF9hID0gZnJvbU5hbWUudmlkZW8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cmk7XG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmcm9tTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGV4dHJhY3QgZmlsZSBuYW1lIGZyb20gdGhlIHByb3ZpZGVkIGlucHV0LicpO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IG5hbWUuc3BsaXQoJ2ZpbGVzLycpWzFdO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN1ZmZpeC5tYXRjaCgvW2EtejAtOV0rLyk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZXh0cmFjdCBmaWxlIG5hbWUgZnJvbSBVUkkgJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBtYXRjaFswXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICBuYW1lID0gbmFtZS5zcGxpdCgnZmlsZXMvJylbMV07XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gdE1vZGVsc1VybChhcGlDbGllbnQsIGJhc2VNb2RlbHMpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIHJlcyA9IGJhc2VNb2RlbHMgPyAncHVibGlzaGVycy9nb29nbGUvbW9kZWxzJyA6ICdtb2RlbHMnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzID0gYmFzZU1vZGVscyA/ICdtb2RlbHMnIDogJ3R1bmVkTW9kZWxzJztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHRFeHRyYWN0TW9kZWxzKHJlc3BvbnNlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgWydtb2RlbHMnLCAndHVuZWRNb2RlbHMnLCAncHVibGlzaGVyTW9kZWxzJ10pIHtcbiAgICAgICAgaWYgKGhhc0ZpZWxkKHJlc3BvbnNlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBoYXNGaWVsZChkYXRhLCBmaWVsZE5hbWUpIHtcbiAgICByZXR1cm4gZGF0YSAhPT0gbnVsbCAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZmllbGROYW1lIGluIGRhdGE7XG59XG5mdW5jdGlvbiBtY3BUb0dlbWluaVRvb2wobWNwVG9vbCwgY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBtY3BUb29sU2NoZW1hID0gbWNwVG9vbDtcbiAgICBjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uID0ge1xuICAgICAgICBuYW1lOiBtY3BUb29sU2NoZW1hWyduYW1lJ10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBtY3BUb29sU2NoZW1hWydkZXNjcmlwdGlvbiddLFxuICAgICAgICBwYXJhbWV0ZXJzSnNvblNjaGVtYTogbWNwVG9vbFNjaGVtYVsnaW5wdXRTY2hlbWEnXSxcbiAgICB9O1xuICAgIGlmIChtY3BUb29sU2NoZW1hWydvdXRwdXRTY2hlbWEnXSkge1xuICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uWydyZXNwb25zZUpzb25TY2hlbWEnXSA9IG1jcFRvb2xTY2hlbWFbJ291dHB1dFNjaGVtYSddO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmJlaGF2aW9yKSB7XG4gICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25bJ2JlaGF2aW9yJ10gPSBjb25maWcuYmVoYXZpb3I7XG4gICAgfVxuICAgIGNvbnN0IGdlbWluaVRvb2wgPSB7XG4gICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgICBdLFxuICAgIH07XG4gICAgcmV0dXJuIGdlbWluaVRvb2w7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgbGlzdCBvZiBNQ1AgdG9vbHMgdG8gYSBzaW5nbGUgR2VtaW5pIHRvb2wgd2l0aCBhIGxpc3Qgb2YgZnVuY3Rpb25cbiAqIGRlY2xhcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWNwVG9vbHNUb0dlbWluaVRvb2wobWNwVG9vbHMsIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBbXTtcbiAgICBjb25zdCB0b29sTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBtY3BUb29sIG9mIG1jcFRvb2xzKSB7XG4gICAgICAgIGNvbnN0IG1jcFRvb2xOYW1lID0gbWNwVG9vbC5uYW1lO1xuICAgICAgICBpZiAodG9vbE5hbWVzLmhhcyhtY3BUb29sTmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGZ1bmN0aW9uIG5hbWUgJHttY3BUb29sTmFtZX0gZm91bmQgaW4gTUNQIHRvb2xzLiBQbGVhc2UgZW5zdXJlIGZ1bmN0aW9uIG5hbWVzIGFyZSB1bmlxdWUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbE5hbWVzLmFkZChtY3BUb29sTmFtZSk7XG4gICAgICAgIGNvbnN0IGdlbWluaVRvb2wgPSBtY3BUb0dlbWluaVRvb2wobWNwVG9vbCwgY29uZmlnKTtcbiAgICAgICAgaWYgKGdlbWluaVRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25zLnB1c2goLi4uZ2VtaW5pVG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IGZ1bmN0aW9uRGVjbGFyYXRpb25zIH07XG59XG4vLyBUcmFuc2Zvcm1zIGEgc291cmNlIGlucHV0IGludG8gYSBCYXRjaEpvYlNvdXJjZSBvYmplY3Qgd2l0aCB2YWxpZGF0aW9uLlxuZnVuY3Rpb24gdEJhdGNoSm9iU291cmNlKGNsaWVudCwgc3JjKSB7XG4gICAgbGV0IHNvdXJjZU9iajtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnZ3M6Ly8nKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZU9iaiA9IHsgZm9ybWF0OiAnanNvbmwnLCBnY3NVcmk6IFtzcmNdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzcmMuc3RhcnRzV2l0aCgnYnE6Ly8nKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZU9iaiA9IHsgZm9ybWF0OiAnYmlncXVlcnknLCBiaWdxdWVyeVVyaTogc3JjIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHN0cmluZyBzb3VyY2UgZm9yIFZlcnRleCBBSTogJHtzcmN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNTERFVlxuICAgICAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZU9iaiA9IHsgZmlsZU5hbWU6IHNyYyB9OyAvLyBEZWZhdWx0IHRvIGZpbGVOYW1lIGZvciBzdHJpbmcgaW5wdXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc3RyaW5nIHNvdXJjZSBmb3IgR2VtaW5pIEFQSTogJHtzcmN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgIGlmIChjbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lubGluZWRSZXF1ZXN0W10gaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlT2JqID0geyBpbmxpbmVkUmVxdWVzdHM6IHNyYyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSXQncyBhbHJlYWR5IGEgQmF0Y2hKb2JTb3VyY2Ugb2JqZWN0XG4gICAgICAgIHNvdXJjZU9iaiA9IHNyYztcbiAgICB9XG4gICAgLy8gVmFsaWRhdGlvbiBsb2dpY1xuICAgIGNvbnN0IHZlcnRleFNvdXJjZXNDb3VudCA9IFtzb3VyY2VPYmouZ2NzVXJpLCBzb3VyY2VPYmouYmlncXVlcnlVcmldLmZpbHRlcihCb29sZWFuKS5sZW5ndGg7XG4gICAgY29uc3QgbWxkZXZTb3VyY2VzQ291bnQgPSBbXG4gICAgICAgIHNvdXJjZU9iai5pbmxpbmVkUmVxdWVzdHMsXG4gICAgICAgIHNvdXJjZU9iai5maWxlTmFtZSxcbiAgICBdLmZpbHRlcihCb29sZWFuKS5sZW5ndGg7XG4gICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKG1sZGV2U291cmNlc0NvdW50ID4gMCB8fCB2ZXJ0ZXhTb3VyY2VzQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhhY3RseSBvbmUgb2YgYGdjc1VyaWAgb3IgYGJpZ3F1ZXJ5VXJpYCBtdXN0IGJlIHNldCBmb3IgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBNTERFVlxuICAgICAgICBpZiAodmVydGV4U291cmNlc0NvdW50ID4gMCB8fCBtbGRldlNvdXJjZXNDb3VudCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGFjdGx5IG9uZSBvZiBgaW5saW5lZFJlcXVlc3RzYCwgYGZpbGVOYW1lYCwgJyArXG4gICAgICAgICAgICAgICAgJ211c3QgYmUgc2V0IGZvciBHZW1pbmkgQVBJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VPYmo7XG59XG5mdW5jdGlvbiB0QmF0Y2hKb2JEZXN0aW5hdGlvbihkZXN0KSB7XG4gICAgaWYgKHR5cGVvZiBkZXN0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgY29uc3QgZGVzdFN0cmluZyA9IGRlc3Q7XG4gICAgaWYgKGRlc3RTdHJpbmcuc3RhcnRzV2l0aCgnZ3M6Ly8nKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAnanNvbmwnLFxuICAgICAgICAgICAgZ2NzVXJpOiBkZXN0U3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChkZXN0U3RyaW5nLnN0YXJ0c1dpdGgoJ2JxOi8vJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogJ2JpZ3F1ZXJ5JyxcbiAgICAgICAgICAgIGJpZ3F1ZXJ5VXJpOiBkZXN0U3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZXN0aW5hdGlvbjogJHtkZXN0U3RyaW5nfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRSZWN2QmF0Y2hKb2JEZXN0aW5hdGlvbihkZXN0KSB7XG4gICAgLy8gRW5zdXJlIGRlc3QgaXMgYSBub24tbnVsbCBvYmplY3QgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgaWYgKHR5cGVvZiBkZXN0ICE9PSAnb2JqZWN0JyB8fCBkZXN0ID09PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBub3QgYW4gb2JqZWN0LCBpdCBjYW5ub3QgYmUgYSB2YWxpZCBCYXRjaEpvYkRlc3RpbmF0aW9uXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBvcGVyYXRpb25zIHBlcmZvcm1lZC4gUmV0dXJuIGl0IGNhc3QsIG9yIGhhbmRsZSBhcyBhbiBlcnJvci5cbiAgICAgICAgLy8gQ2FzdGluZyBhbiBlbXB0eSBvYmplY3QgbWlnaHQgYmUgYSBzYWZlIGRlZmF1bHQuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLy8gQ2FzdCB0byBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB0byBhbGxvdyBzdHJpbmcgcHJvcGVydHkgYWNjZXNzLlxuICAgIGNvbnN0IG9iaiA9IGRlc3Q7XG4gICAgLy8gU2FmZWx5IGFjY2VzcyBuZXN0ZWQgcHJvcGVydGllcy5cbiAgICBjb25zdCBpbmxpbmVSZXNwb25zZXNWYWwgPSBvYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICBpZiAodHlwZW9mIGlubGluZVJlc3BvbnNlc1ZhbCAhPT0gJ29iamVjdCcgfHwgaW5saW5lUmVzcG9uc2VzVmFsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICBjb25zdCBpbmxpbmVSZXNwb25zZXNPYmogPSBpbmxpbmVSZXNwb25zZXNWYWw7XG4gICAgY29uc3QgcmVzcG9uc2VzQXJyYXkgPSBpbmxpbmVSZXNwb25zZXNPYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzcG9uc2VzQXJyYXkpIHx8IHJlc3BvbnNlc0FycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgYW55IHJlc3BvbnNlIGhhcyB0aGUgJ2VtYmVkZGluZycgcHJvcGVydHkuXG4gICAgbGV0IGhhc0VtYmVkZGluZyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcmVzcG9uc2VJdGVtIG9mIHJlc3BvbnNlc0FycmF5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VJdGVtICE9PSAnb2JqZWN0JyB8fCByZXNwb25zZUl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSXRlbU9iaiA9IHJlc3BvbnNlSXRlbTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VWYWwgPSByZXNwb25zZUl0ZW1PYmpbJ3Jlc3BvbnNlJ107XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VWYWwgIT09ICdvYmplY3QnIHx8IHJlc3BvbnNlVmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZU9iaiA9IHJlc3BvbnNlVmFsO1xuICAgICAgICAvLyBDaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgJ2VtYmVkZGluZycga2V5LlxuICAgICAgICBpZiAocmVzcG9uc2VPYmpbJ2VtYmVkZGluZyddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhc0VtYmVkZGluZyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQZXJmb3JtIHRoZSB0cmFuc2Zvcm1hdGlvbiBpZiBhbiBlbWJlZGRpbmcgd2FzIGZvdW5kLlxuICAgIGlmIChoYXNFbWJlZGRpbmcpIHtcbiAgICAgICAgb2JqWydpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJ10gPSBvYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICAgICAgZGVsZXRlIG9ialsnaW5saW5lZFJlc3BvbnNlcyddO1xuICAgIH1cbiAgICAvLyBDYXN0IHRoZSAocG90ZW50aWFsbHkpIG1vZGlmaWVkIG9iamVjdCB0byB0aGUgdGFyZ2V0IHR5cGUuXG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgbmFtZSkge1xuICAgIGNvbnN0IG5hbWVTdHJpbmcgPSBuYW1lO1xuICAgIGlmICghYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBjb25zdCBtbGRldlBhdHRlcm4gPSAvYmF0Y2hlc1xcL1teL10rJC87XG4gICAgICAgIGlmIChtbGRldlBhdHRlcm4udGVzdChuYW1lU3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVTdHJpbmcuc3BsaXQoJy8nKS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBiYXRjaCBqb2IgbmFtZTogJHtuYW1lU3RyaW5nfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2ZXJ0ZXhQYXR0ZXJuID0gL15wcm9qZWN0c1xcL1teL10rXFwvbG9jYXRpb25zXFwvW14vXStcXC9iYXRjaFByZWRpY3Rpb25Kb2JzXFwvW14vXSskLztcbiAgICBpZiAodmVydGV4UGF0dGVybi50ZXN0KG5hbWVTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBuYW1lU3RyaW5nLnNwbGl0KCcvJykucG9wKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eXFxkKyQvLnRlc3QobmFtZVN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVTdHJpbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYmF0Y2ggam9iIG5hbWU6ICR7bmFtZVN0cmluZ30uYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdEpvYlN0YXRlKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhdGVTdHJpbmcgPSBzdGF0ZTtcbiAgICBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9VTlNQRUNJRklFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfVU5TUEVDSUZJRUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1BFTkRJTkcnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1BFTkRJTkcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1JVTk5JTkcnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1JVTk5JTkcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1NVQ0NFRURFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfU1VDQ0VFREVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9GQUlMRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0ZBSUxFRCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfQ0FOQ0VMTEVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9DQU5DRUxMRUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX0VYUElSRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0VYUElSRUQnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlU3RyaW5nO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlc0ZpbGUnXSk7XG4gICAgaWYgKGZyb21GaWxlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVOYW1lJ10sIGZyb21GaWxlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVkUmVzcG9uc2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5saW5lZFJlc3BvbnNlcycsXG4gICAgICAgICdpbmxpbmVkUmVzcG9uc2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlubGluZWRSZXNwb25zZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUlubGluZWRSZXNwb25zZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5saW5lZFJlc3BvbnNlRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lZFJlc3BvbnNlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMnLFxuICAgICAgICAnaW5saW5lZFJlc3BvbnNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21JbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJlZGljdGlvbnNGb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnY3NEZXN0aW5hdGlvbicsXG4gICAgICAgICdvdXRwdXRVcmlQcmVmaXgnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmlncXVlcnlVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdiaWdxdWVyeURlc3RpbmF0aW9uJyxcbiAgICAgICAgJ291dHB1dFVyaScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CaWdxdWVyeVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10sIGZyb21CaWdxdWVyeVVyaSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRGVzdGluYXRpb25Ub1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVkaWN0aW9uc0Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzRGVzdGluYXRpb24nLCAnb3V0cHV0VXJpUHJlZml4J10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmlncXVlcnlVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeURlc3RpbmF0aW9uJywgJ291dHB1dFVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVkUmVzcG9uc2VzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmxpbmVkUmVzcG9uc2VzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZXRhZGF0YScsXG4gICAgICAgICdkaXNwbGF5TmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnLCAnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIHRKb2JTdGF0ZShmcm9tU3RhdGUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZXRhZGF0YScsXG4gICAgICAgICdjcmVhdGVUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZXRhZGF0YScsXG4gICAgICAgICdlbmRUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZXRhZGF0YScsXG4gICAgICAgICd1cGRhdGVUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YScsICdtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc3QgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJywgJ291dHB1dCddKTtcbiAgICBpZiAoZnJvbURlc3QgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXN0J10sIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tTWxkZXYodFJlY3ZCYXRjaEpvYkRlc3RpbmF0aW9uKGZyb21EZXN0KSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYkZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIHRKb2JTdGF0ZShmcm9tU3RhdGUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgam9iRXJyb3JGcm9tVmVydGV4KGZyb21FcnJvcikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lucHV0Q29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3JjJ10sIGJhdGNoSm9iU291cmNlRnJvbVZlcnRleChmcm9tU3JjKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXN0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRDb25maWcnXSk7XG4gICAgaWYgKGZyb21EZXN0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzdCddLCBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbVZlcnRleCh0UmVjdkJhdGNoSm9iRGVzdGluYXRpb24oZnJvbURlc3QpKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iU291cmNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbnN0YW5jZXNGb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1NvdXJjZScsICd1cmlzJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmlncXVlcnlVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdiaWdxdWVyeVNvdXJjZScsXG4gICAgICAgICdpbnB1dFVyaScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CaWdxdWVyeVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10sIGZyb21CaWdxdWVyeVVyaSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iU291cmNlVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZm9ybWF0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWdxdWVyeVVyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pO1xuICAgIGlmIChmcm9tRmlsZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlTmFtZSddLCBmcm9tRmlsZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZFJlcXVlc3RzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5saW5lZFJlcXVlc3RzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlubGluZWRSZXF1ZXN0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tSW5saW5lZFJlcXVlc3RzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubGluZWRSZXF1ZXN0VG9NbGRldihhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHMnLCAncmVxdWVzdHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNGb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1NvdXJjZScsICd1cmlzJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmlncXVlcnlVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeVNvdXJjZScsICdpbnB1dFVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVkUmVxdWVzdHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lubGluZWRSZXF1ZXN0cyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JGcm9tTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5kaWRhdGVGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudCddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50J10sIGNvbnRlbnRGcm9tTWxkZXYkMihmcm9tQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2l0YXRpb25NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NpdGF0aW9uTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9uTWV0YWRhdGEnXSwgY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxKGZyb21DaXRhdGlvbk1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hSZWFzb24nXSk7XG4gICAgaWYgKGZyb21GaW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hSZWFzb24nXSwgZnJvbUZpbmlzaFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0TWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxDb250ZXh0TWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dE1ldGFkYXRhJ10sIHVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldiQyKGZyb21VcmxDb250ZXh0TWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF2Z0xvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdmdMb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUF2Z0xvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSwgZnJvbUF2Z0xvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5kZXggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2luZGV4J10pO1xuICAgIGlmIChmcm9tSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmRleCddLCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnNSZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsb2dwcm9ic1Jlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9ic1Jlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzUmVzdWx0J10sIGZyb21Mb2dwcm9ic1Jlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlSYXRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5UmF0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TYWZldHlSYXRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5UmF0aW5ncyddLCBmcm9tU2FmZXR5UmF0aW5ncyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNpdGF0aW9uTWV0YWRhdGFGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2l0YXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaXRhdGlvblNvdXJjZXMnXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaXRhdGlvbnMnXSwgZnJvbUNpdGF0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVyVXNlVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FbnZpcm9ubWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW52aXJvbm1lbnQnXSk7XG4gICAgaWYgKGZyb21FbnZpcm9ubWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vudmlyb25tZW50J10sIGZyb21FbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zJ10sIGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RW1iZWRkaW5nRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZhbHVlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmFsdWVzJ10pO1xuICAgIGlmIChmcm9tVmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmFsdWVzJ10sIGZyb21WYWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RnJvbU1sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0RnJvbU1sZGV2JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDQoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2JhdGNoJywgJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc3QnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc3QgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc3QgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnb3V0cHV0Q29uZmlnJ10sIGJhdGNoSm9iRGVzdGluYXRpb25Ub1ZlcnRleCh0QmF0Y2hKb2JEZXN0aW5hdGlvbihmcm9tRGVzdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NyYyddKTtcbiAgICBpZiAoZnJvbVNyYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JhdGNoJywgJ2lucHV0Q29uZmlnJ10sIGJhdGNoSm9iU291cmNlVG9NbGRldihhcGlDbGllbnQsIHRCYXRjaEpvYlNvdXJjZShhcGlDbGllbnQsIGZyb21TcmMpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NyYyddKTtcbiAgICBpZiAoZnJvbVNyYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lucHV0Q29uZmlnJ10sIGJhdGNoSm9iU291cmNlVG9WZXJ0ZXgodEJhdGNoSm9iU291cmNlKGFwaUNsaWVudCwgZnJvbVNyYykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlQmF0Y2hKb2JDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnYmF0Y2gnLCAnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlRW1iZWRkaW5nc0JhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3JjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcmMnXSk7XG4gICAgaWYgKGZyb21TcmMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXRjaCcsICdpbnB1dENvbmZpZyddLCBlbWJlZGRpbmdzQmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgZnJvbVNyYykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVJlc291cmNlSm9iRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGpvYkVycm9yRnJvbU1sZGV2KGZyb21FcnJvcikpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVSZXNvdXJjZUpvYkZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgam9iRXJyb3JGcm9tVmVydGV4KGZyb21FcnJvcikpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHluYW1pY1RocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1RocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNUaHJlc2hvbGQnXSwgZnJvbUR5bmFtaWNUaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRCYXRjaFRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3JlcXVlc3QnLCAnY29udGVudCddLCB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIGZyb21Db250ZW50cykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldiQxKGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXNrVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFza1R5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UYXNrVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3Rhc2tUeXBlJ10sIGZyb21UYXNrVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dERpbWVuc2lvbmFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnb3V0cHV0RGltZW5zaW9uYWxpdHknXSwgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pbWVUeXBlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dG9UcnVuY2F0ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0b1RydW5jYXRlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkZGluZ3NCYXRjaEpvYlNvdXJjZVRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pO1xuICAgIGlmIChmcm9tRmlsZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlX25hbWUnXSwgZnJvbUZpbGVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZWRSZXF1ZXN0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRSZXF1ZXN0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkUmVxdWVzdHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0cyddLCBlbWJlZENvbnRlbnRCYXRjaFRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tSW5saW5lZFJlcXVlc3RzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhRnJvbU1sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsRnJvbU1sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnXSwgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmVoYXZpb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pO1xuICAgIGlmIChmcm9tQmVoYXZpb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiZWhhdmlvciddLCBmcm9tQmVoYXZpb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYkMShhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvTWxkZXYkNCh0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZUNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVDb3VudCddLCBmcm9tQ2FuZGlkYXRlQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0b3BTZXF1ZW5jZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdG9wU2VxdWVuY2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0b3BTZXF1ZW5jZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdG9wU2VxdWVuY2VzJ10sIGZyb21TdG9wU2VxdWVuY2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUxvZ3Byb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUxvZ3Byb2JzJ10sIGZyb21SZXNwb25zZUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnMnXSwgZnJvbUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZXNlbmNlUGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVzZW5jZVBlbmFsdHknXSwgZnJvbVByZXNlbmNlUGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcmVxdWVuY3lQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnJlcXVlbmN5UGVuYWx0eSddLCBmcm9tRnJlcXVlbmN5UGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VTY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlU2NoZW1hJ10sIHNjaGVtYVRvTWxkZXYkMSh0U2NoZW1hKGZyb21SZXNwb25zZVNjaGVtYSkpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdXRpbmdDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxTZWxlY3Rpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsU2VsZWN0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlTZXR0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYWZldHlTZXR0aW5nVG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQ0KHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9NbGRldiQyKGZyb21Ub29sQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFiZWxzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DYWNoZWRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NhY2hlZENvbnRlbnQnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbUNhY2hlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgc3BlZWNoQ29uZmlnVG9NbGRldiQzKHRTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1ZGlvVGltZXN0YW1wIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgdGhpbmtpbmdDb25maWdUb01sZGV2JDMoZnJvbVRoaW5raW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21JbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10sIGltYWdlQ29uZmlnVG9NbGRldiQxKGZyb21JbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2FuZGlkYXRlcyddKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhbmRpZGF0ZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlRnJvbU1sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddLCBmcm9tTW9kZWxWZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdEZlZWRiYWNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0RmVlZGJhY2snLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0RmVlZGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRGZWVkYmFjayddLCBmcm9tUHJvbXB0RmVlZGJhY2spO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2VJZCddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUlkJ10sIGZyb21SZXNwb25zZUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkNChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgaW50ZXJ2YWxUb01sZGV2JDQoZnJvbVRpbWVSYW5nZUZpbHRlcikpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGNsdWRlRG9tYWlucyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZURvbWFpbnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAoZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIHNpbmdsZUVtYmVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBqb2JFcnJvckZyb21NbGRldihmcm9tRXJyb3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW5saW5lZFJlcXVlc3RUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb01sZGV2JDQoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0JywgJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3QnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2JDEoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbmxpbmVkUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgam9iRXJyb3JGcm9tTWxkZXYoZnJvbUVycm9yKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGludGVydmFsVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGpvYkVycm9yRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXRhaWxzJ10pO1xuICAgIGlmIChmcm9tRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RldGFpbHMnXSwgZnJvbURldGFpbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29kZSddKTtcbiAgICBpZiAoZnJvbUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlJ10sIGZyb21Db2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lc3NhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lc3NhZ2UnXSk7XG4gICAgaWYgKGZyb21NZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVzc2FnZSddLCBmcm9tTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGpvYkVycm9yRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGV0YWlscyddKTtcbiAgICBpZiAoZnJvbURldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXRhaWxzJ10sIGZyb21EZXRhaWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvZGUnXSk7XG4gICAgaWYgKGZyb21Db2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZSddLCBmcm9tQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXNzYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXNzYWdlJ10pO1xuICAgIGlmIChmcm9tTWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lc3NhZ2UnXSwgZnJvbU1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsYXRMbmdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhdGl0dWRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXRpdHVkZSddKTtcbiAgICBpZiAoZnJvbUxhdGl0dWRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGF0aXR1ZGUnXSwgZnJvbUxhdGl0dWRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvbmdpdHVkZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9uZ2l0dWRlJ10pO1xuICAgIGlmIChmcm9tTG9uZ2l0dWRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9uZ2l0dWRlJ10sIGZyb21Mb25naXR1ZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsdGVyIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdEJhdGNoSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RCYXRjaEpvYnNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhdGNoSm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3BlcmF0aW9ucyddKTtcbiAgICBpZiAoZnJvbUJhdGNoSm9icyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQmF0Y2hKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoSm9iRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmF0Y2hKb2JzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXRjaEpvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdiYXRjaFByZWRpY3Rpb25Kb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJhdGNoSm9icyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQmF0Y2hKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoSm9iRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JhdGNoSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3BlYWtlclZvaWNlQ29uZmlncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NwZWFrZXJWb2ljZUNvbmZpZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3BlYWtlclZvaWNlQ29uZmlncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU3BlYWtlclZvaWNlQ29uZmlncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDMoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVha2VyVm9pY2VDb25maWdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRGcm9tTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YUZyb21NbGRldiQyKGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JGcm9tTWxkZXYkMihmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YUZyb21NbGRldiQyKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsRnJvbU1sZGV2JDIoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhVG9NbGRldiQ0KGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2JDQoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2JDQoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxUb01sZGV2JDQoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlTmFtZSddKTtcbiAgICBpZiAoZnJvbVZvaWNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlTmFtZSddLCBmcm9tVm9pY2VOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmV0cmlldmFsQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRMbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdExuZyddKTtcbiAgICBpZiAoZnJvbUxhdExuZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdExuZyddLCBsYXRMbmdUb01sZGV2JDIoZnJvbUxhdExuZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eVNldHRpbmdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0aG9kJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhdGVnb3J5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYXRlZ29yeSddKTtcbiAgICBpZiAoZnJvbUNhdGVnb3J5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcnknXSwgZnJvbUNhdGVnb3J5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhyZXNob2xkJ10pO1xuICAgIGlmIChmcm9tVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhyZXNob2xkJ10sIGZyb21UaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzY2hlbWFUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFueU9mID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhbnlPZiddKTtcbiAgICBpZiAoZnJvbUFueU9mICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYW55T2YnXSwgZnJvbUFueU9mKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RlZmF1bHQnXSk7XG4gICAgaWYgKGZyb21EZWZhdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVmYXVsdCddLCBmcm9tRGVmYXVsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnVtJ10pO1xuICAgIGlmIChmcm9tRW51bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VudW0nXSwgZnJvbUVudW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhhbXBsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhhbXBsZSddKTtcbiAgICBpZiAoZnJvbUV4YW1wbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGFtcGxlJ10sIGZyb21FeGFtcGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2l0ZW1zJ10pO1xuICAgIGlmIChmcm9tSXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpdGVtcyddLCBmcm9tSXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4SXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heEl0ZW1zJ10pO1xuICAgIGlmIChmcm9tTWF4SXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhJdGVtcyddLCBmcm9tTWF4SXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4TGVuZ3RoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhMZW5ndGgnXSk7XG4gICAgaWYgKGZyb21NYXhMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhMZW5ndGgnXSwgZnJvbU1heExlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhQcm9wZXJ0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4UHJvcGVydGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhQcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4UHJvcGVydGllcyddLCBmcm9tTWF4UHJvcGVydGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhpbXVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhpbXVtJ10pO1xuICAgIGlmIChmcm9tTWF4aW11bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heGltdW0nXSwgZnJvbU1heGltdW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWluSXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbkl0ZW1zJ10pO1xuICAgIGlmIChmcm9tTWluSXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5JdGVtcyddLCBmcm9tTWluSXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWluTGVuZ3RoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5MZW5ndGgnXSk7XG4gICAgaWYgKGZyb21NaW5MZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5MZW5ndGgnXSwgZnJvbU1pbkxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5Qcm9wZXJ0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWluUHJvcGVydGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NaW5Qcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluUHJvcGVydGllcyddLCBmcm9tTWluUHJvcGVydGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5pbXVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5pbXVtJ10pO1xuICAgIGlmIChmcm9tTWluaW11bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbmltdW0nXSwgZnJvbU1pbmltdW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVsbGFibGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ251bGxhYmxlJ10pO1xuICAgIGlmIChmcm9tTnVsbGFibGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydudWxsYWJsZSddLCBmcm9tTnVsbGFibGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGF0dGVybiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGF0dGVybiddKTtcbiAgICBpZiAoZnJvbVBhdHRlcm4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXR0ZXJuJ10sIGZyb21QYXR0ZXJuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb3BlcnRpZXMnXSk7XG4gICAgaWYgKGZyb21Qcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvcGVydGllcyddLCBmcm9tUHJvcGVydGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9wZXJ0eU9yZGVyaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvcGVydHlPcmRlcmluZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9wZXJ0eU9yZGVyaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvcGVydHlPcmRlcmluZyddLCBmcm9tUHJvcGVydHlPcmRlcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXF1aXJlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVxdWlyZWQnXSk7XG4gICAgaWYgKGZyb21SZXF1aXJlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVpcmVkJ10sIGZyb21SZXF1aXJlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0eXBlJ10pO1xuICAgIGlmIChmcm9tVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R5cGUnXSwgZnJvbVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzaW5nbGVFbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRW1iZWRkaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbWJlZGRpbmcnXSk7XG4gICAgaWYgKGZyb21FbWJlZGRpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbWJlZGRpbmcnXSwgY29udGVudEVtYmVkZGluZ0Zyb21NbGRldiQxKGZyb21FbWJlZGRpbmcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSk7XG4gICAgaWYgKGZyb21Ub2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5Db3VudCddLCBmcm9tVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3BlYWtlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlYWtlciddKTtcbiAgICBpZiAoZnJvbVNwZWFrZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVha2VyJ10sIGZyb21TcGVha2VyKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2JDMoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNwZWVjaENvbmZpZ1RvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvTWxkZXYkMyhmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyddLCBtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMyhmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10pO1xuICAgIGlmIChmcm9tTGFuZ3VhZ2VDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10sIGZyb21MYW5ndWFnZUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0aGlua2luZ0NvbmZpZ1RvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW5jbHVkZVRob3VnaHRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVRob3VnaHRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUluY2x1ZGVUaG91Z2h0cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luY2x1ZGVUaG91Z2h0cyddLCBmcm9tSW5jbHVkZVRob3VnaHRzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQnVkZ2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdCdWRnZXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdCdWRnZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0J1ZGdldCddLCBmcm9tVGhpbmtpbmdCdWRnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJ10sIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMihmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsQ29uZmlnJ10sIHJldHJpZXZhbENvbmZpZ1RvTWxkZXYkMihmcm9tUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDQoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQ0KGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQ0KGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb29nbGVNYXBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgdXJsQ29udGV4dFRvTWxkZXYkNCgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgY29tcHV0ZXJVc2VUb01sZGV2JDQoZnJvbUNvbXB1dGVyVXNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmxNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsTWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21VcmxNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVXJsTWV0YWRhdGE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsTWV0YWRhdGFGcm9tTWxkZXYkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybE1ldGFkYXRhJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRUb01sZGV2JDQoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxNZXRhZGF0YUZyb21NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21SZXRyaWV2ZWRVcmwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZlZFVybCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZlZFVybCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZlZFVybCddLCBmcm9tUmV0cmlldmVkVXJsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybFJldHJpZXZhbFN0YXR1cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VybFJldHJpZXZhbFN0YXR1cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcmxSZXRyaWV2YWxTdGF0dXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxSZXRyaWV2YWxTdGF0dXMnXSwgZnJvbVVybFJldHJpZXZhbFN0YXR1cyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFGcm9tTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YVRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdm9pY2VDb25maWdUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVidWlsdFZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVidWlsdFZvaWNlQ29uZmlnJ10sIHByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2JDMoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG52YXIgUGFnZWRJdGVtO1xuKGZ1bmN0aW9uIChQYWdlZEl0ZW0pIHtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0JBVENIX0pPQlNcIl0gPSBcImJhdGNoSm9ic1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fTU9ERUxTXCJdID0gXCJtb2RlbHNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX1RVTklOR19KT0JTXCJdID0gXCJ0dW5pbmdKb2JzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9GSUxFU1wiXSA9IFwiZmlsZXNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0NBQ0hFRF9DT05URU5UU1wiXSA9IFwiY2FjaGVkQ29udGVudHNcIjtcbn0pKFBhZ2VkSXRlbSB8fCAoUGFnZWRJdGVtID0ge30pKTtcbi8qKlxuICogUGFnZXIgY2xhc3MgZm9yIGl0ZXJhdGluZyB0aHJvdWdoIHBhZ2luYXRlZCByZXN1bHRzLlxuICovXG5jbGFzcyBQYWdlciB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcmVxdWVzdCwgcmVzcG9uc2UsIHBhcmFtcykge1xuICAgICAgICB0aGlzLnBhZ2VJbnRlcm5hbCA9IFtdO1xuICAgICAgICB0aGlzLnBhcmFtc0ludGVybmFsID0ge307XG4gICAgICAgIHRoaXMucmVxdWVzdEludGVybmFsID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5pbml0KG5hbWUsIHJlc3BvbnNlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBpbml0KG5hbWUsIHJlc3BvbnNlLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5uYW1lSW50ZXJuYWwgPSBuYW1lO1xuICAgICAgICB0aGlzLnBhZ2VJbnRlcm5hbCA9IHJlc3BvbnNlW3RoaXMubmFtZUludGVybmFsXSB8fCBbXTtcbiAgICAgICAgdGhpcy5zZGtIdHRwUmVzcG9uc2VJbnRlcm5hbCA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2U7XG4gICAgICAgIHRoaXMuaWR4SW50ZXJuYWwgPSAwO1xuICAgICAgICBsZXQgcmVxdWVzdFBhcmFtcyA9IHsgY29uZmlnOiB7fSB9O1xuICAgICAgICBpZiAoIXBhcmFtcyB8fCBPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IHsgY29uZmlnOiB7fSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3RQYXJhbXNbJ2NvbmZpZyddKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zWydjb25maWcnXVsncGFnZVRva2VuJ10gPSByZXNwb25zZVsnbmV4dFBhZ2VUb2tlbiddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyYW1zSW50ZXJuYWwgPSByZXF1ZXN0UGFyYW1zO1xuICAgICAgICB0aGlzLnBhZ2VJbnRlcm5hbFNpemUgPVxuICAgICAgICAgICAgKF9iID0gKF9hID0gcmVxdWVzdFBhcmFtc1snY29uZmlnJ10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsncGFnZVNpemUnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5wYWdlSW50ZXJuYWwubGVuZ3RoO1xuICAgIH1cbiAgICBpbml0TmV4dFBhZ2UocmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5pbml0KHRoaXMubmFtZUludGVybmFsLCByZXNwb25zZSwgdGhpcy5wYXJhbXNJbnRlcm5hbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGFnZSwgd2hpY2ggaXMgYSBsaXN0IG9mIGl0ZW1zLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgZmlyc3QgcGFnZSBpcyByZXRyaWV2ZWQgd2hlbiB0aGUgcGFnZXIgaXMgY3JlYXRlZC4gVGhlIHJldHVybmVkIGxpc3Qgb2ZcbiAgICAgKiBpdGVtcyBjb3VsZCBiZSBhIHN1YnNldCBvZiB0aGUgZW50aXJlIGxpc3QuXG4gICAgICovXG4gICAgZ2V0IHBhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHlwZSBvZiBwYWdlZCBpdGVtIChmb3IgZXhhbXBsZSwgYGBiYXRjaF9qb2JzYGApLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgcGFnZSBmZXRjaGVkIGVhY2ggdGltZSBieSB0aGlzIHBhZ2VyLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBwYWdlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGFnZSBsZW5ndGguXG4gICAgICovXG4gICAgZ2V0IHBhZ2VTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWxTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWFkZXJzIG9mIHRoZSBBUEkgcmVzcG9uc2UuXG4gICAgICovXG4gICAgZ2V0IHNka0h0dHBSZXNwb25zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2RrSHR0cFJlc3BvbnNlSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhcmFtZXRlcnMgd2hlbiBtYWtpbmcgdGhlIEFQSSByZXF1ZXN0IGZvciB0aGUgbmV4dCBwYWdlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBQYXJhbWV0ZXJzIGNvbnRhaW4gYSBzZXQgb2Ygb3B0aW9uYWwgY29uZmlncyB0aGF0IGNhbiBiZVxuICAgICAqIHVzZWQgdG8gY3VzdG9taXplIHRoZSBBUEkgcmVxdWVzdC4gRm9yIGV4YW1wbGUsIHRoZSBgcGFnZVRva2VuYCBwYXJhbWV0ZXJcbiAgICAgKiBjb250YWlucyB0aGUgdG9rZW4gdG8gcmVxdWVzdCB0aGUgbmV4dCBwYWdlLlxuICAgICAqL1xuICAgIGdldCBwYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtc0ludGVybmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGN1cnJlbnQgcGFnZS5cbiAgICAgKi9cbiAgICBnZXQgcGFnZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUludGVybmFsLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaXRlbSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICovXG4gICAgZ2V0SXRlbShpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWxbaW5kZXhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFzeW5jIGl0ZXJhdG9yIHRoYXQgc3VwcG9ydCBpdGVyYXRpbmcgdGhyb3VnaCBhbGwgaXRlbXNcbiAgICAgKiByZXRyaWV2ZWQgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgaXRlcmF0b3Igd2lsbCBhdXRvbWF0aWNhbGx5IGZldGNoIHRoZSBuZXh0IHBhZ2UgaWYgdGhlcmUgYXJlIG1vcmUgaXRlbXNcbiAgICAgKiB0byBmZXRjaCBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBwYWdlciA9IGF3YWl0IGFpLmZpbGVzLmxpc3Qoe2NvbmZpZzoge3BhZ2VTaXplOiAxMH19KTtcbiAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGZpbGUgb2YgcGFnZXIpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWR4SW50ZXJuYWwgPj0gdGhpcy5wYWdlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc05leHRQYWdlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubmV4dFBhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5nZXRJdGVtKHRoaXMuaWR4SW50ZXJuYWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuaWR4SW50ZXJuYWwgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXR1cm46IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBuZXh0IHBhZ2Ugb2YgaXRlbXMuIFRoaXMgbWFrZXMgYSBuZXcgQVBJIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgYXJlIG5vIG1vcmUgcGFnZXMgdG8gZmV0Y2guXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBwYWdlciA9IGF3YWl0IGFpLmZpbGVzLmxpc3Qoe2NvbmZpZzoge3BhZ2VTaXplOiAxMH19KTtcbiAgICAgKiBsZXQgcGFnZSA9IHBhZ2VyLnBhZ2U7XG4gICAgICogd2hpbGUgKHRydWUpIHtcbiAgICAgKiAgIGZvciAoY29uc3QgZmlsZSBvZiBwYWdlKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogICB9XG4gICAgICogICBpZiAoIXBhZ2VyLmhhc05leHRQYWdlKCkpIHtcbiAgICAgKiAgICAgYnJlYWs7XG4gICAgICogICB9XG4gICAgICogICBwYWdlID0gYXdhaXQgcGFnZXIubmV4dFBhZ2UoKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgbmV4dFBhZ2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1vcmUgcGFnZXMgdG8gZmV0Y2guJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3RJbnRlcm5hbCh0aGlzLnBhcmFtcyk7XG4gICAgICAgIHRoaXMuaW5pdE5leHRQYWdlKHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBtb3JlIHBhZ2VzIHRvIGZldGNoIGZyb20gdGhlIEFQSS5cbiAgICAgKi9cbiAgICBoYXNOZXh0UGFnZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMucGFyYW1zWydjb25maWcnXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWydwYWdlVG9rZW4nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQmF0Y2hlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBiYXRjaCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGJhdGNoIGpvYiByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGJhdGNoIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5iYXRjaGVzLmNyZWF0ZSh7XG4gICAgICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgICAgICogICBzcmM6IHtnY3NVcmk6ICdnczovL2J1Y2tldC9wYXRoL3RvL2ZpbGUuanNvbmwnLCBmb3JtYXQ6ICdqc29ubCd9LFxuICAgICAgICAgKiAgIGNvbmZpZzoge1xuICAgICAgICAgKiAgICAgZGVzdDoge2djc1VyaTogJ2dzOi8vYnVja2V0L3BhdGgvb3V0cHV0L2RpcmVjdG9yeScsIGZvcm1hdDogJ2pzb25sJ30sXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgZGVzdGluYXRpb24gaWYgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgLy8gQ2FzdCBwYXJhbXMuc3JjIGFzIFZlcnRleCBBSSBwYXRoIGRvZXMgbm90IGhhbmRsZSBJbmxpbmVkUmVxdWVzdFtdXG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZyA9IHRoaXMuZm9ybWF0RGVzdGluYXRpb24ocGFyYW1zLnNyYywgcGFyYW1zLmNvbmZpZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1MREVWXG4gICAgICAgICAgICBjb25zdCBzcmMgPSBwYXJhbXMuc3JjO1xuICAgICAgICAgICAgY29uc3QgaXNfaW5saW5lZCA9IEFycmF5LmlzQXJyYXkocGFyYW1zLnNyYykgfHwgc3JjLmlubGluZWRSZXF1ZXN0cyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCFpc19pbmxpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElubGluZWQgZ2VuZXJhdGUgY29udGVudCByZXF1ZXN0cyBoYW5kbGluZ1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jcmVhdGVJbmxpbmVkR2VuZXJhdGVDb250ZW50UmVxdWVzdChwYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHJlc3VsdC5wYXRoO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSByZXN1bHQuYm9keTtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKVsnX3F1ZXJ5J10gfHwge307XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICoqRXhwZXJpbWVudGFsKiogQ3JlYXRlcyBhbiBlbWJlZGRpbmcgYmF0Y2ggam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0ZSBlbWJlZGRpbmcgYmF0Y2ggam9iIHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYmF0Y2ggam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmJhdGNoZXMuY3JlYXRlRW1iZWRkaW5ncyh7XG4gICAgICAgICAqICAgbW9kZWw6ICd0ZXh0LWVtYmVkZGluZy0wMDQnLFxuICAgICAgICAgKiAgIHNyYzoge2ZpbGVOYW1lOiAnZmlsZXMvbXlfZW1iZWRkaW5nX2lucHV0J30sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVFbWJlZGRpbmdzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYmF0Y2hlcy5jcmVhdGVFbWJlZGRpbmdzKCkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIHdpdGhvdXQgbm90aWNlLicpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IEFJIGRvZXMgbm90IHN1cHBvcnQgYmF0Y2hlcy5jcmVhdGVFbWJlZGRpbmdzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTUxERVZcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IHBhcmFtcy5zcmM7XG4gICAgICAgICAgICBjb25zdCBpc19pbmxpbmVkID0gc3JjLmlubGluZWRSZXF1ZXN0cyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCFpc19pbmxpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRW1iZWRkaW5nc0ludGVybmFsKHBhcmFtcyk7IC8vIEZpeGVkIHR5cG8gaGVyZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5saW5lZCBlbWJlZCBjb250ZW50IHJlcXVlc3RzIGhhbmRsaW5nXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZUlubGluZWRFbWJlZENvbnRlbnRSZXF1ZXN0KHBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gcmVzdWx0LnBhdGg7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHJlc3VsdC5ib2R5O1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKVsnX3F1ZXJ5J10gfHwge307XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGJhdGNoIGpvYiBjb25maWd1cmF0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBwYWdpbmF0ZWQgcmVzdWx0cyBvZiB0aGUgbGlzdCBvZiBiYXRjaCBqb2JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCBiYXRjaEpvYnMgPSBhd2FpdCBhaS5iYXRjaGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgYmF0Y2hKb2Igb2YgYmF0Y2hKb2JzKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coYmF0Y2hKb2IpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0JBVENIX0pPQlMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwocGFyYW1zKSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSBpbmxpbmVkIGdlbmVyYXRlIGNvbnRlbnQgcmVxdWVzdHNcbiAgICBjcmVhdGVJbmxpbmVkR2VuZXJhdGVDb250ZW50UmVxdWVzdChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIC8vIFVzZSBpbnN0YW5jZSBhcGlDbGllbnRcbiAgICAgICAgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gYm9keVsnX3VybCddO1xuICAgICAgICBjb25zdCBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmJhdGNoR2VuZXJhdGVDb250ZW50JywgdXJsUGFyYW1zKTtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBib2R5WydiYXRjaCddO1xuICAgICAgICBjb25zdCBpbnB1dENvbmZpZyA9IGJhdGNoWydpbnB1dENvbmZpZyddO1xuICAgICAgICBjb25zdCByZXF1ZXN0c1dyYXBwZXIgPSBpbnB1dENvbmZpZ1sncmVxdWVzdHMnXTtcbiAgICAgICAgY29uc3QgcmVxdWVzdHMgPSByZXF1ZXN0c1dyYXBwZXJbJ3JlcXVlc3RzJ107XG4gICAgICAgIGNvbnN0IG5ld1JlcXVlc3RzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdERpY3QgPSBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KTsgLy8gQ2xvbmVcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0RGljdFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5c3RlbUluc3RydWN0aW9uVmFsdWUgPSByZXF1ZXN0RGljdFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ3N5c3RlbUluc3RydWN0aW9uJ107XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdENvbnRlbnQgPSByZXF1ZXN0RGljdFsncmVxdWVzdCddO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RDb250ZW50WydzeXN0ZW1JbnN0cnVjdGlvbiddID0gc3lzdGVtSW5zdHJ1Y3Rpb25WYWx1ZTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGljdFsncmVxdWVzdCddID0gcmVxdWVzdENvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdSZXF1ZXN0cy5wdXNoKHJlcXVlc3REaWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0c1dyYXBwZXJbJ3JlcXVlc3RzJ10gPSBuZXdSZXF1ZXN0cztcbiAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgIHJldHVybiB7IHBhdGgsIGJvZHkgfTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSBpbmxpbmVkIGVtYmVkZGluZyByZXF1ZXN0c1xuICAgIGNyZWF0ZUlubGluZWRFbWJlZENvbnRlbnRSZXF1ZXN0KHBhcmFtcykge1xuICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRW1iZWRkaW5nc0JhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIC8vIFVzZSBpbnN0YW5jZSBhcGlDbGllbnRcbiAgICAgICAgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gYm9keVsnX3VybCddO1xuICAgICAgICBjb25zdCBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmFzeW5jQmF0Y2hFbWJlZENvbnRlbnQnLCB1cmxQYXJhbXMpO1xuICAgICAgICBjb25zdCBiYXRjaCA9IGJvZHlbJ2JhdGNoJ107XG4gICAgICAgIGNvbnN0IGlucHV0Q29uZmlnID0gYmF0Y2hbJ2lucHV0Q29uZmlnJ107XG4gICAgICAgIGNvbnN0IHJlcXVlc3RzV3JhcHBlciA9IGlucHV0Q29uZmlnWydyZXF1ZXN0cyddO1xuICAgICAgICBjb25zdCByZXF1ZXN0cyA9IHJlcXVlc3RzV3JhcHBlclsncmVxdWVzdHMnXTtcbiAgICAgICAgY29uc3QgbmV3UmVxdWVzdHMgPSBbXTtcbiAgICAgICAgZGVsZXRlIHJlcXVlc3RzV3JhcHBlclsnY29uZmlnJ107IC8vIFJlbW92ZSB0b3AtbGV2ZWwgY29uZmlnXG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdERpY3QgPSBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KTsgLy8gQ2xvbmVcbiAgICAgICAgICAgIGNvbnN0IGlubmVyUmVxdWVzdCA9IHJlcXVlc3REaWN0WydyZXF1ZXN0J107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXF1ZXN0RGljdCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdyZXF1ZXN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpbm5lclJlcXVlc3Rba2V5XSA9IHJlcXVlc3REaWN0W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1JlcXVlc3RzLnB1c2gocmVxdWVzdERpY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RzV3JhcHBlclsncmVxdWVzdHMnXSA9IG5ld1JlcXVlc3RzO1xuICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgcmV0dXJuIHsgcGF0aCwgYm9keSB9O1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBmaXJzdCBHQ1MgVVJJXG4gICAgZ2V0R2NzVXJpKHNyYykge1xuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBzcmMuc3RhcnRzV2l0aCgnZ3M6Ly8nKSA/IHNyYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSAmJiBzcmMuZ2NzVXJpICYmIHNyYy5nY3NVcmkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNyYy5nY3NVcmlbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgQmlnUXVlcnkgVVJJXG4gICAgZ2V0QmlncXVlcnlVcmkoc3JjKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHNyYy5zdGFydHNXaXRoKCdicTovLycpID8gc3JjIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjLmJpZ3F1ZXJ5VXJpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEZ1bmN0aW9uIHRvIGZvcm1hdCB0aGUgZGVzdGluYXRpb24gY29uZmlndXJhdGlvbiBmb3IgVmVydGV4IEFJXG4gICAgZm9ybWF0RGVzdGluYXRpb24oc3JjLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgbmV3Q29uZmlnID0gY29uZmlnID8gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSA6IHt9O1xuICAgICAgICBjb25zdCB0aW1lc3RhbXBTdHIgPSBEYXRlLm5vdygpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghbmV3Q29uZmlnLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICBuZXdDb25maWcuZGlzcGxheU5hbWUgPSBgZ2VuYWlCYXRjaEpvYl8ke3RpbWVzdGFtcFN0cn1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDb25maWcuZGVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBnY3NVcmkgPSB0aGlzLmdldEdjc1VyaShzcmMpO1xuICAgICAgICAgICAgY29uc3QgYmlncXVlcnlVcmkgPSB0aGlzLmdldEJpZ3F1ZXJ5VXJpKHNyYyk7XG4gICAgICAgICAgICBpZiAoZ2NzVXJpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdjc1VyaS5lbmRzV2l0aCgnLmpzb25sJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIC5qc29ubCBmaWxlcywgcmVtb3ZlIHN1ZmZpeCBhbmQgYWRkIC9kZXN0XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbmZpZy5kZXN0ID0gYCR7Z2NzVXJpLnNsaWNlKDAsIC02KX0vZGVzdGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBmb3Igb3RoZXIgR0NTIFVSSXNcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29uZmlnLmRlc3QgPSBgJHtnY3NVcml9X2Rlc3RfJHt0aW1lc3RhbXBTdHJ9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaWdxdWVyeVVyaSkge1xuICAgICAgICAgICAgICAgIG5ld0NvbmZpZy5kZXN0ID0gYCR7YmlncXVlcnlVcml9X2Rlc3RfJHt0aW1lc3RhbXBTdHJ9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc291cmNlIGZvciBWZXJ0ZXggQUk6IE5vIEdDUyBvciBCaWdRdWVyeSBVUkkgZm91bmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0NvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGNyZWF0ZSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0ZSBiYXRjaCBqb2IgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpiYXRjaEdlbmVyYXRlQ29udGVudCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGNyZWF0ZSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0ZSBiYXRjaCBqb2IgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUVtYmVkZGluZ3NJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRW1iZWRkaW5nc0JhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmFzeW5jQmF0Y2hFbWJlZENvbnRlbnQnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYmF0Y2ggam9iIGNvbmZpZ3VyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmJhdGNoZXMuZ2V0KHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzL3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoZXMve25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjYW5jZWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBlbXB0eSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmJhdGNoZXMuY2FuY2VsKHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNhbmNlbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icy97bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaGVzL3tuYW1lfTpjYW5jZWwnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RCYXRjaEpvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRlbGV0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuYmF0Y2hlcy5kZWxldGUoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMve25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVSZXNvdXJjZUpvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoZXMve25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVSZXNvdXJjZUpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gYXBpS2V5Q29uZmlnVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXBpS2V5U3RyaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcGlLZXlTdHJpbmcnXSk7XG4gICAgaWYgKGZyb21BcGlLZXlTdHJpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcGlLZXlTdHJpbmcnXSwgZnJvbUFwaUtleVN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGF1dGhDb25maWdUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BcGlLZXlDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FwaUtleUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUFwaUtleUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FwaUtleUNvbmZpZyddLCBhcGlLZXlDb25maWdUb1ZlcnRleCQyKGZyb21BcGlLZXlDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1dGhUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoVHlwZSddKTtcbiAgICBpZiAoZnJvbUF1dGhUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXV0aFR5cGUnXSwgZnJvbUF1dGhUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VydmljZUFjY291bnRDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyddLCBmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2h0dHBCYXNpY0F1dGhDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2h0dHBCYXNpY0F1dGhDb25maWcnXSwgZnJvbUh0dHBCYXNpY0F1dGhDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT2F1dGhDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ29hdXRoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tT2F1dGhDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvYXV0aENvbmZpZyddLCBmcm9tT2F1dGhDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT2lkY0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb2lkY0NvbmZpZyddKTtcbiAgICBpZiAoZnJvbU9pZGNDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvaWRjQ29uZmlnJ10sIGZyb21PaWRjQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYWNoZWRDb250ZW50RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgZnJvbVVzYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYWNoZWRDb250ZW50RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAoZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZXJVc2VUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUVudmlyb25tZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnZpcm9ubWVudCddKTtcbiAgICBpZiAoZnJvbUVudmlyb25tZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW52aXJvbm1lbnQnXSwgZnJvbUVudmlyb25tZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMnXSwgZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVyVXNlVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRW52aXJvbm1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vudmlyb25tZW50J10pO1xuICAgIGlmIChmcm9tRW52aXJvbm1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnZpcm9ubWVudCddLCBmcm9tRW52aXJvbm1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyddLCBmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDMoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9WZXJ0ZXgkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UdGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R0bCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR0bCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dGwnXSwgZnJvbVR0bCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldiQzKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDModENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDMoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgdG9vbENvbmZpZ1RvTWxkZXYkMShmcm9tVG9vbENvbmZpZykpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydrbXNLZXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrbXNLZXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UdGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R0bCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR0bCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dGwnXSwgZnJvbVR0bCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9WZXJ0ZXgkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9WZXJ0ZXgkMih0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgdG9vbENvbmZpZ1RvVmVydGV4JDEoZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUttc0tleU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ttc0tleU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21LbXNLZXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2VuY3J5cHRpb25fc3BlYycsICdrbXNLZXlOYW1lJ10sIGZyb21LbXNLZXlOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgdENhY2hlc01vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIHRDYWNoZXNNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHluYW1pY1RocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1RocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNUaHJlc2hvbGQnXSwgZnJvbUR5bmFtaWNUaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRXhjbHVkZURvbWFpbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGNsdWRlRG9tYWlucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGNsdWRlRG9tYWlucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10sIGZyb21FeGNsdWRlRG9tYWlucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhbGxvd2VkRnVuY3Rpb25OYW1lcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJ10sIGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnXSwgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmVoYXZpb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pO1xuICAgIGlmIChmcm9tQmVoYXZpb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiZWhhdmlvciddLCBmcm9tQmVoYXZpb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZWhhdmlvciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUF1dGhDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhDb25maWcnXSk7XG4gICAgaWYgKGZyb21BdXRoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXV0aENvbmZpZyddLCBhdXRoQ29uZmlnVG9WZXJ0ZXgkMihmcm9tQXV0aENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljUmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljUmV0cmlldmFsQ29uZmlnJ10sIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDMoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvVmVydGV4JDIoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGludGVydmFsVG9NbGRldiQzKGZyb21UaW1lUmFuZ2VGaWx0ZXIpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgaW50ZXJ2YWxUb1ZlcnRleCQyKGZyb21UaW1lUmFuZ2VGaWx0ZXIpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4Y2x1ZGVEb21haW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZURvbWFpbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZURvbWFpbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGNsdWRlRG9tYWlucyddLCBmcm9tRXhjbHVkZURvbWFpbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbnRlcnZhbFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbnRlcnZhbFRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGF0TG5nVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRpdHVkZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0aXR1ZGUnXSk7XG4gICAgaWYgKGZyb21MYXRpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdGl0dWRlJ10sIGZyb21MYXRpdHVkZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb25naXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvbmdpdHVkZSddKTtcbiAgICBpZiAoZnJvbUxvbmdpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvbmdpdHVkZSddLCBmcm9tTG9uZ2l0dWRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGF0TG5nVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGF0aXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdGl0dWRlJ10pO1xuICAgIGlmIChmcm9tTGF0aXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXRpdHVkZSddLCBmcm9tTGF0aXR1ZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9uZ2l0dWRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb25naXR1ZGUnXSk7XG4gICAgaWYgKGZyb21Mb25naXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb25naXR1ZGUnXSwgZnJvbUxvbmdpdHVkZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhY2hlZENvbnRlbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENvbnRlbnRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZWRDb250ZW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRDb250ZW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFUb01sZGV2JDMoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkMyhmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkMyhmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMyhmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhVG9WZXJ0ZXgkMihmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9WZXJ0ZXgkMihmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvVmVydGV4JDIoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxUb1ZlcnRleCQyKGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmV0cmlldmFsQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRMbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdExuZyddKTtcbiAgICBpZiAoZnJvbUxhdExuZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdExuZyddLCBsYXRMbmdUb01sZGV2JDEoZnJvbUxhdExuZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJldHJpZXZhbENvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhdExuZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0TG5nJ10pO1xuICAgIGlmIChmcm9tTGF0TG5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGF0TG5nJ10sIGxhdExuZ1RvVmVydGV4JDEoZnJvbUxhdExuZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQxKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWxDb25maWcnXSwgcmV0cmlldmFsQ29uZmlnVG9NbGRldiQxKGZyb21SZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9WZXJ0ZXgkMShmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsQ29uZmlnJ10sIHJldHJpZXZhbENvbmZpZ1RvVmVydGV4JDEoZnJvbVJldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQzKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYkMyhmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkMyhmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ29vZ2xlTWFwcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIHVybENvbnRleHRUb01sZGV2JDMoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGNvbXB1dGVyVXNlVG9NbGRldiQzKGZyb21Db21wdXRlclVzZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWwnXSwgZnJvbVJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb1ZlcnRleCQyKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgkMihmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnRlcnByaXNlV2ViU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW50ZXJwcmlzZVdlYlNlYXJjaCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddLCBlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgkMihmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb1ZlcnRleCQyKGZyb21Hb29nbGVNYXBzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgdXJsQ29udGV4dFRvVmVydGV4JDIoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGNvbXB1dGVyVXNlVG9WZXJ0ZXgkMihmcm9tQ29tcHV0ZXJVc2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UdGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R0bCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR0bCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dGwnXSwgZnJvbVR0bCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxDb250ZXh0VG9NbGRldiQzKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dFRvVmVydGV4JDIoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBDYWNoZXMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyBjYWNoZWQgY29udGVudCBjb25maWd1cmF0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBwYWdpbmF0ZWQgcmVzdWx0cyBvZiB0aGUgbGlzdCBvZiBjYWNoZWQgY29udGVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGNhY2hlZENvbnRlbnRzID0gYXdhaXQgYWkuY2FjaGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgY2FjaGVkQ29udGVudCBvZiBjYWNoZWRDb250ZW50cykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGNhY2hlZENvbnRlbnQpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0NBQ0hFRF9DT05URU5UUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2FjaGVkIGNvbnRlbnRzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDb250ZXh0IGNhY2hpbmcgaXMgb25seSBzdXBwb3J0ZWQgZm9yIHNwZWNpZmljIG1vZGVscy4gU2VlIFtHZW1pbmlcbiAgICAgKiBEZXZlbG9wZXIgQVBJIHJlZmVyZW5jZV0oaHR0cHM6Ly9haS5nb29nbGUuZGV2L2dlbWluaS1hcGkvZG9jcy9jYWNoaW5nP2xhbmc9bm9kZS9jb250ZXh0LWNhYylcbiAgICAgKiBhbmQgW1ZlcnRleCBBSSByZWZlcmVuY2VdKGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZ2VuZXJhdGl2ZS1haS9kb2NzL2NvbnRleHQtY2FjaGUvY29udGV4dC1jYWNoZS1vdmVydmlldyNzdXBwb3J0ZWRfbW9kZWxzKVxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgY3JlYXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb250ZW50cyA9IC4uLjsgLy8gSW5pdGlhbGl6ZSB0aGUgY29udGVudCB0byBjYWNoZS5cbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmNhY2hlcy5jcmVhdGUoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAnY29udGVudHMnOiBjb250ZW50cyxcbiAgICAgKiAgICAnZGlzcGxheU5hbWUnOiAndGVzdCBjYWNoZScsXG4gICAgICogICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ1doYXQgaXMgdGhlIHN1bSBvZiB0aGUgdHdvIHBkZnM/JyxcbiAgICAgKiAgICAndHRsJzogJzg2NDAwcycsXG4gICAgICogIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdjYWNoZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FjaGVkQ29udGVudEZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnY2FjaGVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNhY2hlZENvbnRlbnRGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjYWNoZWQgY29udGVudCBjb25maWd1cmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGdldCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNhY2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmNhY2hlcy5nZXQoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNhY2hlZENvbnRlbnRGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjYWNoZWRDb250ZW50RnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2FjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkZWxldGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBlbXB0eSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmNhY2hlcy5kZWxldGUoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjYWNoZWQgY29udGVudCBjb25maWd1cmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIHVwZGF0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgY2FjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5jYWNoZXMudXBkYXRlKHtcbiAgICAgKiAgIG5hbWU6ICcuLi4nLCAgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiAgIGNvbmZpZzogeyd0dGwnOiAnNzYwMHMnfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNhY2hlZENvbnRlbnRGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNhY2hlZENvbnRlbnRGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlc3BvbnNlIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAocmVzcG9uc2UuY2FuZGlkYXRlcyA9PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UuY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gKF9hID0gcmVzcG9uc2UuY2FuZGlkYXRlc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQ7XG4gICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc1ZhbGlkQ29udGVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAoY29udGVudC5wYXJ0cyA9PT0gdW5kZWZpbmVkIHx8IGNvbnRlbnQucGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQucGFydHMpIHtcbiAgICAgICAgaWYgKHBhcnQgPT09IHVuZGVmaW5lZCB8fCBPYmplY3Qua2V5cyhwYXJ0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBoaXN0b3J5IGNvbnRhaW5zIHRoZSBjb3JyZWN0IHJvbGVzLlxuICpcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHVzZXIgdHVybi5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgY29udGFpbnMgYW4gaW52YWxpZCByb2xlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSkge1xuICAgIC8vIEVtcHR5IGhpc3RvcnkgaXMgdmFsaWQuXG4gICAgaWYgKGhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb250ZW50IG9mIGhpc3RvcnkpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQucm9sZSAhPT0gJ3VzZXInICYmIGNvbnRlbnQucm9sZSAhPT0gJ21vZGVsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb2xlIG11c3QgYmUgdXNlciBvciBtb2RlbCwgYnV0IGdvdCAke2NvbnRlbnQucm9sZX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBjdXJhdGVkICh2YWxpZCkgaGlzdG9yeSBmcm9tIGEgY29tcHJlaGVuc2l2ZSBoaXN0b3J5LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgbW9kZWwgbWF5IHNvbWV0aW1lcyBnZW5lcmF0ZSBpbnZhbGlkIG9yIGVtcHR5IGNvbnRlbnRzKGUuZy4sIGR1ZSB0byBzYWZ0eVxuICogZmlsdGVycyBvciByZWNpdGF0aW9uKS4gRXh0cmFjdGluZyB2YWxpZCB0dXJucyBmcm9tIHRoZSBoaXN0b3J5XG4gKiBlbnN1cmVzIHRoYXQgc3Vic2VxdWVudCByZXF1ZXN0cyBjb3VsZCBiZSBhY2NwZXRlZCBieSB0aGUgbW9kZWwuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDdXJhdGVkSGlzdG9yeShjb21wcmVoZW5zaXZlSGlzdG9yeSkge1xuICAgIGlmIChjb21wcmVoZW5zaXZlSGlzdG9yeSA9PT0gdW5kZWZpbmVkIHx8IGNvbXByZWhlbnNpdmVIaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGN1cmF0ZWRIaXN0b3J5ID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gY29tcHJlaGVuc2l2ZUhpc3RvcnkubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0ucm9sZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wdXNoKGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gW107XG4gICAgICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCAmJiBjb21wcmVoZW5zaXZlSGlzdG9yeVtpXS5yb2xlID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxPdXRwdXQucHVzaChjb21wcmVoZW5zaXZlSGlzdG9yeVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQgJiYgIWlzVmFsaWRDb250ZW50KGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY3VyYXRlZEhpc3RvcnkucHVzaCguLi5tb2RlbE91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgdXNlciBpbnB1dCB3aGVuIG1vZGVsIGNvbnRlbnQgaXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VyYXRlZEhpc3Rvcnk7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBjcmVhdGUgYSBjaGF0IHNlc3Npb24uXG4gKi9cbmNsYXNzIENoYXRzIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbHNNb2R1bGUsIGFwaUNsaWVudCkge1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgY29uZmlnIGluIHRoZSBwYXJhbXMgd2lsbCBiZSB1c2VkIGZvciBhbGwgcmVxdWVzdHMgd2l0aGluIHRoZSBjaGF0XG4gICAgICogc2Vzc2lvbiB1bmxlc3Mgb3ZlcnJpZGRlbiBieSBhIHBlci1yZXF1ZXN0IGBjb25maWdgIGluXG4gICAgICogQHNlZSB7QGxpbmsgdHlwZXMuU2VuZE1lc3NhZ2VQYXJhbWV0ZXJzI2NvbmZpZ30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgQSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNoYXQgPSBhaS5jaGF0cy5jcmVhdGUoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIHRlbXBlcmF0dXJlOiAwLjUsXG4gICAgICogICAgIG1heE91dHB1dFRva2VuczogMTAyNCxcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdCh0aGlzLmFwaUNsaWVudCwgdGhpcy5tb2RlbHNNb2R1bGUsIHBhcmFtcy5tb2RlbCwgcGFyYW1zLmNvbmZpZywgXG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHN0cnVjdHVyZWRDbG9uZShwYXJhbXMuaGlzdG9yeSkpO1xuICAgIH1cbn1cbi8qKlxuICogQ2hhdCBzZXNzaW9uIHRoYXQgZW5hYmxlcyBzZW5kaW5nIG1lc3NhZ2VzIHRvIHRoZSBtb2RlbCB3aXRoIHByZXZpb3VzXG4gKiBjb252ZXJzYXRpb24gY29udGV4dC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHNlc3Npb24gbWFpbnRhaW5zIGFsbCB0aGUgdHVybnMgYmV0d2VlbiB1c2VyIGFuZCBtb2RlbC5cbiAqL1xuY2xhc3MgQ2hhdCB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBtb2RlbHNNb2R1bGUsIG1vZGVsLCBjb25maWcgPSB7fSwgaGlzdG9yeSA9IFtdKSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcbiAgICAgICAgLy8gQSBwcm9taXNlIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgbWVzc2FnZSBiZWluZyBzZW50IHRvIHRoZVxuICAgICAgICAvLyBtb2RlbC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBtZXNzYWdlIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmVcbiAgICAgKiBzZW5kaW5nIHRoZSBuZXh0IG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBDaGF0I3NlbmRNZXNzYWdlU3RyZWFtfSBmb3Igc3RyZWFtaW5nIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gcGFyYW1ldGVycyBmb3Igc2VuZGluZyBtZXNzYWdlcyB3aXRoaW4gYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UudGV4dCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUHJvbWlzZTtcbiAgICAgICAgY29uc3QgaW5wdXRDb250ZW50ID0gdENvbnRlbnQocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSAoX2IgPSAoX2EgPSByZXNwb25zZS5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50O1xuICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgQUZDIGlucHV0IGNvbnRhaW5zIHRoZSBlbnRpcmUgY3VyYXRlZCBjaGF0IGhpc3RvcnkgaW5cbiAgICAgICAgICAgIC8vIGFkZGl0aW9uIHRvIHRoZSBuZXcgdXNlciBpbnB1dCwgd2UgbmVlZCB0byB0cnVuY2F0ZSB0aGUgQUZDIGhpc3RvcnlcbiAgICAgICAgICAgIC8vIHRvIGRlZHVwbGljYXRlIHRoZSBleGlzdGluZyBjaGF0IGhpc3RvcnkuXG4gICAgICAgICAgICBjb25zdCBmdWxsQXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IHJlc3BvbnNlLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SGlzdG9yeSh0cnVlKS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgaWYgKGZ1bGxBdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgKF9jID0gZnVsbEF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnkuc2xpY2UoaW5kZXgpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gb3V0cHV0Q29udGVudCA/IFtvdXRwdXRDb250ZW50XSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRIaXN0b3J5KGlucHV0Q29udGVudCwgbW9kZWxPdXRwdXQsIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KSgpO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRQcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJlc2V0cyBzZW5kUHJvbWlzZSB0byBhdm9pZCBzdWJzZXF1ZW50IGNhbGxzIGZhaWxpbmdcbiAgICAgICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlIGluIGNodW5rcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgbWVzc2FnZSB0byBiZSBwcm9jZXNzZWQgYmVmb3JlXG4gICAgICogc2VuZGluZyB0aGUgbmV4dCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQ2hhdCNzZW5kTWVzc2FnZX0gZm9yIG5vbi1zdHJlYW1pbmcgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBwYXJhbWV0ZXJzIGZvciBzZW5kaW5nIHRoZSBtZXNzYWdlLlxuICAgICAqIEByZXR1cm4gVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZVN0cmVhbSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXNwb25zZSkge1xuICAgICAqICAgY29uc29sZS5sb2coY2h1bmsudGV4dCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlU3RyZWFtKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFByb21pc2U7XG4gICAgICAgIGNvbnN0IGlucHV0Q29udGVudCA9IHRDb250ZW50KHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtUmVzcG9uc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0oe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIGludGVybmFsIHRyYWNraW5nIG9mIHNlbmQgY29tcGxldGlvbiBwcm9taXNlIC0gYHNlbmRQcm9taXNlYFxuICAgICAgICAvLyBmb3IgYm90aCBzdWNjZXNzIGFuZCBmYWlsdXJlIHJlc3BvbnNlLiBUaGUgYWN0dWFsIGZhaWx1cmUgaXMgc3RpbGxcbiAgICAgICAgLy8gcHJvcGFnYXRlZCBieSB0aGUgYGF3YWl0IHN0cmVhbVJlc3BvbnNlYC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IHN0cmVhbVJlc3BvbnNlXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdHJlYW1SZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UsIGlucHV0Q29udGVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoYXQgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGhpc3RvcnkgaXMgYSBsaXN0IG9mIGNvbnRlbnRzIGFsdGVybmF0aW5nIGJldHdlZW4gdXNlciBhbmQgbW9kZWwuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIGhpc3Rvcnk6XG4gICAgICogLSBUaGUgYGN1cmF0ZWQgaGlzdG9yeWAgY29udGFpbnMgb25seSB0aGUgdmFsaWQgdHVybnMgYmV0d2VlbiB1c2VyIGFuZFxuICAgICAqIG1vZGVsLCB3aGljaCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJzZXF1ZW50IHJlcXVlc3RzIHNlbnQgdG8gdGhlIG1vZGVsLlxuICAgICAqIC0gVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGNvbnRhaW5zIGFsbCB0dXJucywgaW5jbHVkaW5nIGludmFsaWQgb3JcbiAgICAgKiAgIGVtcHR5IG1vZGVsIG91dHB1dHMsIHByb3ZpZGluZyBhIGNvbXBsZXRlIHJlY29yZCBvZiB0aGUgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIFRoZSBoaXN0b3J5IGlzIHVwZGF0ZWQgYWZ0ZXIgcmVjZWl2aW5nIHRoZSByZXNwb25zZSBmcm9tIHRoZSBtb2RlbCxcbiAgICAgKiBmb3Igc3RyZWFtaW5nIHJlc3BvbnNlLCBpdCBtZWFucyByZWNlaXZpbmcgdGhlIGxhc3QgY2h1bmsgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGlzIHJldHVybmVkIGJ5IGRlZmF1bHQuIFRvIGdldCB0aGUgYGN1cmF0ZWRcbiAgICAgKiBoaXN0b3J5YCwgc2V0IHRoZSBgY3VyYXRlZGAgcGFyYW1ldGVyIHRvIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdXJhdGVkIC0gd2hldGhlciB0byByZXR1cm4gdGhlIGN1cmF0ZWQgaGlzdG9yeSBvciB0aGUgY29tcHJlaGVuc2l2ZVxuICAgICAqICAgICBoaXN0b3J5LlxuICAgICAqIEByZXR1cm4gSGlzdG9yeSBjb250ZW50cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsIGZvciB0aGUgZW50aXJlXG4gICAgICogICAgIGNoYXQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBnZXRIaXN0b3J5KGN1cmF0ZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoaXN0b3J5ID0gY3VyYXRlZFxuICAgICAgICAgICAgPyBleHRyYWN0Q3VyYXRlZEhpc3RvcnkodGhpcy5oaXN0b3J5KVxuICAgICAgICAgICAgOiB0aGlzLmhpc3Rvcnk7XG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUoaGlzdG9yeSk7XG4gICAgfVxuICAgIHByb2Nlc3NTdHJlYW1SZXNwb25zZShzdHJlYW1SZXNwb25zZSwgaW5wdXRDb250ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHByb2Nlc3NTdHJlYW1SZXNwb25zZV8xKCkge1xuICAgICAgICAgICAgdmFyIF9jLCBlXzEsIF9kLCBfZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBzdHJlYW1SZXNwb25zZV8xID0gX19hc3luY1ZhbHVlcyhzdHJlYW1SZXNwb25zZSksIHN0cmVhbVJlc3BvbnNlXzFfMTsgc3RyZWFtUmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChzdHJlYW1SZXNwb25zZV8xLm5leHQoKSksIF9jID0gc3RyZWFtUmVzcG9uc2VfMV8xLmRvbmUsICFfYzsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lID0gc3RyZWFtUmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFJlc3BvbnNlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChfYiA9IChfYSA9IGNodW5rLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q29udGVudC5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYyAmJiAoX2QgPSBzdHJlYW1SZXNwb25zZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2QuY2FsbChzdHJlYW1SZXNwb25zZV8xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVjb3JkSGlzdG9yeShpbnB1dENvbnRlbnQsIG91dHB1dENvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVjb3JkSGlzdG9yeSh1c2VySW5wdXQsIG1vZGVsT3V0cHV0LCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5KSB7XG4gICAgICAgIGxldCBvdXRwdXRDb250ZW50cyA9IFtdO1xuICAgICAgICBpZiAobW9kZWxPdXRwdXQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgbW9kZWxPdXRwdXQuZXZlcnkoKGNvbnRlbnQpID0+IGNvbnRlbnQucm9sZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMgPSBtb2RlbE91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGVuZHMgYW4gZW1wdHkgY29udGVudCB3aGVuIG1vZGVsIHJldHVybnMgZW1wdHkgcmVzcG9uc2UsIHNvIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBoaXN0b3J5IGlzIGFsd2F5cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsLlxuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm9sZTogJ21vZGVsJyxcbiAgICAgICAgICAgICAgICBwYXJ0czogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSAmJlxuICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5leHRyYWN0Q3VyYXRlZEhpc3RvcnkoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2godXNlcklucHV0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5vdXRwdXRDb250ZW50cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIEFQSSBlcnJvcnMgcmFpc2VkIGJ5IHRoZSBHZW5BSSBBUEkuXG4gKi9cbmNsYXNzIEFwaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEFwaUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlJ10pO1xuICAgIGlmIChmcm9tRmlsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGUnXSwgZmlsZVRvTWxkZXYoZnJvbUZpbGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdmaWxlJ10sIHRGaWxlTmFtZShmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TaXplQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NpemVCeXRlcyddKTtcbiAgICBpZiAoZnJvbVNpemVCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NpemVCeXRlcyddLCBmcm9tU2l6ZUJ5dGVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmF0aW9uVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4cGlyYXRpb25UaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4cGlyYXRpb25UaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhwaXJhdGlvblRpbWUnXSwgZnJvbUV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TaGEyNTZIYXNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzaGEyNTZIYXNoJ10pO1xuICAgIGlmIChmcm9tU2hhMjU2SGFzaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NoYTI1Nkhhc2gnXSwgZnJvbVNoYTI1Nkhhc2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb3dubG9hZFVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG93bmxvYWRVcmknXSk7XG4gICAgaWYgKGZyb21Eb3dubG9hZFVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rvd25sb2FkVXJpJ10sIGZyb21Eb3dubG9hZFVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIGZyb21TdGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Tb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NvdXJjZSddKTtcbiAgICBpZiAoZnJvbVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NvdXJjZSddLCBmcm9tU291cmNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZmlsZVN0YXR1c0Zyb21NbGRldihmcm9tRXJyb3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZVN0YXR1c0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGV0YWlscyddKTtcbiAgICBpZiAoZnJvbURldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXRhaWxzJ10sIGZyb21EZXRhaWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lc3NhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lc3NhZ2UnXSk7XG4gICAgaWYgKGZyb21NZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVzc2FnZSddLCBmcm9tTWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb2RlJ10pO1xuICAgIGlmIChmcm9tQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGUnXSwgZnJvbUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlU3RhdHVzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGV0YWlscyddKTtcbiAgICBpZiAoZnJvbURldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXRhaWxzJ10sIGZyb21EZXRhaWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lc3NhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lc3NhZ2UnXSk7XG4gICAgaWYgKGZyb21NZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVzc2FnZSddLCBmcm9tTWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb2RlJ10pO1xuICAgIGlmIChmcm9tQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGUnXSwgZnJvbUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNpemVCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2l6ZUJ5dGVzJ10pO1xuICAgIGlmIChmcm9tU2l6ZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2l6ZUJ5dGVzJ10sIGZyb21TaXplQnl0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyYXRpb25UaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhwaXJhdGlvblRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhwaXJhdGlvblRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleHBpcmF0aW9uVGltZSddLCBmcm9tRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNoYTI1Nkhhc2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NoYTI1Nkhhc2gnXSk7XG4gICAgaWYgKGZyb21TaGEyNTZIYXNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2hhMjU2SGFzaCddLCBmcm9tU2hhMjU2SGFzaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvd25sb2FkVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb3dubG9hZFVyaSddKTtcbiAgICBpZiAoZnJvbURvd25sb2FkVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG93bmxvYWRVcmknXSwgZnJvbURvd25sb2FkVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgZnJvbVN0YXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc291cmNlJ10sIGZyb21Tb3VyY2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmaWxlU3RhdHVzVG9NbGRldihmcm9tRXJyb3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0RmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnZmlsZSddLCB0RmlsZU5hbWUoZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlc1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RGaWxlc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZXNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlcyddKTtcbiAgICBpZiAoZnJvbUZpbGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GaWxlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBGaWxlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGFsbCBjdXJyZW50IHByb2plY3QgZmlsZXMgZnJvbSB0aGUgc2VydmljZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0XG4gICAgICAgICAqIEByZXR1cm4gVGhlIHBhZ2luYXRlZCByZXN1bHRzIG9mIHRoZSBsaXN0IG9mIGZpbGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSBwcmludHMgdGhlIG5hbWVzIG9mIGFsbCBmaWxlcyBmcm9tIHRoZSBzZXJ2aWNlLCB0aGVcbiAgICAgICAgICogc2l6ZSBvZiBlYWNoIHBhZ2UgaXMgMTAuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGxpc3RSZXNwb25zZSA9IGF3YWl0IGFpLmZpbGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDEwfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGZpbGUgb2YgbGlzdFJlc3BvbnNlKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9GSUxFUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB0byB0aGUgR2VtaW5pIEFQSS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgYXZhaWxhYmxlIGluIFZlcnRleCBBSS5cbiAgICAgKiBTdXBwb3J0ZWQgdXBsb2FkIHNvdXJjZXM6XG4gICAgICogLSBOb2RlLmpzOiBGaWxlIHBhdGggKHN0cmluZykgb3IgQmxvYiBvYmplY3QuXG4gICAgICogLSBCcm93c2VyOiBCbG9iIG9iamVjdCAoZS5nLiwgRmlsZSkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBgbWltZVR5cGVgIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIGBjb25maWdgIHBhcmFtZXRlci4gSWYgb21pdHRlZDpcbiAgICAgKiAgLSBGb3IgZmlsZSBwYXRoIChzdHJpbmcpIGlucHV0cywgdGhlIGBtaW1lVHlwZWAgd2lsbCBiZSBpbmZlcnJlZCBmcm9tIHRoZVxuICAgICAqICAgICBmaWxlIGV4dGVuc2lvbi5cbiAgICAgKiAgLSBGb3IgQmxvYiBvYmplY3QgaW5wdXRzLCB0aGUgYG1pbWVUeXBlYCB3aWxsIGJlIHNldCB0byB0aGUgQmxvYidzIGB0eXBlYFxuICAgICAqICAgICBwcm9wZXJ0eS5cbiAgICAgKiBTb21leCBlYW1wbGVzIGZvciBmaWxlIGV4dGVuc2lvbiB0byBtaW1lVHlwZSBtYXBwaW5nOlxuICAgICAqIC50eHQgLT4gdGV4dC9wbGFpblxuICAgICAqIC5qc29uIC0+IGFwcGxpY2F0aW9uL2pzb25cbiAgICAgKiAuanBnICAtPiBpbWFnZS9qcGVnXG4gICAgICogLnBuZyAtPiBpbWFnZS9wbmdcbiAgICAgKiAubXAzIC0+IGF1ZGlvL21wZWdcbiAgICAgKiAubXA0IC0+IHZpZGVvL21wNFxuICAgICAqXG4gICAgICogVGhpcyBzZWN0aW9uIGNhbiBjb250YWluIG11bHRpcGxlIHBhcmFncmFwaHMgYW5kIGNvZGUgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlXG4gICAgICogICAgICAgIGB0eXBlcy5VcGxvYWRGaWxlUGFyYW1ldGVyc2AgaW50ZXJmYWNlLlxuICAgICAqICAgICAgICAgQHNlZSB7QGxpbmsgdHlwZXMuVXBsb2FkRmlsZVBhcmFtZXRlcnMjY29uZmlnfSBmb3IgdGhlIG9wdGlvbmFsXG4gICAgICogICAgICAgICBjb25maWcgaW4gdGhlIHBhcmFtZXRlcnMuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGB0eXBlcy5GaWxlYCBvYmplY3QuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBjYWxsZWQgb24gYSBWZXJ0ZXggQUkgY2xpZW50LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGBtaW1lVHlwZWAgaXMgbm90IHByb3ZpZGVkIGFuZCBjYW4gbm90IGJlIGluZmVycmVkLFxuICAgICAqIHRoZSBgbWltZVR5cGVgIGNhbiBiZSBwcm92aWRlZCBpbiB0aGUgYHBhcmFtcy5jb25maWdgIHBhcmFtZXRlci5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIG9jY3VycyBpZiBhIHN1aXRhYmxlIHVwbG9hZCBsb2NhdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSB1cGxvYWRzIGEgZmlsZSB0byBHZW1pbmkgQVBJLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBmaWxlID0gYXdhaXQgYWkuZmlsZXMudXBsb2FkKHtmaWxlOiAnZmlsZS50eHQnLCBjb25maWc6IHtcbiAgICAgKiAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG4gICAgICogfX0pO1xuICAgICAqIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBBSSBkb2VzIG5vdCBzdXBwb3J0IHVwbG9hZGluZyBmaWxlcy4gWW91IGNhbiBzaGFyZSBmaWxlcyB0aHJvdWdoIGEgR0NTIGJ1Y2tldC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgIC51cGxvYWRGaWxlKHBhcmFtcy5maWxlLCBwYXJhbXMuY29uZmlnKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gZmlsZUZyb21NbGRldihyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBhIHJlbW90ZWx5IHN0b3JlZCBmaWxlIGFzeW5jaHJvbm91c2x5IHRvIGEgbG9jYXRpb24gc3BlY2lmaWVkIGluXG4gICAgICogdGhlIGBwYXJhbXNgIG9iamVjdC4gVGhpcyBtZXRob2Qgb25seSB3b3JrcyBvbiBOb2RlIGVudmlyb25tZW50LCB0b1xuICAgICAqIGRvd25sb2FkIGZpbGVzIGluIHRoZSBicm93c2VyLCB1c2UgYSBicm93c2VyIGNvbXBsaWFudCBtZXRob2QgbGlrZSBhbiA8YT5cbiAgICAgKiB0YWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkb3dubG9hZCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNvZGUgZG93bmxvYWRzIGFuIGV4YW1wbGUgZmlsZSBuYW1lZCBcImZpbGVzL21laG96cHhmODc3ZFwiIGFzXG4gICAgICogXCJmaWxlLnR4dFwiLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5maWxlcy5kb3dubG9hZCh7ZmlsZTogZmlsZS5uYW1lLCBkb3dubG9hZFBhdGg6ICdmaWxlLnR4dCd9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkb3dubG9hZChwYXJhbXMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQuZG93bmxvYWRGaWxlKHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdEZpbGVzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0RmlsZXNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RGaWxlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjcmVhdGVJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd1cGxvYWQvdjFiZXRhL2ZpbGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjcmVhdGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDcmVhdGVGaWxlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZmlsZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIFRoZSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHR5cGVzLkZpbGUgb2JqZWN0IHJlcXVlc3RlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb25maWc6IEdldEZpbGVQYXJhbWV0ZXJzID0ge1xuICAgICAqICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICogfTtcbiAgICAgKiBmaWxlID0gYXdhaXQgYWkuZmlsZXMuZ2V0KGNvbmZpZyk7XG4gICAgICogY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldEZpbGVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMve2ZpbGV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGZpbGVGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHJlbW90ZWx5IHN0b3JlZCBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZGVsZXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgRGVsZXRlRmlsZVJlc3BvbnNlLCB0aGUgcmVzcG9uc2UgZm9yIHRoZSBkZWxldGUgbWV0aG9kLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNvZGUgZGVsZXRlcyBhbiBleGFtcGxlIGZpbGUgbmFtZWQgXCJmaWxlcy9tZWhvenB4Zjg3N2RcIi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuZmlsZXMuZGVsZXRlKHtuYW1lOiBmaWxlLm5hbWV9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMve2ZpbGV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVGaWxlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBhY3Rpdml0eUVuZFRvTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhY3Rpdml0eUVuZFRvVmVydGV4KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYWN0aXZpdHlTdGFydFRvTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhY3Rpdml0eVN0YXJ0VG9WZXJ0ZXgoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhcGlLZXlDb25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BcGlLZXlTdHJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FwaUtleVN0cmluZyddKTtcbiAgICBpZiAoZnJvbUFwaUtleVN0cmluZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FwaUtleVN0cmluZyddLCBmcm9tQXBpS2V5U3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXVkaW9DaHVua0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc291cmNlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU291cmNlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzb3VyY2VNZXRhZGF0YSddLCBsaXZlTXVzaWNTb3VyY2VNZXRhZGF0YUZyb21NbGRldihmcm9tU291cmNlTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9NbGRldiQxKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9WZXJ0ZXgoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdXRoQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXBpS2V5Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcGlLZXlDb25maWcnXSk7XG4gICAgaWYgKGZyb21BcGlLZXlDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcGlLZXlDb25maWcnXSwgYXBpS2V5Q29uZmlnVG9WZXJ0ZXgkMShmcm9tQXBpS2V5Q29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdXRoVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aFR5cGUnXSk7XG4gICAgaWYgKGZyb21BdXRoVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dGhUeXBlJ10sIGZyb21BdXRoVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VydmljZUFjY291bnRDb25maWcnXSwgZnJvbUdvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUh0dHBCYXNpY0F1dGhDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdodHRwQmFzaWNBdXRoQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUh0dHBCYXNpY0F1dGhDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydodHRwQmFzaWNBdXRoQ29uZmlnJ10sIGZyb21IdHRwQmFzaWNBdXRoQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU9hdXRoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvYXV0aENvbmZpZyddKTtcbiAgICBpZiAoZnJvbU9hdXRoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb2F1dGhDb25maWcnXSwgZnJvbU9hdXRoQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU9pZGNDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ29pZGNDb25maWcnXSk7XG4gICAgaWYgKGZyb21PaWRjQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb2lkY0NvbmZpZyddLCBmcm9tT2lkY0NvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNhYmxlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzYWJsZWQnXSk7XG4gICAgaWYgKGZyb21EaXNhYmxlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc2FibGVkJ10sIGZyb21EaXNhYmxlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5J10sIGZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuZE9mU3BlZWNoU2Vuc2l0aXZpdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mU3BlZWNoU2Vuc2l0aXZpdHknXSwgZnJvbUVuZE9mU3BlZWNoU2Vuc2l0aXZpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlZml4UGFkZGluZ01zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZml4UGFkZGluZ01zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZWZpeFBhZGRpbmdNcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWZpeFBhZGRpbmdNcyddLCBmcm9tUHJlZml4UGFkZGluZ01zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNpbGVuY2VEdXJhdGlvbk1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2lsZW5jZUR1cmF0aW9uTXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2lsZW5jZUR1cmF0aW9uTXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzaWxlbmNlRHVyYXRpb25NcyddLCBmcm9tU2lsZW5jZUR1cmF0aW9uTXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvblRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNhYmxlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzYWJsZWQnXSk7XG4gICAgaWYgKGZyb21EaXNhYmxlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc2FibGVkJ10sIGZyb21EaXNhYmxlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5J10sIGZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuZE9mU3BlZWNoU2Vuc2l0aXZpdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mU3BlZWNoU2Vuc2l0aXZpdHknXSwgZnJvbUVuZE9mU3BlZWNoU2Vuc2l0aXZpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlZml4UGFkZGluZ01zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZml4UGFkZGluZ01zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZWZpeFBhZGRpbmdNcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWZpeFBhZGRpbmdNcyddLCBmcm9tUHJlZml4UGFkZGluZ01zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNpbGVuY2VEdXJhdGlvbk1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2lsZW5jZUR1cmF0aW9uTXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2lsZW5jZUR1cmF0aW9uTXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzaWxlbmNlRHVyYXRpb25NcyddLCBmcm9tU2lsZW5jZUR1cmF0aW9uTXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JGcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZXJVc2VUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUVudmlyb25tZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnZpcm9ubWVudCddKTtcbiAgICBpZiAoZnJvbUVudmlyb25tZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW52aXJvbm1lbnQnXSwgZnJvbUVudmlyb25tZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMnXSwgZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVyVXNlVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRW52aXJvbm1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vudmlyb25tZW50J10pO1xuICAgIGlmIChmcm9tRW52aXJvbm1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnZpcm9ubWVudCddLCBmcm9tRW52aXJvbm1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyddLCBmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydEZyb21NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRGcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0RnJvbVZlcnRleCQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldiQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvVmVydGV4JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UcmlnZ2VyVG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHJpZ2dlclRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UcmlnZ2VyVG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHJpZ2dlclRva2VucyddLCBmcm9tVHJpZ2dlclRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TbGlkaW5nV2luZG93ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2xpZGluZ1dpbmRvdycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TbGlkaW5nV2luZG93ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2xpZGluZ1dpbmRvdyddLCBzbGlkaW5nV2luZG93VG9NbGRldiQxKGZyb21TbGlkaW5nV2luZG93KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRleHRXaW5kb3dDb21wcmVzc2lvbkNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UcmlnZ2VyVG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHJpZ2dlclRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UcmlnZ2VyVG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHJpZ2dlclRva2VucyddLCBmcm9tVHJpZ2dlclRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TbGlkaW5nV2luZG93ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2xpZGluZ1dpbmRvdycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TbGlkaW5nV2luZG93ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2xpZGluZ1dpbmRvdyddLCBzbGlkaW5nV2luZG93VG9WZXJ0ZXgoZnJvbVNsaWRpbmdXaW5kb3cpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR5bmFtaWNUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljVGhyZXNob2xkJ10sIGZyb21EeW5hbWljVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVudGVycHJpc2VXZWJTZWFyY2hUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FeGNsdWRlRG9tYWlucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4Y2x1ZGVEb21haW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4Y2x1ZGVEb21haW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSwgZnJvbUV4Y2x1ZGVEb21haW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFGcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbEZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CZWhhdmlvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSk7XG4gICAgaWYgKGZyb21CZWhhdmlvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JlaGF2aW9yJ10sIGZyb21CZWhhdmlvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlaGF2aW9yIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKTtcbiAgICBpZiAoZnJvbUF1dGhDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdXRoQ29uZmlnJ10sIGF1dGhDb25maWdUb1ZlcnRleCQxKGZyb21BdXRoQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMihmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1JldHJpZXZhbENvbmZpZyddLCBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgkMShmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgaW50ZXJ2YWxUb01sZGV2JDIoZnJvbVRpbWVSYW5nZUZpbHRlcikpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGNsdWRlRG9tYWlucyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZURvbWFpbnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBpbnRlcnZhbFRvVmVydGV4JDEoZnJvbVRpbWVSYW5nZUZpbHRlcikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhjbHVkZURvbWFpbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGNsdWRlRG9tYWlucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGNsdWRlRG9tYWlucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10sIGZyb21FeGNsdWRlRG9tYWlucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGludGVydmFsVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGludGVydmFsVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnXSwgZnJvbUdlbmVyYXRpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzcGVlY2hDb25maWcnXSwgc3BlZWNoQ29uZmlnVG9NbGRldiQyKHRMaXZlU3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGhpbmtpbmdDb25maWcnXSwgdGhpbmtpbmdDb25maWdUb01sZGV2JDIoZnJvbVRoaW5raW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQyKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDIodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldiQxKGZyb21TZXNzaW9uUmVzdW1wdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb01sZGV2JDEoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb01sZGV2JDEoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWFsdGltZUlucHV0Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVhbHRpbWVJbnB1dENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWFsdGltZUlucHV0Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3JlYWx0aW1lSW5wdXRDb25maWcnXSwgcmVhbHRpbWVJbnB1dENvbmZpZ1RvTWxkZXYkMShmcm9tUmVhbHRpbWVJbnB1dENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nXSwgY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9NbGRldiQxKGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb2FjdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9hY3Rpdml0eSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb2FjdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Byb2FjdGl2aXR5J10sIHByb2FjdGl2aXR5Q29uZmlnVG9NbGRldiQxKGZyb21Qcm9hY3Rpdml0eSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBmcm9tR2VuZXJhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb1ZlcnRleCQxKHRMaXZlU3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGhpbmtpbmdDb25maWcnXSwgdGhpbmtpbmdDb25maWdUb1ZlcnRleCQxKGZyb21UaGlua2luZ0NvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZyddLCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvVmVydGV4JDEodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4JDEodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9WZXJ0ZXgoZnJvbVNlc3Npb25SZXN1bXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvVmVydGV4KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9WZXJ0ZXgoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWFsdGltZUlucHV0Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVhbHRpbWVJbnB1dENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWFsdGltZUlucHV0Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3JlYWx0aW1lSW5wdXRDb25maWcnXSwgcmVhbHRpbWVJbnB1dENvbmZpZ1RvVmVydGV4KGZyb21SZWFsdGltZUlucHV0Q29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbiddLCBjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb1ZlcnRleChmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9hY3Rpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvYWN0aXZpdHknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9hY3Rpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdwcm9hY3Rpdml0eSddLCBwcm9hY3Rpdml0eUNvbmZpZ1RvVmVydGV4KGZyb21Qcm9hY3Rpdml0eSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYkMShmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGl2ZUNvbm5lY3RDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNDbGllbnRDb250ZW50RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21XZWlnaHRlZFByb21wdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd3ZWlnaHRlZFByb21wdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tV2VpZ2h0ZWRQcm9tcHRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21XZWlnaHRlZFByb21wdHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2VpZ2h0ZWRQcm9tcHRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd3ZWlnaHRlZFByb21wdHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljQ2xpZW50Q29udGVudFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVdlaWdodGVkUHJvbXB0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3dlaWdodGVkUHJvbXB0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21XZWlnaHRlZFByb21wdHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVdlaWdodGVkUHJvbXB0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB3ZWlnaHRlZFByb21wdFRvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd3ZWlnaHRlZFByb21wdHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljQ2xpZW50TWVzc2FnZVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNldHVwID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZXR1cCddKTtcbiAgICBpZiAoZnJvbVNldHVwICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnXSwgbGl2ZU11c2ljQ2xpZW50U2V0dXBUb01sZGV2KGZyb21TZXR1cCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2xpZW50Q29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NsaWVudENvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2xpZW50Q29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NsaWVudENvbnRlbnQnXSwgbGl2ZU11c2ljQ2xpZW50Q29udGVudFRvTWxkZXYoZnJvbUNsaWVudENvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211c2ljR2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXNpY0dlbmVyYXRpb25Db25maWcnXSwgbGl2ZU11c2ljR2VuZXJhdGlvbkNvbmZpZ1RvTWxkZXYoZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGxheWJhY2tDb250cm9sID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGxheWJhY2tDb250cm9sJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBsYXliYWNrQ29udHJvbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BsYXliYWNrQ29udHJvbCddLCBmcm9tUGxheWJhY2tDb250cm9sKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljQ2xpZW50U2V0dXBUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY0ZpbHRlcmVkUHJvbXB0RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyZWRSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmaWx0ZXJlZFJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GaWx0ZXJlZFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbHRlcmVkUmVhc29uJ10sIGZyb21GaWx0ZXJlZFJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY0dlbmVyYXRpb25Db25maWdGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3VpZGFuY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2d1aWRhbmNlJ10pO1xuICAgIGlmIChmcm9tR3VpZGFuY2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydndWlkYW5jZSddLCBmcm9tR3VpZGFuY2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQnBtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydicG0nXSk7XG4gICAgaWYgKGZyb21CcG0gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydicG0nXSwgZnJvbUJwbSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZW5zaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZW5zaXR5J10pO1xuICAgIGlmIChmcm9tRGVuc2l0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RlbnNpdHknXSwgZnJvbURlbnNpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQnJpZ2h0bmVzcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYnJpZ2h0bmVzcyddKTtcbiAgICBpZiAoZnJvbUJyaWdodG5lc3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydicmlnaHRuZXNzJ10sIGZyb21CcmlnaHRuZXNzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzY2FsZSddKTtcbiAgICBpZiAoZnJvbVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2NhbGUnXSwgZnJvbVNjYWxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU11dGVCYXNzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtdXRlQmFzcyddKTtcbiAgICBpZiAoZnJvbU11dGVCYXNzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXV0ZUJhc3MnXSwgZnJvbU11dGVCYXNzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU11dGVEcnVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbXV0ZURydW1zJ10pO1xuICAgIGlmIChmcm9tTXV0ZURydW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXV0ZURydW1zJ10sIGZyb21NdXRlRHJ1bXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT25seUJhc3NBbmREcnVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ29ubHlCYXNzQW5kRHJ1bXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT25seUJhc3NBbmREcnVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ29ubHlCYXNzQW5kRHJ1bXMnXSwgZnJvbU9ubHlCYXNzQW5kRHJ1bXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXVzaWNHZW5lcmF0aW9uTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211c2ljR2VuZXJhdGlvbk1vZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTXVzaWNHZW5lcmF0aW9uTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211c2ljR2VuZXJhdGlvbk1vZGUnXSwgZnJvbU11c2ljR2VuZXJhdGlvbk1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNHZW5lcmF0aW9uQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ3VpZGFuY2UnXSk7XG4gICAgaWYgKGZyb21HdWlkYW5jZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2d1aWRhbmNlJ10sIGZyb21HdWlkYW5jZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CcG0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JwbSddKTtcbiAgICBpZiAoZnJvbUJwbSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JwbSddLCBmcm9tQnBtKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlbnNpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RlbnNpdHknXSk7XG4gICAgaWYgKGZyb21EZW5zaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVuc2l0eSddLCBmcm9tRGVuc2l0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CcmlnaHRuZXNzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydicmlnaHRuZXNzJ10pO1xuICAgIGlmIChmcm9tQnJpZ2h0bmVzcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JyaWdodG5lc3MnXSwgZnJvbUJyaWdodG5lc3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NjYWxlJ10pO1xuICAgIGlmIChmcm9tU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY2FsZSddLCBmcm9tU2NhbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXV0ZUJhc3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ211dGVCYXNzJ10pO1xuICAgIGlmIChmcm9tTXV0ZUJhc3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXRlQmFzcyddLCBmcm9tTXV0ZUJhc3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXV0ZURydW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtdXRlRHJ1bXMnXSk7XG4gICAgaWYgKGZyb21NdXRlRHJ1bXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXRlRHJ1bXMnXSwgZnJvbU11dGVEcnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Pbmx5QmFzc0FuZERydW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb25seUJhc3NBbmREcnVtcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Pbmx5QmFzc0FuZERydW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb25seUJhc3NBbmREcnVtcyddLCBmcm9tT25seUJhc3NBbmREcnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdXNpY0dlbmVyYXRpb25Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbXVzaWNHZW5lcmF0aW9uTW9kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdXNpY0dlbmVyYXRpb25Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVzaWNHZW5lcmF0aW9uTW9kZSddLCBmcm9tTXVzaWNHZW5lcmF0aW9uTW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NlcnZlckNvbnRlbnRGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUF1ZGlvQ2h1bmtzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpb0NodW5rcyddKTtcbiAgICBpZiAoZnJvbUF1ZGlvQ2h1bmtzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21BdWRpb0NodW5rcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdWRpb0NodW5rRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW9DaHVua3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljU2VydmVyTWVzc2FnZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2V0dXBDb21wbGV0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NldHVwQ29tcGxldGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2V0dXBDb21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwQ29tcGxldGUnXSwgbGl2ZU11c2ljU2VydmVyU2V0dXBDb21wbGV0ZUZyb21NbGRldigpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlcnZlckNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2ZXJDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlcnZlckNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXJ2ZXJDb250ZW50J10sIGxpdmVNdXNpY1NlcnZlckNvbnRlbnRGcm9tTWxkZXYoZnJvbVNlcnZlckNvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlcmVkUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZmlsdGVyZWRQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRmlsdGVyZWRQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWx0ZXJlZFByb21wdCddLCBsaXZlTXVzaWNGaWx0ZXJlZFByb21wdEZyb21NbGRldihmcm9tRmlsdGVyZWRQcm9tcHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljU2VydmVyU2V0dXBDb21wbGV0ZUZyb21NbGRldigpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdXNpY0dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVzaWNHZW5lcmF0aW9uQ29uZmlnJ10sIGxpdmVNdXNpY0dlbmVyYXRpb25Db25maWdUb01sZGV2KGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljU2V0V2VpZ2h0ZWRQcm9tcHRzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVdlaWdodGVkUHJvbXB0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3dlaWdodGVkUHJvbXB0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21XZWlnaHRlZFByb21wdHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVdlaWdodGVkUHJvbXB0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB3ZWlnaHRlZFByb21wdFRvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd3ZWlnaHRlZFByb21wdHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljU291cmNlTWV0YWRhdGFGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNsaWVudENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjbGllbnRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNsaWVudENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjbGllbnRDb250ZW50J10sIGxpdmVNdXNpY0NsaWVudENvbnRlbnRGcm9tTWxkZXYoZnJvbUNsaWVudENvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211c2ljR2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXNpY0dlbmVyYXRpb25Db25maWcnXSwgbGl2ZU11c2ljR2VuZXJhdGlvbkNvbmZpZ0Zyb21NbGRldihmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVkaWEnXSk7XG4gICAgaWYgKGZyb21NZWRpYSAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0QmxvYnMoZnJvbU1lZGlhKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFDaHVua3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpbyddKTtcbiAgICBpZiAoZnJvbUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW8nXSwgdEF1ZGlvQmxvYihmcm9tQXVkaW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvU3RyZWFtRW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9TdHJlYW1FbmQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9TdHJlYW1FbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1N0cmVhbUVuZCddLCBmcm9tQXVkaW9TdHJlYW1FbmQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB0SW1hZ2VCbG9iKGZyb21WaWRlbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5U3RhcnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhY3Rpdml0eVN0YXJ0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5U3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eVN0YXJ0J10sIGFjdGl2aXR5U3RhcnRUb01sZGV2KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlFbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlFbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eUVuZCddLCBhY3Rpdml0eUVuZFRvTWxkZXYoKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lZGlhJ10pO1xuICAgIGlmIChmcm9tTWVkaWEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEJsb2JzKGZyb21NZWRpYSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhQ2h1bmtzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW8nXSk7XG4gICAgaWYgKGZyb21BdWRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvJ10sIHRBdWRpb0Jsb2IoZnJvbUF1ZGlvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpb1N0cmVhbUVuZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1ZGlvU3RyZWFtRW5kJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1ZGlvU3RyZWFtRW5kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW9TdHJlYW1FbmQnXSwgZnJvbUF1ZGlvU3RyZWFtRW5kKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdEltYWdlQmxvYihmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eVN0YXJ0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWN0aXZpdHlTdGFydCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eVN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlTdGFydCddLCBhY3Rpdml0eVN0YXJ0VG9WZXJ0ZXgoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eUVuZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10sIGFjdGl2aXR5RW5kVG9WZXJ0ZXgoKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJDb250ZW50RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbFR1cm4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVHVybiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVHVybiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVHVybiddLCBjb250ZW50RnJvbU1sZGV2JDEoZnJvbU1vZGVsVHVybikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVybkNvbXBsZXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dXJuQ29tcGxldGUnXSk7XG4gICAgaWYgKGZyb21UdXJuQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dXJuQ29tcGxldGUnXSwgZnJvbVR1cm5Db21wbGV0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnRlcnJ1cHRlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW50ZXJydXB0ZWQnXSk7XG4gICAgaWYgKGZyb21JbnRlcnJ1cHRlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ludGVycnVwdGVkJ10sIGZyb21JbnRlcnJ1cHRlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hcm91bmRpbmdNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dyb3VuZGluZ01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdyb3VuZGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3JvdW5kaW5nTWV0YWRhdGEnXSwgZnJvbUdyb3VuZGluZ01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db21wbGV0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db21wbGV0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0aW9uQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0aW9uQ29tcGxldGUnXSwgZnJvbUdlbmVyYXRpb25Db21wbGV0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dFRyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dFRyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5wdXRUcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRUcmFuc2NyaXB0aW9uJ10sIHRyYW5zY3JpcHRpb25Gcm9tTWxkZXYoZnJvbUlucHV0VHJhbnNjcmlwdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0VHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dFRyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3V0cHV0VHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ291dHB1dFRyYW5zY3JpcHRpb24nXSwgdHJhbnNjcmlwdGlvbkZyb21NbGRldihmcm9tT3V0cHV0VHJhbnNjcmlwdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsQ29udGV4dE1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHRNZXRhZGF0YSddLCB1cmxDb250ZXh0TWV0YWRhdGFGcm9tTWxkZXYkMShmcm9tVXJsQ29udGV4dE1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ29tcGxldGVSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dXJuQ29tcGxldGVSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHVybkNvbXBsZXRlUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVybkNvbXBsZXRlUmVhc29uJ10sIGZyb21UdXJuQ29tcGxldGVSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tV2FpdGluZ0ZvcklucHV0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnd2FpdGluZ0ZvcklucHV0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVdhaXRpbmdGb3JJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3dhaXRpbmdGb3JJbnB1dCddLCBmcm9tV2FpdGluZ0ZvcklucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlckNvbnRlbnRGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbFR1cm4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVHVybiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVHVybiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVHVybiddLCBjb250ZW50RnJvbVZlcnRleCQxKGZyb21Nb2RlbFR1cm4pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1cm5Db21wbGV0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVybkNvbXBsZXRlJ10pO1xuICAgIGlmIChmcm9tVHVybkNvbXBsZXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVybkNvbXBsZXRlJ10sIGZyb21UdXJuQ29tcGxldGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW50ZXJydXB0ZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ludGVycnVwdGVkJ10pO1xuICAgIGlmIChmcm9tSW50ZXJydXB0ZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnRlcnJ1cHRlZCddLCBmcm9tSW50ZXJydXB0ZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdncm91bmRpbmdNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hcm91bmRpbmdNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dyb3VuZGluZ01ldGFkYXRhJ10sIGZyb21Hcm91bmRpbmdNZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29tcGxldGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGlvbkNvbXBsZXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGlvbkNvbXBsZXRlJ10sIGZyb21HZW5lcmF0aW9uQ29tcGxldGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRUcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRUcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlucHV0VHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lucHV0VHJhbnNjcmlwdGlvbiddLCB0cmFuc2NyaXB0aW9uRnJvbVZlcnRleChmcm9tSW5wdXRUcmFuc2NyaXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0VHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0VHJhbnNjcmlwdGlvbiddLCB0cmFuc2NyaXB0aW9uRnJvbVZlcnRleChmcm9tT3V0cHV0VHJhbnNjcmlwdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVybkNvbXBsZXRlUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVybkNvbXBsZXRlUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVR1cm5Db21wbGV0ZVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1cm5Db21wbGV0ZVJlYXNvbiddLCBmcm9tVHVybkNvbXBsZXRlUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVdhaXRpbmdGb3JJbnB1dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3dhaXRpbmdGb3JJbnB1dCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21XYWl0aW5nRm9ySW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd3YWl0aW5nRm9ySW5wdXQnXSwgZnJvbVdhaXRpbmdGb3JJbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJHb0F3YXlGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVMZWZ0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aW1lTGVmdCddKTtcbiAgICBpZiAoZnJvbVRpbWVMZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZUxlZnQnXSwgZnJvbVRpbWVMZWZ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlckdvQXdheUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVMZWZ0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aW1lTGVmdCddKTtcbiAgICBpZiAoZnJvbVRpbWVMZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZUxlZnQnXSwgZnJvbVRpbWVMZWZ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlck1lc3NhZ2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNldHVwQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXR1cENvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNldHVwQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cENvbXBsZXRlJ10sIGxpdmVTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbU1sZGV2KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VydmVyQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlcnZlckNvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VydmVyQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlcnZlckNvbnRlbnQnXSwgbGl2ZVNlcnZlckNvbnRlbnRGcm9tTWxkZXYoZnJvbVNlcnZlckNvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ2FsbCddKTtcbiAgICBpZiAoZnJvbVRvb2xDYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbENhbGwnXSwgbGl2ZVNlcnZlclRvb2xDYWxsRnJvbU1sZGV2KGZyb21Ub29sQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b29sQ2FsbENhbmNlbGxhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xDYWxsQ2FuY2VsbGF0aW9uJ10sIGxpdmVTZXJ2ZXJUb29sQ2FsbENhbmNlbGxhdGlvbkZyb21NbGRldihmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIHVzYWdlTWV0YWRhdGFGcm9tTWxkZXYoZnJvbVVzYWdlTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvQXdheSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29Bd2F5J10pO1xuICAgIGlmIChmcm9tR29Bd2F5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29Bd2F5J10sIGxpdmVTZXJ2ZXJHb0F3YXlGcm9tTWxkZXYoZnJvbUdvQXdheSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXNzaW9uUmVzdW1wdGlvblVwZGF0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nlc3Npb25SZXN1bXB0aW9uVXBkYXRlJ10sIGxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21NbGRldihmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlck1lc3NhZ2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZXR1cENvbXBsZXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2V0dXBDb21wbGV0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXR1cENvbXBsZXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXBDb21wbGV0ZSddLCBsaXZlU2VydmVyU2V0dXBDb21wbGV0ZUZyb21WZXJ0ZXgoZnJvbVNldHVwQ29tcGxldGUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlcnZlckNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2ZXJDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlcnZlckNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXJ2ZXJDb250ZW50J10sIGxpdmVTZXJ2ZXJDb250ZW50RnJvbVZlcnRleChmcm9tU2VydmVyQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDYWxsJ10pO1xuICAgIGlmIChmcm9tVG9vbENhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sQ2FsbCddLCBsaXZlU2VydmVyVG9vbENhbGxGcm9tVmVydGV4KGZyb21Ub29sQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b29sQ2FsbENhbmNlbGxhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xDYWxsQ2FuY2VsbGF0aW9uJ10sIGxpdmVTZXJ2ZXJUb29sQ2FsbENhbmNlbGxhdGlvbkZyb21WZXJ0ZXgoZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCB1c2FnZU1ldGFkYXRhRnJvbVZlcnRleChmcm9tVXNhZ2VNZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29Bd2F5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb0F3YXknXSk7XG4gICAgaWYgKGZyb21Hb0F3YXkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb0F3YXknXSwgbGl2ZVNlcnZlckdvQXdheUZyb21WZXJ0ZXgoZnJvbUdvQXdheSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXNzaW9uUmVzdW1wdGlvblVwZGF0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nlc3Npb25SZXN1bXB0aW9uVXBkYXRlJ10sIGxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21WZXJ0ZXgoZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmV3SGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduZXdIYW5kbGUnXSk7XG4gICAgaWYgKGZyb21OZXdIYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXdIYW5kbGUnXSwgZnJvbU5ld0hhbmRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXN1bWFibGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3VtYWJsZSddKTtcbiAgICBpZiAoZnJvbVJlc3VtYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3VtYWJsZSddLCBmcm9tUmVzdW1hYmxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21MYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXgnXSwgZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5ld0hhbmRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmV3SGFuZGxlJ10pO1xuICAgIGlmIChmcm9tTmV3SGFuZGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV3SGFuZGxlJ10sIGZyb21OZXdIYW5kbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzdW1hYmxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXN1bWFibGUnXSk7XG4gICAgaWYgKGZyb21SZXN1bWFibGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXN1bWFibGUnXSwgZnJvbVJlc3VtYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXgnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTGFzdENvbnN1bWVkQ2xpZW50TWVzc2FnZUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFzdENvbnN1bWVkQ2xpZW50TWVzc2FnZUluZGV4J10sIGZyb21MYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyU2V0dXBDb21wbGV0ZUZyb21NbGRldigpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2Vzc2lvbklkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZXNzaW9uSWQnXSk7XG4gICAgaWYgKGZyb21TZXNzaW9uSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXNzaW9uSWQnXSwgZnJvbVNlc3Npb25JZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJUb29sQ2FsbENhbmNlbGxhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZHMnXSk7XG4gICAgaWYgKGZyb21JZHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZHMnXSwgZnJvbUlkcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJUb29sQ2FsbENhbmNlbGxhdGlvbkZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWRzJ10pO1xuICAgIGlmIChmcm9tSWRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWRzJ10sIGZyb21JZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyVG9vbENhbGxGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uQ2FsbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxsRnJvbU1sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJUb29sQ2FsbEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uQ2FsbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxsRnJvbVZlcnRleCQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RhbGl0eSddKTtcbiAgICBpZiAoZnJvbU1vZGFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kYWxpdHknXSwgZnJvbU1vZGFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSk7XG4gICAgaWYgKGZyb21Ub2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5Db3VudCddLCBmcm9tVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGFsaXR5VG9rZW5Db3VudEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RhbGl0eSddKTtcbiAgICBpZiAoZnJvbU1vZGFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kYWxpdHknXSwgZnJvbU1vZGFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSk7XG4gICAgaWYgKGZyb21Ub2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5Db3VudCddLCBmcm9tVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TcGVha2VyVm9pY2VDb25maWdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3BlYWtlclZvaWNlQ29uZmlncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TcGVha2VyVm9pY2VDb25maWdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TcGVha2VyVm9pY2VDb25maWdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWFrZXJWb2ljZUNvbmZpZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydEZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYkZyb21NbGRldiQxKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhRnJvbU1sZGV2JDEoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxGcm9tTWxkZXYkMShmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRGcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFGcm9tVmVydGV4JDEoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYkZyb21WZXJ0ZXgkMShmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YUZyb21WZXJ0ZXgkMShmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbEZyb21WZXJ0ZXgkMShmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFUb01sZGV2JDIoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkMihmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkMihmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMihmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhVG9WZXJ0ZXgkMShmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9WZXJ0ZXgkMShmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvVmVydGV4JDEoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxUb1ZlcnRleCQxKGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZU5hbWUnXSk7XG4gICAgaWYgKGZyb21Wb2ljZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZU5hbWUnXSwgZnJvbVZvaWNlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHByZWJ1aWx0Vm9pY2VDb25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlTmFtZSddKTtcbiAgICBpZiAoZnJvbVZvaWNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlTmFtZSddLCBmcm9tVm9pY2VOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJvYWN0aXZpdHlDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb2FjdGl2ZUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvYWN0aXZlQXVkaW8nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvYWN0aXZlQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9hY3RpdmVBdWRpbyddLCBmcm9tUHJvYWN0aXZlQXVkaW8pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcm9hY3Rpdml0eUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9hY3RpdmVBdWRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb2FjdGl2ZUF1ZGlvJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb2FjdGl2ZUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvYWN0aXZlQXVkaW8nXSwgZnJvbVByb2FjdGl2ZUF1ZGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVhbHRpbWVJbnB1dENvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uJ10sIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9NbGRldiQxKGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlIYW5kbGluZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FjdGl2aXR5SGFuZGxpbmcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlIYW5kbGluZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5SGFuZGxpbmcnXSwgZnJvbUFjdGl2aXR5SGFuZGxpbmcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVybkNvdmVyYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dXJuQ292ZXJhZ2UnXSk7XG4gICAgaWYgKGZyb21UdXJuQ292ZXJhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dXJuQ292ZXJhZ2UnXSwgZnJvbVR1cm5Db3ZlcmFnZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlYWx0aW1lSW5wdXRDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uJ10sIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9WZXJ0ZXgoZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eUhhbmRsaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWN0aXZpdHlIYW5kbGluZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eUhhbmRsaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlIYW5kbGluZyddLCBmcm9tQWN0aXZpdHlIYW5kbGluZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ292ZXJhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1cm5Db3ZlcmFnZSddKTtcbiAgICBpZiAoZnJvbVR1cm5Db3ZlcmFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1cm5Db3ZlcmFnZSddLCBmcm9tVHVybkNvdmVyYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaGFuZGxlJ10pO1xuICAgIGlmIChmcm9tSGFuZGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaGFuZGxlJ10sIGZyb21IYW5kbGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cmFuc3BhcmVudCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNwYXJlbnQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydoYW5kbGUnXSk7XG4gICAgaWYgKGZyb21IYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydoYW5kbGUnXSwgZnJvbUhhbmRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UcmFuc3BhcmVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJhbnNwYXJlbnQnXSk7XG4gICAgaWYgKGZyb21UcmFuc3BhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RyYW5zcGFyZW50J10sIGZyb21UcmFuc3BhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNsaWRpbmdXaW5kb3dUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhcmdldFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFyZ2V0VG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVGFyZ2V0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGFyZ2V0VG9rZW5zJ10sIGZyb21UYXJnZXRUb2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzbGlkaW5nV2luZG93VG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhcmdldFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFyZ2V0VG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVGFyZ2V0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGFyZ2V0VG9rZW5zJ10sIGZyb21UYXJnZXRUb2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNwZWFrZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWFrZXInXSk7XG4gICAgaWYgKGZyb21TcGVha2VyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlYWtlciddLCBmcm9tU3BlYWtlcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Wb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21Wb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10sIHZvaWNlQ29uZmlnVG9NbGRldiQyKGZyb21Wb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2JDIoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSwgbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDIoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlZWNoQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvVmVydGV4JDEoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdGhpbmtpbmdDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUluY2x1ZGVUaG91Z2h0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVUaG91Z2h0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmNsdWRlVGhvdWdodHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmNsdWRlVGhvdWdodHMnXSwgZnJvbUluY2x1ZGVUaG91Z2h0cyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0J1ZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQnVkZ2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQnVkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdCdWRnZXQnXSwgZnJvbVRoaW5raW5nQnVkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdGhpbmtpbmdDb25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbmNsdWRlVGhvdWdodHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlVGhvdWdodHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5jbHVkZVRob3VnaHRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5jbHVkZVRob3VnaHRzJ10sIGZyb21JbmNsdWRlVGhvdWdodHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdCdWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0J1ZGdldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0J1ZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQnVkZ2V0J10sIGZyb21UaGlua2luZ0J1ZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQyKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQyKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb29nbGVNYXBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgdXJsQ29udGV4dFRvTWxkZXYkMigpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgY29tcHV0ZXJVc2VUb01sZGV2JDIoZnJvbUNvbXB1dGVyVXNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbCddLCBmcm9tUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvVmVydGV4JDEoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb1ZlcnRleCQxKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbnRlcnByaXNlV2ViU2VhcmNoJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10sIGVudGVycHJpc2VXZWJTZWFyY2hUb1ZlcnRleCQxKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvVmVydGV4JDEoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCB1cmxDb250ZXh0VG9WZXJ0ZXgkMSgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgY29tcHV0ZXJVc2VUb1ZlcnRleCQxKGZyb21Db21wdXRlclVzZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0cmFuc2NyaXB0aW9uRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbmlzaGVkJ10pO1xuICAgIGlmIChmcm9tRmluaXNoZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hlZCddLCBmcm9tRmluaXNoZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0cmFuc2NyaXB0aW9uRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbmlzaGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hlZCddKTtcbiAgICBpZiAoZnJvbUZpbmlzaGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmluaXNoZWQnXSwgZnJvbUZpbmlzaGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dE1ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVybE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxNZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbVVybE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21VcmxNZXRhZGF0YTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmxNZXRhZGF0YUZyb21NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsTWV0YWRhdGEnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dFRvTWxkZXYkMigpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRUb1ZlcnRleCQxKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsTWV0YWRhdGFGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmV0cmlldmVkVXJsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2ZWRVcmwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2ZWRVcmwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2ZWRVcmwnXSwgZnJvbVJldHJpZXZlZFVybCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxSZXRyaWV2YWxTdGF0dXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxSZXRyaWV2YWxTdGF0dXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsUmV0cmlldmFsU3RhdHVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsUmV0cmlldmFsU3RhdHVzJ10sIGZyb21VcmxSZXRyaWV2YWxTdGF0dXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1c2FnZU1ldGFkYXRhRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0VG9rZW5Db3VudCddLCBmcm9tUHJvbXB0VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudFRva2VuQ291bnQnXSwgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2VuQ291bnQnXSwgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xVc2VQcm9tcHRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbFVzZVByb21wdFRva2VuQ291bnQnXSwgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRzVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRzVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0c1Rva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0c1Rva2VuQ291bnQnXSwgZnJvbVRob3VnaHRzVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3RhbFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b3RhbFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbkNvdW50J10sIGZyb21Ub3RhbFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZVRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZVRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1c2FnZU1ldGFkYXRhRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdFRva2VuQ291bnQnXSwgZnJvbVByb21wdFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50J10sIGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVzVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2VuQ291bnQnXSwgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xVc2VQcm9tcHRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbFVzZVByb21wdFRva2VuQ291bnQnXSwgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRzVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRzVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0c1Rva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0c1Rva2VuQ291bnQnXSwgZnJvbVRob3VnaHRzVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3RhbFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b3RhbFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbkNvdW50J10sIGZyb21Ub3RhbFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbGl0eVRva2VuQ291bnRGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0VG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlVG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGFsaXR5VG9rZW5Db3VudEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZVRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZXNUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGFsaXR5VG9rZW5Db3VudEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGFsaXR5VG9rZW5Db3VudEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhZmZpY1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RyYWZmaWNUeXBlJ10pO1xuICAgIGlmIChmcm9tVHJhZmZpY1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cmFmZmljVHlwZSddLCBmcm9tVHJhZmZpY1R5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFGcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2b2ljZUNvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWJ1aWx0Vm9pY2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWJ1aWx0Vm9pY2VDb25maWcnXSwgcHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYkMihmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2b2ljZUNvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVidWlsdFZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVidWlsdFZvaWNlQ29uZmlnJ10sIHByZWJ1aWx0Vm9pY2VDb25maWdUb1ZlcnRleCQxKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHdlaWdodGVkUHJvbXB0RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tV2VpZ2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd3ZWlnaHQnXSk7XG4gICAgaWYgKGZyb21XZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd3ZWlnaHQnXSwgZnJvbVdlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHdlaWdodGVkUHJvbXB0VG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVdlaWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnd2VpZ2h0J10pO1xuICAgIGlmIChmcm9tV2VpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnd2VpZ2h0J10sIGZyb21XZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGFwaUtleUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BcGlLZXlTdHJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FwaUtleVN0cmluZyddKTtcbiAgICBpZiAoZnJvbUFwaUtleVN0cmluZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FwaUtleVN0cmluZyddLCBmcm9tQXBpS2V5U3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXV0aENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BcGlLZXlDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FwaUtleUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUFwaUtleUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FwaUtleUNvbmZpZyddLCBhcGlLZXlDb25maWdUb1ZlcnRleChmcm9tQXBpS2V5Q29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdXRoVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aFR5cGUnXSk7XG4gICAgaWYgKGZyb21BdXRoVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dGhUeXBlJ10sIGZyb21BdXRoVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VydmljZUFjY291bnRDb25maWcnXSwgZnJvbUdvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUh0dHBCYXNpY0F1dGhDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdodHRwQmFzaWNBdXRoQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUh0dHBCYXNpY0F1dGhDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydodHRwQmFzaWNBdXRoQ29uZmlnJ10sIGZyb21IdHRwQmFzaWNBdXRoQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU9hdXRoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvYXV0aENvbmZpZyddKTtcbiAgICBpZiAoZnJvbU9hdXRoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb2F1dGhDb25maWcnXSwgZnJvbU9hdXRoQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU9pZGNDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ29pZGNDb25maWcnXSk7XG4gICAgaWYgKGZyb21PaWRjQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb2lkY0NvbmZpZyddLCBmcm9tT2lkY0NvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5kaWRhdGVGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnQnXSk7XG4gICAgaWYgKGZyb21Db250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudCddLCBjb250ZW50RnJvbU1sZGV2KGZyb21Db250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaXRhdGlvbk1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2l0YXRpb25NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbk1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25NZXRhZGF0YSddLCBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2KGZyb21DaXRhdGlvbk1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hSZWFzb24nXSk7XG4gICAgaWYgKGZyb21GaW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hSZWFzb24nXSwgZnJvbUZpbmlzaFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0TWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxDb250ZXh0TWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dE1ldGFkYXRhJ10sIHVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldihmcm9tVXJsQ29udGV4dE1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdmdMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21BdmdMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10sIGZyb21BdmdMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hcm91bmRpbmdNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dyb3VuZGluZ01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdyb3VuZGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3JvdW5kaW5nTWV0YWRhdGEnXSwgZnJvbUdyb3VuZGluZ01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluZGV4ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmRleCddKTtcbiAgICBpZiAoZnJvbUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5kZXgnXSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ncHJvYnNSZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTG9ncHJvYnNSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9ic1Jlc3VsdCddLCBmcm9tTG9ncHJvYnNSZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5UmF0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVJhdGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2FmZXR5UmF0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eVJhdGluZ3MnXSwgZnJvbVNhZmV0eVJhdGluZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5kaWRhdGVGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50J10pO1xuICAgIGlmIChmcm9tQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnQnXSwgY29udGVudEZyb21WZXJ0ZXgoZnJvbUNvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNpdGF0aW9uTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjaXRhdGlvbk1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9uTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaXRhdGlvbk1ldGFkYXRhJ10sIGNpdGF0aW9uTWV0YWRhdGFGcm9tVmVydGV4KGZyb21DaXRhdGlvbk1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaW5pc2hNZXNzYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZmluaXNoTWVzc2FnZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GaW5pc2hNZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmluaXNoTWVzc2FnZSddLCBmcm9tRmluaXNoTWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaW5pc2hSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddKTtcbiAgICBpZiAoZnJvbUZpbmlzaFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddLCBmcm9tRmluaXNoUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHRNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VybENvbnRleHRNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0TWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0TWV0YWRhdGEnXSwgdXJsQ29udGV4dE1ldGFkYXRhRnJvbVZlcnRleChmcm9tVXJsQ29udGV4dE1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdmdMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21BdmdMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10sIGZyb21BdmdMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hcm91bmRpbmdNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dyb3VuZGluZ01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdyb3VuZGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3JvdW5kaW5nTWV0YWRhdGEnXSwgZnJvbUdyb3VuZGluZ01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluZGV4ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmRleCddKTtcbiAgICBpZiAoZnJvbUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5kZXgnXSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ncHJvYnNSZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTG9ncHJvYnNSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9ic1Jlc3VsdCddLCBmcm9tTG9ncHJvYnNSZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5UmF0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVJhdGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2FmZXR5UmF0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eVJhdGluZ3MnXSwgZnJvbVNhZmV0eVJhdGluZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjaGVja3BvaW50RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2hlY2twb2ludElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaGVja3BvaW50SWQnXSk7XG4gICAgaWYgKGZyb21DaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaGVja3BvaW50SWQnXSwgZnJvbUNoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcG9jaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2gnXSk7XG4gICAgaWYgKGZyb21FcG9jaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vwb2NoJ10sIGZyb21FcG9jaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGVwID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGVwJ10pO1xuICAgIGlmIChmcm9tU3RlcCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0ZXAnXSwgZnJvbVN0ZXApO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DaXRhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NpdGF0aW9uU291cmNlcyddKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9ucyddLCBmcm9tQ2l0YXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2l0YXRpb25NZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNpdGF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2l0YXRpb25zJ10pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25zJ10sIGZyb21DaXRhdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlVG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbnNJbmZvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbnNJbmZvJ10pO1xuICAgIGlmIChmcm9tVG9rZW5zSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2Vuc0luZm8nXSwgZnJvbVRva2Vuc0luZm8pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlclVzZVRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRW52aXJvbm1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vudmlyb25tZW50J10pO1xuICAgIGlmIChmcm9tRW52aXJvbm1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnZpcm9ubWVudCddLCBmcm9tRW52aXJvbm1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyddLCBmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZXJVc2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRW52aXJvbm1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vudmlyb25tZW50J10pO1xuICAgIGlmIChmcm9tRW52aXJvbm1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnZpcm9ubWVudCddLCBmcm9tRW52aXJvbm1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyddLCBmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEVtYmVkZGluZ0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmFsdWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2YWx1ZXMnXSk7XG4gICAgaWYgKGZyb21WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2YWx1ZXMnXSwgZnJvbVZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRFbWJlZGRpbmdGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WYWx1ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZhbHVlcyddKTtcbiAgICBpZiAoZnJvbVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZhbHVlcyddLCBmcm9tVmFsdWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRpc3RpY3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRpc3RpY3MnXSk7XG4gICAgaWYgKGZyb21TdGF0aXN0aWNzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGlzdGljcyddLCBjb250ZW50RW1iZWRkaW5nU3RhdGlzdGljc0Zyb21WZXJ0ZXgoZnJvbVN0YXRpc3RpY3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEVtYmVkZGluZ1N0YXRpc3RpY3NGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UcnVuY2F0ZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RydW5jYXRlZCddKTtcbiAgICBpZiAoZnJvbVRydW5jYXRlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RydW5jYXRlZCddLCBmcm9tVHJ1bmNhdGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuX2NvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydEZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250cm9sUmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbnRyb2xUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250cm9sVHlwZSddKTtcbiAgICBpZiAoZnJvbUNvbnRyb2xUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udHJvbFR5cGUnXSwgZnJvbUNvbnRyb2xUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQ29udHJvbEltYWdlQ29tcHV0YXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5hYmxlQ29udHJvbEltYWdlQ29tcHV0YXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlQ29udHJvbCddLCBmcm9tRW5hYmxlQ29udHJvbEltYWdlQ29tcHV0YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N5c3RlbUluc3RydWN0aW9uIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29scyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW5lcmF0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9WZXJ0ZXgodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21HZW5lcmF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY291bnRUb2tlbnNDb25maWdUb01sZGV2KGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjb3VudFRva2Vuc0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3RhbFRva2VucyddKTtcbiAgICBpZiAoZnJvbVRvdGFsVG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbnMnXSwgZnJvbVRvdGFsVG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50VG9rZW5Db3VudCddLCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3RhbFRva2VucyddKTtcbiAgICBpZiAoZnJvbVRvdGFsVG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbnMnXSwgZnJvbVRvdGFsVG9rZW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHluYW1pY1RocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1RocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNUaHJlc2hvbGQnXSwgZnJvbUR5bmFtaWNUaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVkaXRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkZFdhdGVybWFyayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRkV2F0ZXJtYXJrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYWRkV2F0ZXJtYXJrJ10sIGZyb21BZGRXYXRlcm1hcmspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRWRpdE1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VkaXRNb2RlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRWRpdE1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0TW9kZSddLCBmcm9tRWRpdE1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZVN0ZXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlU3RlcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXNlU3RlcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0Q29uZmlnJywgJ2Jhc2VTdGVwcyddLCBmcm9tQmFzZVN0ZXBzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZUltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVmZXJlbmNlSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdyZWZlcmVuY2VJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZWRpdEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlZGl0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXNrVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFza1R5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UYXNrVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3Rhc2tUeXBlJ10sIGZyb21UYXNrVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dERpbWVuc2lvbmFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnb3V0cHV0RGltZW5zaW9uYWxpdHknXSwgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pbWVUeXBlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dG9UcnVuY2F0ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0b1RydW5jYXRlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhc2tUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0YXNrVHlwZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRhc2tUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1tdJywgJ3Rhc2tfdHlwZSddLCBmcm9tVGFza1R5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0RGltZW5zaW9uYWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXREaW1lbnNpb25hbGl0eSddLCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1dG9UcnVuY2F0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0b1RydW5jYXRlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXV0b1RydW5jYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXV0b1RydW5jYXRlJ10sIGZyb21BdXRvVHJ1bmNhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRNZXRhZGF0YUZyb21NbGRldigpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudE1ldGFkYXRhRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmlsbGFibGVDaGFyYWN0ZXJDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpbGxhYmxlQ2hhcmFjdGVyQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmlsbGFibGVDaGFyYWN0ZXJDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpbGxhYmxlQ2hhcmFjdGVyQ291bnQnXSwgZnJvbUJpbGxhYmxlQ2hhcmFjdGVyQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnY29udGVudCddLCB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIGZyb21Db250ZW50cykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHNbXScsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzW10nLCAnY29udGVudCddLCB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIGZyb21Db250ZW50cykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBlbWJlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW1iZWRkaW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW1iZWRkaW5ncyddKTtcbiAgICBpZiAoZnJvbUVtYmVkZGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUVtYmVkZGluZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudEVtYmVkZGluZ0Zyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VtYmVkZGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZW1iZWRDb250ZW50TWV0YWRhdGFGcm9tTWxkZXYoKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVtYmVkZGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9uc1tdJyxcbiAgICAgICAgJ2VtYmVkZGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW1iZWRkaW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRW1iZWRkaW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50RW1iZWRkaW5nRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VtYmVkZGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZW1iZWRDb250ZW50TWV0YWRhdGFGcm9tVmVydGV4KGZyb21NZXRhZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbmRwb2ludEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZHBvaW50J10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVwbG95ZWRNb2RlbElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZGVwbG95ZWRNb2RlbElkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURlcGxveWVkTW9kZWxJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RlcGxveWVkTW9kZWxJZCddLCBmcm9tRGVwbG95ZWRNb2RlbElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW50ZXJwcmlzZVdlYlNlYXJjaFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FeGNsdWRlRG9tYWlucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4Y2x1ZGVEb21haW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4Y2x1ZGVEb21haW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSwgZnJvbUV4Y2x1ZGVEb21haW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW50aXR5TGFiZWxGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYWJlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWwnXSk7XG4gICAgaWYgKGZyb21MYWJlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhYmVsJ10sIGZyb21MYWJlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY29yZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2NvcmUnXSk7XG4gICAgaWYgKGZyb21TY29yZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Njb3JlJ10sIGZyb21TY29yZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CZWhhdmlvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSk7XG4gICAgaWYgKGZyb21CZWhhdmlvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JlaGF2aW9yJ10sIGZyb21CZWhhdmlvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZWhhdmlvciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvTWxkZXYkMSh0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZUNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVDb3VudCddLCBmcm9tQ2FuZGlkYXRlQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0b3BTZXF1ZW5jZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdG9wU2VxdWVuY2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0b3BTZXF1ZW5jZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdG9wU2VxdWVuY2VzJ10sIGZyb21TdG9wU2VxdWVuY2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUxvZ3Byb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUxvZ3Byb2JzJ10sIGZyb21SZXNwb25zZUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnMnXSwgZnJvbUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZXNlbmNlUGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVzZW5jZVBlbmFsdHknXSwgZnJvbVByZXNlbmNlUGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcmVxdWVuY3lQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnJlcXVlbmN5UGVuYWx0eSddLCBmcm9tRnJlcXVlbmN5UGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VTY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlU2NoZW1hJ10sIHNjaGVtYVRvTWxkZXYodFNjaGVtYShmcm9tUmVzcG9uc2VTY2hlbWEpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb3V0aW5nQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyb3V0aW5nQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsU2VsZWN0aW9uQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlbFNlbGVjdGlvbkNvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5U2V0dGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlTZXR0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlTZXR0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU2FmZXR5U2V0dGluZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2FmZXR5U2V0dGluZ1RvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2FmZXR5U2V0dGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDEodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb01sZGV2KGZyb21Ub29sQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFiZWxzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DYWNoZWRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NhY2hlZENvbnRlbnQnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbUNhY2hlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgc3BlZWNoQ29uZmlnVG9NbGRldiQxKHRTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1ZGlvVGltZXN0YW1wIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgdGhpbmtpbmdDb25maWdUb01sZGV2JDEoZnJvbVRoaW5raW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21JbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10sIGltYWdlQ29uZmlnVG9NbGRldihmcm9tSW1hZ2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb1ZlcnRleCh0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZUNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVDb3VudCddLCBmcm9tQ2FuZGlkYXRlQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0b3BTZXF1ZW5jZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdG9wU2VxdWVuY2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0b3BTZXF1ZW5jZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdG9wU2VxdWVuY2VzJ10sIGZyb21TdG9wU2VxdWVuY2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUxvZ3Byb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUxvZ3Byb2JzJ10sIGZyb21SZXNwb25zZUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnMnXSwgZnJvbUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZXNlbmNlUGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVzZW5jZVBlbmFsdHknXSwgZnJvbVByZXNlbmNlUGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcmVxdWVuY3lQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnJlcXVlbmN5UGVuYWx0eSddLCBmcm9tRnJlcXVlbmN5UGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VTY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlU2NoZW1hJ10sIHNjaGVtYVRvVmVydGV4KHRTY2hlbWEoZnJvbVJlc3BvbnNlU2NoZW1hKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvdXRpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyb3V0aW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJvdXRpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb3V0aW5nQ29uZmlnJ10sIGZyb21Sb3V0aW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbW9kZWxTZWxlY3Rpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbENvbmZpZyddLCBtb2RlbFNlbGVjdGlvbkNvbmZpZ1RvVmVydGV4KGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5U2V0dGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlTZXR0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlTZXR0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU2FmZXR5U2V0dGluZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2FmZXR5U2V0dGluZ1RvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb1ZlcnRleChmcm9tVG9vbENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ2FjaGVkQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjYWNoZWRDb250ZW50J10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21DYWNoZWRDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIHNwZWVjaENvbmZpZ1RvVmVydGV4KHRTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvVGltZXN0YW1wID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9UaW1lc3RhbXAnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9UaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddLCBmcm9tQXVkaW9UaW1lc3RhbXApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIHRoaW5raW5nQ29uZmlnVG9WZXJ0ZXgoZnJvbVRoaW5raW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21JbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10sIGltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2FuZGlkYXRlcyddKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhbmRpZGF0ZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxWZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFZlcnNpb24nXSwgZnJvbU1vZGVsVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRGZWVkYmFjayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdEZlZWRiYWNrJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdEZlZWRiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0RmVlZGJhY2snXSwgZnJvbVByb21wdEZlZWRiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VJZCddLCBmcm9tUmVzcG9uc2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCBmcm9tVXNhZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYW5kaWRhdGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxWZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFZlcnNpb24nXSwgZnJvbU1vZGVsVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRGZWVkYmFjayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdEZlZWRiYWNrJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdEZlZWRiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0RmVlZGJhY2snXSwgZnJvbVByb21wdEZlZWRiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VJZCddLCBmcm9tUmVzcG9uc2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCBmcm9tVXNhZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0R2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25lZ2F0aXZlUHJvbXB0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWdhdGl2ZVByb21wdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlZWQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUZpbHRlckxldmVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5RmlsdGVyTGV2ZWwnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYWZldHlTZXR0aW5nJ10sIGZyb21TYWZldHlGaWx0ZXJMZXZlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnXSwgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVSYWlSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlUmFpUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVSYWlSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlUmFpUmVhc29uJ10sIGZyb21JbmNsdWRlUmFpUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhbmd1YWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbGFuZ3VhZ2UnXSwgZnJvbUxhbmd1YWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dE1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0TWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0TWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ21pbWVUeXBlJ10sIGZyb21PdXRwdXRNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkZFdhdGVybWFyayddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkV2F0ZXJtYXJrIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUltYWdlU2l6ZSddLCBmcm9tSW1hZ2VTaXplKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5oYW5jZVByb21wdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW5oYW5jZVByb21wdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkZFdhdGVybWFyayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRkV2F0ZXJtYXJrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYWRkV2F0ZXJtYXJrJ10sIGZyb21BZGRXYXRlcm1hcmspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVJbWFnZVNpemUnXSwgZnJvbUltYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21NbGRldihmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4KGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU51bWJlck9mVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZWaWRlb3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZWaWRlb3MpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dEdjc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZwcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHVyYXRpb25TZWNvbmRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHVyYXRpb25TZWNvbmRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUR1cmF0aW9uU2Vjb25kcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2R1cmF0aW9uU2Vjb25kcyddLCBmcm9tRHVyYXRpb25TZWNvbmRzKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VlZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzb2x1dGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdyZXNvbHV0aW9uJ10sIGZyb21SZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHVic3ViVG9waWMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1YnN1YlRvcGljIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZWdhdGl2ZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25lZ2F0aXZlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU5lZ2F0aXZlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbmVnYXRpdmVQcm9tcHQnXSwgZnJvbU5lZ2F0aXZlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2VuZXJhdGVBdWRpbyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VuZXJhdGVBdWRpbyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXN0RnJhbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3RGcmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZWZlcmVuY2VJbWFnZXMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlZmVyZW5jZUltYWdlcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXNrIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXByZXNzaW9uUXVhbGl0eSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29tcHJlc3Npb25RdWFsaXR5IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZlZpZGVvcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZlZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZlZpZGVvcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRHY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3N0b3JhZ2VVcmknXSwgZnJvbU91dHB1dEdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR1cmF0aW9uU2Vjb25kcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R1cmF0aW9uU2Vjb25kcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EdXJhdGlvblNlY29uZHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdkdXJhdGlvblNlY29uZHMnXSwgZnJvbUR1cmF0aW9uU2Vjb25kcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzb2x1dGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdyZXNvbHV0aW9uJ10sIGZyb21SZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVB1YnN1YlRvcGljID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwdWJzdWJUb3BpYyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVB1YnN1YlRvcGljICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncHVic3ViVG9waWMnXSwgZnJvbVB1YnN1YlRvcGljKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VuaGFuY2VQcm9tcHQnXSwgZnJvbUVuaGFuY2VQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVBdWRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRlQXVkaW8nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGVBdWRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2dlbmVyYXRlQXVkaW8nXSwgZnJvbUdlbmVyYXRlQXVkaW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFzdEZyYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXN0RnJhbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYXN0RnJhbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2xhc3RGcmFtZSddLCBpbWFnZVRvVmVydGV4KGZyb21MYXN0RnJhbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZUltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZUltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWZlcmVuY2VJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVJlZmVyZW5jZUltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlb0dlbmVyYXRpb25SZWZlcmVuY2VJbWFnZVRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdyZWZlcmVuY2VJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2snXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdtYXNrJ10sIHZpZGVvR2VuZXJhdGlvbk1hc2tUb1ZlcnRleChmcm9tTWFzaykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tQ29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZScsXG4gICAgICAgICdnZW5lcmF0ZVZpZGVvUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvTWxkZXYoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2aWRlbyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvTWxkZXYoZnJvbVNvdXJjZSwgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAndmlkZW8nXSwgdmlkZW9Ub1ZlcnRleChmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb1ZlcnRleChmcm9tU291cmNlLCB0b09iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0ZWRTYW1wbGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvcyddKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvTWxkZXYoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2aWRlbyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICd2aWRlbyddLCB2aWRlb1RvVmVydGV4KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRJbWFnZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZUZyb21NbGRldihmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaUZpbHRlcmVkUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpRmlsdGVyZWRSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpRmlsdGVyZWRSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlGaWx0ZXJlZFJlYXNvbiddLCBmcm9tUmFpRmlsdGVyZWRSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21TYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2KGZyb21TYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZUZyb21WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlGaWx0ZXJlZFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaUZpbHRlcmVkUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaUZpbHRlcmVkUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpRmlsdGVyZWRSZWFzb24nXSwgZnJvbVJhaUZpbHRlcmVkUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgoZnJvbVNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VkUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21FbmhhbmNlZFByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuaGFuY2VkUHJvbXB0J10sIGZyb21FbmhhbmNlZFByb21wdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZEltYWdlTWFza0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1hc2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tTWFzayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2snXSwgaW1hZ2VGcm9tVmVydGV4KGZyb21NYXNrKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAoZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tTGFiZWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudGl0eUxhYmVsRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhYmVscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21NbGRldihmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbVZlcnRleChmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZU1hcHNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKTtcbiAgICBpZiAoZnJvbUF1dGhDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdXRoQ29uZmlnJ10sIGF1dGhDb25maWdUb1ZlcnRleChmcm9tQXV0aENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljUmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljUmV0cmlldmFsQ29uZmlnJ10sIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDEoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljUmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljUmV0cmlldmFsQ29uZmlnJ10sIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgaW50ZXJ2YWxUb01sZGV2JDEoZnJvbVRpbWVSYW5nZUZpbHRlcikpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGNsdWRlRG9tYWlucyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZURvbWFpbnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgaW50ZXJ2YWxUb1ZlcnRleChmcm9tVGltZVJhbmdlRmlsdGVyKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGNsdWRlRG9tYWlucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4Y2x1ZGVEb21haW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4Y2x1ZGVEb21haW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSwgZnJvbUV4Y2x1ZGVEb21haW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAoZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQnl0ZXMnXSwgdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYnl0ZXNCYXNlNjRFbmNvZGVkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUltYWdlQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZUJ5dGVzJ10sIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnl0ZXNCYXNlNjRFbmNvZGVkJ10sIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnl0ZXNCYXNlNjRFbmNvZGVkJ10sIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbnRlcnZhbFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbnRlcnZhbFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxhdExuZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhdGl0dWRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXRpdHVkZSddKTtcbiAgICBpZiAoZnJvbUxhdGl0dWRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGF0aXR1ZGUnXSwgZnJvbUxhdGl0dWRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvbmdpdHVkZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9uZ2l0dWRlJ10pO1xuICAgIGlmIChmcm9tTG9uZ2l0dWRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9uZ2l0dWRlJ10sIGZyb21Mb25naXR1ZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsYXRMbmdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGF0aXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdGl0dWRlJ10pO1xuICAgIGlmIChmcm9tTGF0aXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXRpdHVkZSddLCBmcm9tTGF0aXR1ZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9uZ2l0dWRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb25naXR1ZGUnXSk7XG4gICAgaWYgKGZyb21Mb25naXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb25naXR1ZGUnXSwgZnJvbUxvbmdpdHVkZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZpbHRlciddLCBmcm9tRmlsdGVyKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVF1ZXJ5QmFzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncXVlcnlCYXNlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUXVlcnlCYXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ191cmwnLCAnbW9kZWxzX3VybCddLCB0TW9kZWxzVXJsKGFwaUNsaWVudCwgZnJvbVF1ZXJ5QmFzZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0TW9kZWxzQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUXVlcnlCYXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydxdWVyeUJhc2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21RdWVyeUJhc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3VybCcsICdtb2RlbHNfdXJsJ10sIHRNb2RlbHNVcmwoYXBpQ2xpZW50LCBmcm9tUXVlcnlCYXNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RNb2RlbHNDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0TW9kZWxzUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdE1vZGVsc0NvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0TW9kZWxzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tTW9kZWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRFeHRyYWN0TW9kZWxzKGZyb21Nb2RlbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tTW9kZWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRFeHRyYWN0TW9kZWxzKGZyb21Nb2RlbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtYXNrUmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1hc2tNb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrTW9kZSddKTtcbiAgICBpZiAoZnJvbU1hc2tNb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza01vZGUnXSwgZnJvbU1hc2tNb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZ21lbnRhdGlvbkNsYXNzZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZWdtZW50YXRpb25DbGFzc2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlZ21lbnRhdGlvbkNsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrQ2xhc3NlcyddLCBmcm9tU2VnbWVudGF0aW9uQ2xhc3Nlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrRGlsYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2tEaWxhdGlvbiddKTtcbiAgICBpZiAoZnJvbU1hc2tEaWxhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RpbGF0aW9uJ10sIGZyb21NYXNrRGlsYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtb2RlbEZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21WZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmVyc2lvbiddLCBmcm9tVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsSW5mbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWxJbmZvJ10sIHR1bmVkTW9kZWxJbmZvRnJvbU1sZGV2KGZyb21UdW5lZE1vZGVsSW5mbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRUb2tlbkxpbWl0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRUb2tlbkxpbWl0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlucHV0VG9rZW5MaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lucHV0VG9rZW5MaW1pdCddLCBmcm9tSW5wdXRUb2tlbkxpbWl0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dFRva2VuTGltaXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRUb2tlbkxpbWl0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU91dHB1dFRva2VuTGltaXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvdXRwdXRUb2tlbkxpbWl0J10sIGZyb21PdXRwdXRUb2tlbkxpbWl0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN1cHBvcnRlZEFjdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdXBwb3J0ZWRHZW5lcmF0aW9uTWV0aG9kcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdXBwb3J0ZWRBY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3VwcG9ydGVkQWN0aW9ucyddLCBmcm9tU3VwcG9ydGVkQWN0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZlcnNpb25JZCddKTtcbiAgICBpZiAoZnJvbVZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2ZXJzaW9uJ10sIGZyb21WZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZHBvaW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVwbG95ZWRNb2RlbHMnXSk7XG4gICAgaWYgKGZyb21FbmRwb2ludHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUVuZHBvaW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRwb2ludEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbEluZm8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbEluZm8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsSW5mbyddLCB0dW5lZE1vZGVsSW5mb0Zyb21WZXJ0ZXgoZnJvbVR1bmVkTW9kZWxJbmZvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZWZhdWx0Q2hlY2twb2ludElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZGVmYXVsdENoZWNrcG9pbnRJZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EZWZhdWx0Q2hlY2twb2ludElkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVmYXVsdENoZWNrcG9pbnRJZCddLCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaGVja3BvaW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2hlY2twb2ludHMnXSk7XG4gICAgaWYgKGZyb21DaGVja3BvaW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2hlY2twb2ludHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2twb2ludEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaGVja3BvaW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtb2RlbFNlbGVjdGlvbkNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UnXSwgZnJvbUZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzcGVha2VyVm9pY2VDb25maWdzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlYWtlclZvaWNlQ29uZmlncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhRnJvbU1sZGV2KGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JGcm9tTWxkZXYoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFGcm9tTWxkZXYoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxGcm9tTWxkZXYoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYkZyb21WZXJ0ZXgoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFGcm9tVmVydGV4KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsRnJvbVZlcnRleChmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFUb01sZGV2JDEoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkMShmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkMShmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMShmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YVRvVmVydGV4KGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb1ZlcnRleChmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvVmVydGV4KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9WZXJ0ZXgoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlTmFtZSddKTtcbiAgICBpZiAoZnJvbVZvaWNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlTmFtZSddLCBmcm9tVm9pY2VOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJlYnVpbHRWb2ljZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlTmFtZSddKTtcbiAgICBpZiAoZnJvbVZvaWNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlTmFtZSddLCBmcm9tVm9pY2VOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJvZHVjdEltYWdlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb2R1Y3RJbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvZHVjdEltYWdlJ10pO1xuICAgIGlmIChmcm9tUHJvZHVjdEltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tUHJvZHVjdEltYWdlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlY29udGV4dEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlU3RlcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VTdGVwcyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJhc2VTdGVwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VkaXRDb25maWcnLCAnYmFzZVN0ZXBzJ10sIGZyb21CYXNlU3RlcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUZpbHRlckxldmVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5RmlsdGVyTGV2ZWwnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYWZldHlTZXR0aW5nJ10sIGZyb21TYWZldHlGaWx0ZXJMZXZlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BZGRXYXRlcm1hcmsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkZFdhdGVybWFyayddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFkZFdhdGVybWFyayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FkZFdhdGVybWFyayddLCBmcm9tQWRkV2F0ZXJtYXJrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dE1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0TWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0TWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ21pbWVUeXBlJ10sIGZyb21PdXRwdXRNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlY29udGV4dEltYWdlUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgcmVjb250ZXh0SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tU291cmNlLCB0b09iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHJlY29udGV4dEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWNvbnRleHRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlY29udGV4dEltYWdlU291cmNlVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwZXJzb25JbWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwZXJzb25JbWFnZScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21QZXJzb25JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvZHVjdEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb2R1Y3RJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvZHVjdEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUHJvZHVjdEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9kdWN0SW1hZ2VUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvZHVjdEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWZlcmVuY2VJbWFnZUFQSUludGVybmFsVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZWZlcmVuY2VJbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21SZWZlcmVuY2VJbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JlZmVyZW5jZUlkJ10pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZWZlcmVuY2VJZCddLCBmcm9tUmVmZXJlbmNlSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZVR5cGUnXSwgZnJvbVJlZmVyZW5jZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFza0ltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWFza0ltYWdlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1hc2tJbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2tJbWFnZUNvbmZpZyddLCBtYXNrUmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU1hc2tJbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udHJvbEltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udHJvbEltYWdlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvbnRyb2xJbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRyb2xJbWFnZUNvbmZpZyddLCBjb250cm9sUmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbnRyb2xJbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3R5bGVJbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0eWxlSW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3R5bGVJbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0eWxlSW1hZ2VDb25maWcnXSwgc3R5bGVSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tU3R5bGVJbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3ViamVjdEltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3ViamVjdEltYWdlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN1YmplY3RJbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N1YmplY3RJbWFnZUNvbmZpZyddLCBzdWJqZWN0UmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbVN1YmplY3RJbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZXRyaWV2YWxDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRMbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdExuZyddKTtcbiAgICBpZiAoZnJvbUxhdExuZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdExuZyddLCBsYXRMbmdUb01sZGV2KGZyb21MYXRMbmcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10pO1xuICAgIGlmIChmcm9tTGFuZ3VhZ2VDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10sIGZyb21MYW5ndWFnZUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZXRyaWV2YWxDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGF0TG5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXRMbmcnXSk7XG4gICAgaWYgKGZyb21MYXRMbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXRMbmcnXSwgbGF0TG5nVG9WZXJ0ZXgoZnJvbUxhdExuZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eUF0dHJpYnV0ZXNGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNhdGVnb3JpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ2NhdGVnb3JpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcmllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhdGVnb3JpZXMnXSwgZnJvbUNhdGVnb3JpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NvcmVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5QXR0cmlidXRlcycsXG4gICAgICAgICdzY29yZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2NvcmVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2NvcmVzJ10sIGZyb21TY29yZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10pO1xuICAgIGlmIChmcm9tQ29udGVudFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50VHlwZSddLCBmcm9tQ29udGVudFR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzYWZldHlBdHRyaWJ1dGVzRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcmllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnY2F0ZWdvcmllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yaWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcmllcyddLCBmcm9tQ2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY29yZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ3Njb3JlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TY29yZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY29yZXMnXSwgZnJvbVNjb3Jlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50VHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250ZW50VHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10sIGZyb21Db250ZW50VHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eVNldHRpbmdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGhvZCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYXRlZ29yeSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2F0ZWdvcnknXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yeSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhdGVnb3J5J10sIGZyb21DYXRlZ29yeSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RocmVzaG9sZCddKTtcbiAgICBpZiAoZnJvbVRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RocmVzaG9sZCddLCBmcm9tVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5U2V0dGluZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZXRob2QgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGhvZCddKTtcbiAgICBpZiAoZnJvbU1ldGhvZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGhvZCddLCBmcm9tTWV0aG9kKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhdGVnb3J5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYXRlZ29yeSddKTtcbiAgICBpZiAoZnJvbUNhdGVnb3J5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcnknXSwgZnJvbUNhdGVnb3J5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhyZXNob2xkJ10pO1xuICAgIGlmIChmcm9tVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhyZXNob2xkJ10sIGZyb21UaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzY2hlbWFUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BbnlPZiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYW55T2YnXSk7XG4gICAgaWYgKGZyb21BbnlPZiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FueU9mJ10sIGZyb21BbnlPZik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZWZhdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZWZhdWx0J10pO1xuICAgIGlmIChmcm9tRGVmYXVsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RlZmF1bHQnXSwgZnJvbURlZmF1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW51bSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW51bSddKTtcbiAgICBpZiAoZnJvbUVudW0gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnVtJ10sIGZyb21FbnVtKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4YW1wbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4YW1wbGUnXSk7XG4gICAgaWYgKGZyb21FeGFtcGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhhbXBsZSddLCBmcm9tRXhhbXBsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUl0ZW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpdGVtcyddKTtcbiAgICBpZiAoZnJvbUl0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaXRlbXMnXSwgZnJvbUl0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heEl0ZW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhJdGVtcyddKTtcbiAgICBpZiAoZnJvbU1heEl0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4SXRlbXMnXSwgZnJvbU1heEl0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heExlbmd0aCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWF4TGVuZ3RoJ10pO1xuICAgIGlmIChmcm9tTWF4TGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4TGVuZ3RoJ10sIGZyb21NYXhMZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4UHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heFByb3BlcnRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4UHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heFByb3BlcnRpZXMnXSwgZnJvbU1heFByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4aW11bSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWF4aW11bSddKTtcbiAgICBpZiAoZnJvbU1heGltdW0gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhpbXVtJ10sIGZyb21NYXhpbXVtKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbkl0ZW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5JdGVtcyddKTtcbiAgICBpZiAoZnJvbU1pbkl0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluSXRlbXMnXSwgZnJvbU1pbkl0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbkxlbmd0aCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluTGVuZ3RoJ10pO1xuICAgIGlmIChmcm9tTWluTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluTGVuZ3RoJ10sIGZyb21NaW5MZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWluUHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21pblByb3BlcnRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWluUHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pblByb3BlcnRpZXMnXSwgZnJvbU1pblByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWluaW11bSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluaW11bSddKTtcbiAgICBpZiAoZnJvbU1pbmltdW0gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5pbXVtJ10sIGZyb21NaW5pbXVtKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU51bGxhYmxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydudWxsYWJsZSddKTtcbiAgICBpZiAoZnJvbU51bGxhYmxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbnVsbGFibGUnXSwgZnJvbU51bGxhYmxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhdHRlcm4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhdHRlcm4nXSk7XG4gICAgaWYgKGZyb21QYXR0ZXJuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGF0dGVybiddLCBmcm9tUGF0dGVybik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9wZXJ0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9wZXJ0aWVzJ10pO1xuICAgIGlmIChmcm9tUHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb3BlcnRpZXMnXSwgZnJvbVByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvcGVydHlPcmRlcmluZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb3BlcnR5T3JkZXJpbmcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvcGVydHlPcmRlcmluZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb3BlcnR5T3JkZXJpbmcnXSwgZnJvbVByb3BlcnR5T3JkZXJpbmcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVxdWlyZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JlcXVpcmVkJ10pO1xuICAgIGlmIChmcm9tUmVxdWlyZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1aXJlZCddLCBmcm9tUmVxdWlyZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHlwZSddKTtcbiAgICBpZiAoZnJvbVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0eXBlJ10sIGZyb21UeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2NoZW1hVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFueU9mID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhbnlPZiddKTtcbiAgICBpZiAoZnJvbUFueU9mICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYW55T2YnXSwgZnJvbUFueU9mKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RlZmF1bHQnXSk7XG4gICAgaWYgKGZyb21EZWZhdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVmYXVsdCddLCBmcm9tRGVmYXVsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnVtJ10pO1xuICAgIGlmIChmcm9tRW51bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VudW0nXSwgZnJvbUVudW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhhbXBsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhhbXBsZSddKTtcbiAgICBpZiAoZnJvbUV4YW1wbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGFtcGxlJ10sIGZyb21FeGFtcGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2l0ZW1zJ10pO1xuICAgIGlmIChmcm9tSXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpdGVtcyddLCBmcm9tSXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4SXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heEl0ZW1zJ10pO1xuICAgIGlmIChmcm9tTWF4SXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhJdGVtcyddLCBmcm9tTWF4SXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4TGVuZ3RoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhMZW5ndGgnXSk7XG4gICAgaWYgKGZyb21NYXhMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhMZW5ndGgnXSwgZnJvbU1heExlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhQcm9wZXJ0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4UHJvcGVydGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhQcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4UHJvcGVydGllcyddLCBmcm9tTWF4UHJvcGVydGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhpbXVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhpbXVtJ10pO1xuICAgIGlmIChmcm9tTWF4aW11bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heGltdW0nXSwgZnJvbU1heGltdW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWluSXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbkl0ZW1zJ10pO1xuICAgIGlmIChmcm9tTWluSXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5JdGVtcyddLCBmcm9tTWluSXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWluTGVuZ3RoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5MZW5ndGgnXSk7XG4gICAgaWYgKGZyb21NaW5MZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5MZW5ndGgnXSwgZnJvbU1pbkxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5Qcm9wZXJ0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWluUHJvcGVydGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NaW5Qcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluUHJvcGVydGllcyddLCBmcm9tTWluUHJvcGVydGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5pbXVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5pbXVtJ10pO1xuICAgIGlmIChmcm9tTWluaW11bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbmltdW0nXSwgZnJvbU1pbmltdW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVsbGFibGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ251bGxhYmxlJ10pO1xuICAgIGlmIChmcm9tTnVsbGFibGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydudWxsYWJsZSddLCBmcm9tTnVsbGFibGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGF0dGVybiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGF0dGVybiddKTtcbiAgICBpZiAoZnJvbVBhdHRlcm4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXR0ZXJuJ10sIGZyb21QYXR0ZXJuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb3BlcnRpZXMnXSk7XG4gICAgaWYgKGZyb21Qcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvcGVydGllcyddLCBmcm9tUHJvcGVydGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9wZXJ0eU9yZGVyaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvcGVydHlPcmRlcmluZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9wZXJ0eU9yZGVyaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvcGVydHlPcmRlcmluZyddLCBmcm9tUHJvcGVydHlPcmRlcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXF1aXJlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVxdWlyZWQnXSk7XG4gICAgaWYgKGZyb21SZXF1aXJlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVpcmVkJ10sIGZyb21SZXF1aXJlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0eXBlJ10pO1xuICAgIGlmIChmcm9tVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R5cGUnXSwgZnJvbVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzY3JpYmJsZUltYWdlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2VnbWVudEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFByZWRpY3Rpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4UHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4UHJlZGljdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtYXhQcmVkaWN0aW9ucyddLCBmcm9tTWF4UHJlZGljdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlkZW5jZVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZGVuY2VUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29uZmlkZW5jZVRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2NvbmZpZGVuY2VUaHJlc2hvbGQnXSwgZnJvbUNvbmZpZGVuY2VUaHJlc2hvbGQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFza0RpbGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrRGlsYXRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXNrRGlsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtYXNrRGlsYXRpb24nXSwgZnJvbU1hc2tEaWxhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaW5hcnlDb2xvclRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpbmFyeUNvbG9yVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJpbmFyeUNvbG9yVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYmluYXJ5Q29sb3JUaHJlc2hvbGQnXSwgZnJvbUJpbmFyeUNvbG9yVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2VnbWVudEltYWdlUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc2VnbWVudEltYWdlU291cmNlVG9WZXJ0ZXgoZnJvbVNvdXJjZSwgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZWdtZW50SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlZ21lbnRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkTWFza3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ByZWRpY3Rpb25zJ10pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkTWFza3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZE1hc2tzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlTWFza0Zyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRNYXNrcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZWdtZW50SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY3JpYmJsZUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2NyaWJibGVJbWFnZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TY3JpYmJsZUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdzY3JpYmJsZSddLCBzY3JpYmJsZUltYWdlVG9WZXJ0ZXgoZnJvbVNjcmliYmxlSW1hZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TcGVha2VyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVha2VyJ10pO1xuICAgIGlmIChmcm9tU3BlYWtlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWFrZXInXSwgZnJvbVNwZWFrZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvTWxkZXYkMShmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlZWNoQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21Wb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10sIHZvaWNlQ29uZmlnVG9NbGRldiQxKGZyb21Wb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJ10sIG11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQxKGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNwZWVjaENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21Wb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10sIHZvaWNlQ29uZmlnVG9WZXJ0ZXgoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3R5bGVSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3R5bGVEZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0eWxlRGVzY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3R5bGVEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0eWxlRGVzY3JpcHRpb24nXSwgZnJvbVN0eWxlRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzdWJqZWN0UmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN1YmplY3RUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdWJqZWN0VHlwZSddKTtcbiAgICBpZiAoZnJvbVN1YmplY3RUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3ViamVjdFR5cGUnXSwgZnJvbVN1YmplY3RUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN1YmplY3REZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N1YmplY3REZXNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdWJqZWN0RGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdWJqZWN0RGVzY3JpcHRpb24nXSwgZnJvbVN1YmplY3REZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRoaW5raW5nQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbmNsdWRlVGhvdWdodHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlVGhvdWdodHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5jbHVkZVRob3VnaHRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5jbHVkZVRob3VnaHRzJ10sIGZyb21JbmNsdWRlVGhvdWdodHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdCdWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0J1ZGdldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0J1ZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQnVkZ2V0J10sIGZyb21UaGlua2luZ0J1ZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRoaW5raW5nQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUluY2x1ZGVUaG91Z2h0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVUaG91Z2h0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmNsdWRlVGhvdWdodHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmNsdWRlVGhvdWdodHMnXSwgZnJvbUluY2x1ZGVUaG91Z2h0cyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0J1ZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQnVkZ2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQnVkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdCdWRnZXQnXSwgZnJvbVRoaW5raW5nQnVkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldihmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsQ29uZmlnJ10sIHJldHJpZXZhbENvbmZpZ1RvTWxkZXYoZnJvbVJldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9WZXJ0ZXgoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbENvbmZpZyddLCByZXRyaWV2YWxDb25maWdUb1ZlcnRleChmcm9tUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQxKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQxKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb29nbGVNYXBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgdXJsQ29udGV4dFRvTWxkZXYkMSgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgY29tcHV0ZXJVc2VUb01sZGV2JDEoZnJvbUNvbXB1dGVyVXNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsJ10sIGZyb21SZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9WZXJ0ZXgoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb1ZlcnRleChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnRlcnByaXNlV2ViU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW50ZXJwcmlzZVdlYlNlYXJjaCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddLCBlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgoZnJvbUVudGVycHJpc2VXZWJTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9WZXJ0ZXgoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCB1cmxDb250ZXh0VG9WZXJ0ZXgoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGNvbXB1dGVyVXNlVG9WZXJ0ZXgoZnJvbUNvbXB1dGVyVXNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxJbmZvRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsSW5mb0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xhYmVscycsXG4gICAgICAgICdnb29nbGUtdmVydGV4LWxsbS10dW5pbmctYmFzZS1tb2RlbC1pZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlZmF1bHRDaGVja3BvaW50SWQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZWZhdWx0Q2hlY2twb2ludElkJ10sIGZyb21EZWZhdWx0Q2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZWZhdWx0Q2hlY2twb2ludElkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVmYXVsdENoZWNrcG9pbnRJZCddLCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU1vZGVsQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlTW9kZWxDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwc2NhbGVJbWFnZUFQSUNvbmZpZ0ludGVybmFsVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VJbnB1dEltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZUlucHV0SW1hZ2UnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZUlucHV0SW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICd1cHNjYWxlQ29uZmlnJywgJ2VuaGFuY2VJbnB1dEltYWdlJ10sIGZyb21FbmhhbmNlSW5wdXRJbWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVByZXNlcnZhdGlvbkZhY3RvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ltYWdlUHJlc2VydmF0aW9uRmFjdG9yJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlUHJlc2VydmF0aW9uRmFjdG9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAndXBzY2FsZUNvbmZpZycsICdpbWFnZVByZXNlcnZhdGlvbkZhY3RvciddLCBmcm9tSW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cHNjYWxlSW1hZ2VBUElQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBzY2FsZUZhY3RvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Vwc2NhbGVGYWN0b3InLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXBzY2FsZUZhY3RvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAndXBzY2FsZUNvbmZpZycsICd1cHNjYWxlRmFjdG9yJ10sIGZyb21VcHNjYWxlRmFjdG9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBzY2FsZUltYWdlQVBJQ29uZmlnSW50ZXJuYWxUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwc2NhbGVJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxDb250ZXh0TWV0YWRhdGFGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVybE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxNZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbVVybE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21VcmxNZXRhZGF0YTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmxNZXRhZGF0YUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybE1ldGFkYXRhJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRNZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVybE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxNZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbVVybE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21VcmxNZXRhZGF0YTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmxNZXRhZGF0YUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxNZXRhZGF0YSddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxDb250ZXh0VG9NbGRldiQxKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dFRvVmVydGV4KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsTWV0YWRhdGFGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJldHJpZXZlZFVybCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmVkVXJsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmVkVXJsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmVkVXJsJ10sIGZyb21SZXRyaWV2ZWRVcmwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsUmV0cmlldmFsU3RhdHVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybFJldHJpZXZhbFN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybFJldHJpZXZhbFN0YXR1cyddLCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsTWV0YWRhdGFGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21SZXRyaWV2ZWRVcmwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZlZFVybCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZlZFVybCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZlZFVybCddLCBmcm9tUmV0cmlldmVkVXJsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybFJldHJpZXZhbFN0YXR1cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VybFJldHJpZXZhbFN0YXR1cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcmxSZXRyaWV2YWxTdGF0dXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxSZXRyaWV2YWxTdGF0dXMnXSwgZnJvbVVybFJldHJpZXZhbFN0YXR1cyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJywgJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlbycsXG4gICAgICAgICdlbmNvZGVkVmlkZW8nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5jb2RpbmcnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYnl0ZXNCYXNlNjRFbmNvZGVkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0dlbmVyYXRpb25NYXNrVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3NlbGYnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2tNb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrTW9kZSddKTtcbiAgICBpZiAoZnJvbU1hc2tNb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza01vZGUnXSwgZnJvbU1hc2tNb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlSW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZVR5cGUnXSwgZnJvbVJlZmVyZW5jZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YVRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnl0ZXNCYXNlNjRFbmNvZGVkJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2b2ljZUNvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWJ1aWx0Vm9pY2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWJ1aWx0Vm9pY2VDb25maWcnXSwgcHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYkMShmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2b2ljZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QcmVidWlsdFZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlYnVpbHRWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlYnVpbHRWb2ljZUNvbmZpZyddLCBwcmVidWlsdFZvaWNlQ29uZmlnVG9WZXJ0ZXgoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBDT05URU5UX1RZUEVfSEVBREVSID0gJ0NvbnRlbnQtVHlwZSc7XG5jb25zdCBTRVJWRVJfVElNRU9VVF9IRUFERVIgPSAnWC1TZXJ2ZXItVGltZW91dCc7XG5jb25zdCBVU0VSX0FHRU5UX0hFQURFUiA9ICdVc2VyLUFnZW50JztcbmNvbnN0IEdPT0dMRV9BUElfQ0xJRU5UX0hFQURFUiA9ICd4LWdvb2ctYXBpLWNsaWVudCc7XG5jb25zdCBTREtfVkVSU0lPTiA9ICcxLjIyLjAnOyAvLyB4LXJlbGVhc2UtcGxlYXNlLXZlcnNpb25cbmNvbnN0IExJQlJBUllfTEFCRUwgPSBgZ29vZ2xlLWdlbmFpLXNkay8ke1NES19WRVJTSU9OfWA7XG5jb25zdCBWRVJURVhfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiA9ICd2MWJldGExJztcbmNvbnN0IEdPT0dMRV9BSV9BUElfREVGQVVMVF9WRVJTSU9OID0gJ3YxYmV0YSc7XG5jb25zdCByZXNwb25zZUxpbmVSRSA9IC9eXFxzKmRhdGE6ICguKikoPzpcXG5cXG58XFxyXFxyfFxcclxcblxcclxcbikvO1xuLyoqXG4gKiBUaGUgQXBpQ2xpZW50IGNsYXNzIGlzIHVzZWQgdG8gc2VuZCByZXF1ZXN0cyB0byB0aGUgR2VtaW5pIEFQSSBvciBWZXJ0ZXggQUlcbiAqIGVuZHBvaW50cy5cbiAqL1xuY2xhc3MgQXBpQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgcHJvamVjdDogb3B0cy5wcm9qZWN0LCBsb2NhdGlvbjogb3B0cy5sb2NhdGlvbiwgYXBpS2V5OiBvcHRzLmFwaUtleSwgdmVydGV4YWk6IG9wdHMudmVydGV4YWkgfSk7XG4gICAgICAgIGNvbnN0IGluaXRIdHRwT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLnZlcnRleGFpKSB7XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYXBpVmVyc2lvbiA9XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jbGllbnRPcHRpb25zLmFwaVZlcnNpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFZFUlRFWF9BSV9BUElfREVGQVVMVF9WRVJTSU9OO1xuICAgICAgICAgICAgaW5pdEh0dHBPcHRpb25zLmJhc2VVcmwgPSB0aGlzLmJhc2VVcmxGcm9tUHJvamVjdExvY2F0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZUF1dGhQYXJhbWV0ZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBHZW1pbmkgQVBJXG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYXBpVmVyc2lvbiA9XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5jbGllbnRPcHRpb25zLmFwaVZlcnNpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IEdPT0dMRV9BSV9BUElfREVGQVVMVF9WRVJTSU9OO1xuICAgICAgICAgICAgaW5pdEh0dHBPcHRpb25zLmJhc2VVcmwgPSBgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vYDtcbiAgICAgICAgfVxuICAgICAgICBpbml0SHR0cE9wdGlvbnMuaGVhZGVycyA9IHRoaXMuZ2V0RGVmYXVsdEhlYWRlcnMoKTtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zID0gaW5pdEh0dHBPcHRpb25zO1xuICAgICAgICBpZiAob3B0cy5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zID0gdGhpcy5wYXRjaEh0dHBPcHRpb25zKGluaXRIdHRwT3B0aW9ucywgb3B0cy5odHRwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgYmFzZSBVUkwgZm9yIFZlcnRleCBBSSBiYXNlZCBvbiBwcm9qZWN0IGFuZCBsb2NhdGlvbi5cbiAgICAgKiBVc2VzIHRoZSBnbG9iYWwgZW5kcG9pbnQgaWYgbG9jYXRpb24gaXMgJ2dsb2JhbCcgb3IgaWYgcHJvamVjdC9sb2NhdGlvblxuICAgICAqIGFyZSBub3Qgc3BlY2lmaWVkIChpbXBseWluZyBBUEkga2V5IHVzYWdlKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJhc2VVcmxGcm9tUHJvamVjdExvY2F0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLnByb2plY3QgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbiAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uICE9PSAnZ2xvYmFsJykge1xuICAgICAgICAgICAgLy8gUmVnaW9uYWwgZW5kcG9pbnRcbiAgICAgICAgICAgIHJldHVybiBgaHR0cHM6Ly8ke3RoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbn0tYWlwbGF0Zm9ybS5nb29nbGVhcGlzLmNvbS9gO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdsb2JhbCBlbmRwb2ludCAoY292ZXJzICdnbG9iYWwnIGxvY2F0aW9uIGFuZCBBUEkga2V5IHVzYWdlKVxuICAgICAgICByZXR1cm4gYGh0dHBzOi8vYWlwbGF0Zm9ybS5nb29nbGVhcGlzLmNvbS9gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIGF1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnMgZm9yIFZlcnRleCBBSS5cbiAgICAgKiBJZiBwcm9qZWN0IGFuZCBsb2NhdGlvbiBhcmUgcHJvdmlkZWQsIEFQSSBrZXkgaXMgY2xlYXJlZC5cbiAgICAgKiBJZiBwcm9qZWN0IGFuZCBsb2NhdGlvbiBhcmUgbm90IHByb3ZpZGVkIChpbXBseWluZyBBUEkga2V5IHVzYWdlKSxcbiAgICAgKiBwcm9qZWN0IGFuZCBsb2NhdGlvbiBhcmUgY2xlYXJlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG5vcm1hbGl6ZUF1dGhQYXJhbWV0ZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLnByb2plY3QgJiYgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAvLyBVc2luZyBwcm9qZWN0L2xvY2F0aW9uIGZvciBhdXRoLCBjbGVhciBwb3RlbnRpYWwgQVBJIGtleVxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmFwaUtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2luZyBBUEkga2V5IGZvciBhdXRoIChvciBubyBhdXRoIHByb3ZpZGVkIHlldCksIGNsZWFyIHByb2plY3QvbG9jYXRpb25cbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLnByb2plY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaXNWZXJ0ZXhBSSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGllbnRPcHRpb25zLnZlcnRleGFpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0UHJvamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0O1xuICAgIH1cbiAgICBnZXRMb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbjtcbiAgICB9XG4gICAgZ2V0QXBpVmVyc2lvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmFwaVZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5hcGlWZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQVBJIHZlcnNpb24gaXMgbm90IHNldC4nKTtcbiAgICB9XG4gICAgZ2V0QmFzZVVybCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmJhc2VVcmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFzZSBVUkwgaXMgbm90IHNldC4nKTtcbiAgICB9XG4gICAgZ2V0UmVxdWVzdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVxdWVzdFVybEludGVybmFsKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyk7XG4gICAgfVxuICAgIGdldEhlYWRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5oZWFkZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGVhZGVycyBhcmUgbm90IHNldC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZXF1ZXN0VXJsSW50ZXJuYWwoaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFodHRwT3B0aW9ucyB8fFxuICAgICAgICAgICAgaHR0cE9wdGlvbnMuYmFzZVVybCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBodHRwT3B0aW9ucy5hcGlWZXJzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSFRUUCBvcHRpb25zIGFyZSBub3QgY29ycmVjdGx5IHNldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlVXJsID0gaHR0cE9wdGlvbnMuYmFzZVVybC5lbmRzV2l0aCgnLycpXG4gICAgICAgICAgICA/IGh0dHBPcHRpb25zLmJhc2VVcmwuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICA6IGh0dHBPcHRpb25zLmJhc2VVcmw7XG4gICAgICAgIGNvbnN0IHVybEVsZW1lbnQgPSBbYmFzZVVybF07XG4gICAgICAgIGlmIChodHRwT3B0aW9ucy5hcGlWZXJzaW9uICYmIGh0dHBPcHRpb25zLmFwaVZlcnNpb24gIT09ICcnKSB7XG4gICAgICAgICAgICB1cmxFbGVtZW50LnB1c2goaHR0cE9wdGlvbnMuYXBpVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybEVsZW1lbnQuam9pbignLycpO1xuICAgIH1cbiAgICBnZXRCYXNlUmVzb3VyY2VQYXRoKCkge1xuICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7dGhpcy5jbGllbnRPcHRpb25zLnByb2plY3R9L2xvY2F0aW9ucy8ke3RoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbn1gO1xuICAgIH1cbiAgICBnZXRBcGlLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5O1xuICAgIH1cbiAgICBnZXRXZWJzb2NrZXRCYXNlVXJsKCkge1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gdGhpcy5nZXRCYXNlVXJsKCk7XG4gICAgICAgIGNvbnN0IHVybFBhcnRzID0gbmV3IFVSTChiYXNlVXJsKTtcbiAgICAgICAgdXJsUGFydHMucHJvdG9jb2wgPSB1cmxQYXJ0cy5wcm90b2NvbCA9PSAnaHR0cDonID8gJ3dzJyA6ICd3c3MnO1xuICAgICAgICByZXR1cm4gdXJsUGFydHMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgc2V0QmFzZVVybCh1cmwpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmJhc2VVcmwgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hUVFAgb3B0aW9ucyBhcmUgbm90IGNvcnJlY3RseSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0VXJsKHBhdGgsIGh0dHBPcHRpb25zLCBwcmVwZW5kUHJvamVjdExvY2F0aW9uKSB7XG4gICAgICAgIGNvbnN0IHVybEVsZW1lbnQgPSBbdGhpcy5nZXRSZXF1ZXN0VXJsSW50ZXJuYWwoaHR0cE9wdGlvbnMpXTtcbiAgICAgICAgaWYgKHByZXBlbmRQcm9qZWN0TG9jYXRpb24pIHtcbiAgICAgICAgICAgIHVybEVsZW1lbnQucHVzaCh0aGlzLmdldEJhc2VSZXNvdXJjZVBhdGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGggIT09ICcnKSB7XG4gICAgICAgICAgICB1cmxFbGVtZW50LnB1c2gocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt1cmxFbGVtZW50LmpvaW4oJy8nKX1gKTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgc2hvdWxkUHJlcGVuZFZlcnRleFByb2plY3RQYXRoKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2xpZW50T3B0aW9ucy52ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0LnBhdGguc3RhcnRzV2l0aCgncHJvamVjdHMvJykpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSB0aGUgcGF0aCBhbHJlYWR5IHN0YXJ0cyB3aXRoXG4gICAgICAgICAgICAvLyBgcHJvamVjdHMvPHByb2plY3Q+L2xvY2F0aW9uLzxsb2NhdGlvbj5gLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0Lmh0dHBNZXRob2QgPT09ICdHRVQnICYmXG4gICAgICAgICAgICByZXF1ZXN0LnBhdGguc3RhcnRzV2l0aCgncHVibGlzaGVycy9nb29nbGUvbW9kZWxzJykpIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIHBhdGhzIGFyZSB1c2VkIGJ5IFZlcnRleCdzIG1vZGVscy5nZXQgYW5kIG1vZGVscy5saXN0XG4gICAgICAgICAgICAvLyBjYWxscy4gRm9yIGJhc2UgbW9kZWxzIFZlcnRleCBkb2VzIG5vdCBhY2NlcHQgYSBwcm9qZWN0L2xvY2F0aW9uXG4gICAgICAgICAgICAvLyBwcmVmaXggKGZvciB0dW5lZCBtb2RlbCB0aGUgcHJlZml4IGlzIHJlcXVpcmVkKS5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIGxldCBwYXRjaGVkSHR0cE9wdGlvbnMgPSB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnM7XG4gICAgICAgIGlmIChyZXF1ZXN0Lmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnMgPSB0aGlzLnBhdGNoSHR0cE9wdGlvbnModGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLCByZXF1ZXN0Lmh0dHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVwZW5kUHJvamVjdExvY2F0aW9uID0gdGhpcy5zaG91bGRQcmVwZW5kVmVydGV4UHJvamVjdFBhdGgocmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuY29uc3RydWN0VXJsKHJlcXVlc3QucGF0aCwgcGF0Y2hlZEh0dHBPcHRpb25zLCBwcmVwZW5kUHJvamVjdExvY2F0aW9uKTtcbiAgICAgICAgaWYgKHJlcXVlc3QucXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlcXVlc3QucXVlcnlQYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVxdWVzdEluaXQgPSB7fTtcbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmJvZHkgJiYgcmVxdWVzdC5ib2R5ICE9PSAne30nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IGJvZHkgc2hvdWxkIGJlIGVtcHR5IGZvciBHRVQgcmVxdWVzdCwgYnV0IGdvdCBub24gZW1wdHkgcmVxdWVzdCBib2R5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0SW5pdC5ib2R5ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RJbml0ID0gYXdhaXQgdGhpcy5pbmNsdWRlRXh0cmFIdHRwT3B0aW9uc1RvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIHBhdGNoZWRIdHRwT3B0aW9ucywgcmVxdWVzdC5hYm9ydFNpZ25hbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnVuYXJ5QXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCByZXF1ZXN0Lmh0dHBNZXRob2QpO1xuICAgIH1cbiAgICBwYXRjaEh0dHBPcHRpb25zKGJhc2VIdHRwT3B0aW9ucywgcmVxdWVzdEh0dHBPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhdGNoZWRIdHRwT3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYmFzZUh0dHBPcHRpb25zKSk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlcXVlc3RIdHRwT3B0aW9ucykpIHtcbiAgICAgICAgICAgIC8vIFJlY29yZHMgY29tcGlsZSB0byBvYmplY3RzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTMjM0NVRTNzA1MzogRWxlbWVudCBpbXBsaWNpdGx5IGhhcyBhbiAnYW55JyB0eXBlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBleHByZXNzaW9uIG9mIHR5cGUgJ3N0cmluZycgY2FuJ3QgYmUgdXNlZCB0byBpbmRleCB0eXBlXG4gICAgICAgICAgICAgICAgLy8gJ0h0dHBPcHRpb25zJy5cbiAgICAgICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGF0Y2hlZEh0dHBPcHRpb25zW2tleV0pLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUzIzNDVUUzcwNTM6IEVsZW1lbnQgaW1wbGljaXRseSBoYXMgYW4gJ2FueScgdHlwZVxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZXhwcmVzc2lvbiBvZiB0eXBlICdzdHJpbmcnIGNhbid0IGJlIHVzZWQgdG8gaW5kZXggdHlwZVxuICAgICAgICAgICAgICAgIC8vICdIdHRwT3B0aW9ucycuXG4gICAgICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0Y2hlZEh0dHBPcHRpb25zO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0U3RyZWFtKHJlcXVlc3QpIHtcbiAgICAgICAgbGV0IHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucztcbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMucGF0Y2hIdHRwT3B0aW9ucyh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMsIHJlcXVlc3QuaHR0cE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXBlbmRQcm9qZWN0TG9jYXRpb24gPSB0aGlzLnNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5jb25zdHJ1Y3RVcmwocmVxdWVzdC5wYXRoLCBwYXRjaGVkSHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pO1xuICAgICAgICBpZiAoIXVybC5zZWFyY2hQYXJhbXMuaGFzKCdhbHQnKSB8fCB1cmwuc2VhcmNoUGFyYW1zLmdldCgnYWx0JykgIT09ICdzc2UnKSB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnYWx0JywgJ3NzZScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXF1ZXN0SW5pdCA9IHt9O1xuICAgICAgICByZXF1ZXN0SW5pdC5ib2R5ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgICByZXF1ZXN0SW5pdCA9IGF3YWl0IHRoaXMuaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0KHJlcXVlc3RJbml0LCBwYXRjaGVkSHR0cE9wdGlvbnMsIHJlcXVlc3QuYWJvcnRTaWduYWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1BcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIHJlcXVlc3QuaHR0cE1ldGhvZCk7XG4gICAgfVxuICAgIGFzeW5jIGluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgaHR0cE9wdGlvbnMsIGFib3J0U2lnbmFsKSB7XG4gICAgICAgIGlmICgoaHR0cE9wdGlvbnMgJiYgaHR0cE9wdGlvbnMudGltZW91dCkgfHwgYWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICAgICAgICBpZiAoaHR0cE9wdGlvbnMudGltZW91dCAmJiAoaHR0cE9wdGlvbnMgPT09IG51bGwgfHwgaHR0cE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0dHBPcHRpb25zLnRpbWVvdXQpID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IGFib3J0Q29udHJvbGxlci5hYm9ydCgpLCBodHRwT3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dEhhbmRsZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGltZW91dEhhbmRsZS51bnJlZiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCB1bnJlZiB0byBwcmV2ZW50IG5vZGVqcyBwcm9jZXNzIGZyb20gaGFuZ2luZywgc2VlXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjdGltZW91dHVucmVmXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRIYW5kbGUudW5yZWYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0SW5pdC5zaWduYWwgPSBzaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGh0dHBPcHRpb25zICYmIGh0dHBPcHRpb25zLmV4dHJhQm9keSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIGh0dHBPcHRpb25zLmV4dHJhQm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEluaXQuaGVhZGVycyA9IGF3YWl0IHRoaXMuZ2V0SGVhZGVyc0ludGVybmFsKGh0dHBPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RJbml0O1xuICAgIH1cbiAgICBhc3luYyB1bmFyeUFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCwgaHR0cE1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGlDYWxsKHVybC50b1N0cmluZygpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RJbml0KSwgeyBtZXRob2Q6IGh0dHBNZXRob2QgfSkpXG4gICAgICAgICAgICAudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSHR0cFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtQXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCBodHRwTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaUNhbGwodXJsLnRvU3RyaW5nKCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdEluaXQpLCB7IG1ldGhvZDogaHR0cE1ldGhvZCB9KSlcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhyb3dFcnJvcklmTm90T0socmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvY2Vzc1N0cmVhbVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogcHJvY2Vzc1N0cmVhbVJlc3BvbnNlXzEoKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSAoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuYm9keSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgICAgICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBib2R5IGlzIGVtcHR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBidWZmZXIgPSAnJztcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSB5aWVsZCBfX2F3YWl0KHJlYWRlci5yZWFkKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wbGV0ZSBKU09OIHNlZ21lbnQgYXQgdGhlIGVuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtTdHJpbmcgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuZCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgY2h1bmsgY29udGFpbnMgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua0pzb24gPSBKU09OLnBhcnNlKGNodW5rU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnZXJyb3InIGluIGNodW5rSnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ySnNvbiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY2h1bmtKc29uWydlcnJvciddKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZXJyb3JKc29uWydzdGF0dXMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gZXJyb3JKc29uWydjb2RlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYGdvdCBzdGF0dXM6ICR7c3RhdHVzfS4gJHtKU09OLnN0cmluZ2lmeShjaHVua0pzb24pfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPj0gNDAwICYmIGNvZGUgPCA2MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXBpRXJyb3IgPSBuZXcgQXBpRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYXBpRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0FwaUVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyICs9IGNodW5rU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBidWZmZXIubWF0Y2gocmVzcG9uc2VMaW5lUkUpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZENodW5rU3RyaW5nID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxSZXNwb25zZSA9IG5ldyBSZXNwb25zZShwcm9jZXNzZWRDaHVua1N0cmluZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KG5ldyBIdHRwUmVzcG9uc2UocGFydGlhbFJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBidWZmZXIubWF0Y2gocmVzcG9uc2VMaW5lUkUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4Y2VwdGlvbiBwYXJzaW5nIHN0cmVhbSBjaHVuayAke3Byb2Nlc3NlZENodW5rU3RyaW5nfS4gJHtlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBhcGlDYWxsKHVybCwgcmVxdWVzdEluaXQpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKHVybCwgcmVxdWVzdEluaXQpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4Y2VwdGlvbiAke2V9IHNlbmRpbmcgcmVxdWVzdGApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RGVmYXVsdEhlYWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgY29uc3QgdmVyc2lvbkhlYWRlclZhbHVlID0gTElCUkFSWV9MQUJFTCArICcgJyArIHRoaXMuY2xpZW50T3B0aW9ucy51c2VyQWdlbnRFeHRyYTtcbiAgICAgICAgaGVhZGVyc1tVU0VSX0FHRU5UX0hFQURFUl0gPSB2ZXJzaW9uSGVhZGVyVmFsdWU7XG4gICAgICAgIGhlYWRlcnNbR09PR0xFX0FQSV9DTElFTlRfSEVBREVSXSA9IHZlcnNpb25IZWFkZXJWYWx1ZTtcbiAgICAgICAgaGVhZGVyc1tDT05URU5UX1RZUEVfSEVBREVSXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIGFzeW5jIGdldEhlYWRlcnNJbnRlcm5hbChodHRwT3B0aW9ucykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgaWYgKGh0dHBPcHRpb25zICYmIGh0dHBPcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGh0dHBPcHRpb25zLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcHBlbmQgYSB0aW1lb3V0IGhlYWRlciBpZiBpdCBpcyBzZXQsIG5vdGUgdGhhdCB0aGUgdGltZW91dCBvcHRpb24gaXNcbiAgICAgICAgICAgIC8vIGluIG1pbGxpc2Vjb25kcyBidXQgdGhlIGhlYWRlciBpcyBpbiBzZWNvbmRzLlxuICAgICAgICAgICAgaWYgKGh0dHBPcHRpb25zLnRpbWVvdXQgJiYgaHR0cE9wdGlvbnMudGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChTRVJWRVJfVElNRU9VVF9IRUFERVIsIFN0cmluZyhNYXRoLmNlaWwoaHR0cE9wdGlvbnMudGltZW91dCAvIDEwMDApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnRPcHRpb25zLmF1dGguYWRkQXV0aEhlYWRlcnMoaGVhZGVycyk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB1c2luZyBHZW1pbmkgQVBJIG9ubHksIHRoaXMgaXMgbm90IHN1cHBvcnRlZFxuICAgICAqIGluIFZlcnRleCBBSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBzdHJpbmcgcGF0aCB0byB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZCBvciBhIEJsb2Igb2JqZWN0LlxuICAgICAqIEBwYXJhbSBjb25maWcgT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlIGBVcGxvYWRGaWxlQ29uZmlnYFxuICAgICAqICAgICBpbnRlcmZhY2UuIEBzZWUge0BsaW5rIFVwbG9hZEZpbGVDb25maWd9XG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGaWxlYCBvYmplY3QuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBjYWxsZWQgb24gYSBWZXJ0ZXggQUkgY2xpZW50LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGBtaW1lVHlwZWAgaXMgbm90IHByb3ZpZGVkIGFuZCBjYW4gbm90IGJlIGluZmVycmVkLFxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZEZpbGUoZmlsZSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZmlsZVRvVXBsb2FkID0ge307XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLm1pbWVUeXBlID0gY29uZmlnLm1pbWVUeXBlO1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLm5hbWUgPSBjb25maWcubmFtZTtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5kaXNwbGF5TmFtZSA9IGNvbmZpZy5kaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZVRvVXBsb2FkLm5hbWUgJiYgIWZpbGVUb1VwbG9hZC5uYW1lLnN0YXJ0c1dpdGgoJ2ZpbGVzLycpKSB7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQubmFtZSA9IGBmaWxlcy8ke2ZpbGVUb1VwbG9hZC5uYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBsb2FkZXIgPSB0aGlzLmNsaWVudE9wdGlvbnMudXBsb2FkZXI7XG4gICAgICAgIGNvbnN0IGZpbGVTdGF0ID0gYXdhaXQgdXBsb2FkZXIuc3RhdChmaWxlKTtcbiAgICAgICAgZmlsZVRvVXBsb2FkLnNpemVCeXRlcyA9IFN0cmluZyhmaWxlU3RhdC5zaXplKTtcbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSAoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubWltZVR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpbGVTdGF0LnR5cGU7XG4gICAgICAgIGlmIChtaW1lVHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1pbWVUeXBlID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGRldGVybWluZSBtaW1lVHlwZS4gUGxlYXNlIHByb3ZpZGUgbWltZVR5cGUgaW4gdGhlIGNvbmZpZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBmaWxlVG9VcGxvYWQubWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgICAgICAgY29uc3QgdXBsb2FkVXJsID0gYXdhaXQgdGhpcy5mZXRjaFVwbG9hZFVybChmaWxlVG9VcGxvYWQsIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB1cGxvYWRlci51cGxvYWQoZmlsZSwgdXBsb2FkVXJsLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB0byB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW1zIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZG93bmxvYWQgcmVxdWVzdCwgc2VlIHtAbGlua1xuICAgICAqIERvd25sb2FkRmlsZVBhcmFtZXRlcnN9XG4gICAgICovXG4gICAgYXN5bmMgZG93bmxvYWRGaWxlKHBhcmFtcykge1xuICAgICAgICBjb25zdCBkb3dubG9hZGVyID0gdGhpcy5jbGllbnRPcHRpb25zLmRvd25sb2FkZXI7XG4gICAgICAgIGF3YWl0IGRvd25sb2FkZXIuZG93bmxvYWQocGFyYW1zLCB0aGlzKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hVcGxvYWRVcmwoZmlsZSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGh0dHBPcHRpb25zID0ge307XG4gICAgICAgIGlmIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGh0dHBPcHRpb25zID0gY29uZmlnLmh0dHBPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgYXBpVmVyc2lvbjogJycsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1Qcm90b2NvbCc6ICdyZXN1bWFibGUnLFxuICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtSGVhZGVyLUNvbnRlbnQtTGVuZ3RoJzogYCR7ZmlsZS5zaXplQnl0ZXN9YCxcbiAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtSGVhZGVyLUNvbnRlbnQtVHlwZSc6IGAke2ZpbGUubWltZVR5cGV9YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgJ2ZpbGUnOiBmaWxlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBodHRwUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgcGF0aDogZm9ybWF0TWFwKCd1cGxvYWQvdjFiZXRhL2ZpbGVzJywgYm9keVsnX3VybCddKSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaHR0cE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWh0dHBSZXNwb25zZSB8fCAhKGh0dHBSZXNwb25zZSA9PT0gbnVsbCB8fCBodHRwUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0dHBSZXNwb25zZS5oZWFkZXJzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gYW4gSHR0cFJlc3BvbnNlIG9yIHRoZSByZXR1cm5lZCBIdHRwUmVzcG9uc2UgZGlkIG5vdCBoYXZlIGhlYWRlcnMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBsb2FkVXJsID0gKF9hID0gaHR0cFJlc3BvbnNlID09PSBudWxsIHx8IGh0dHBSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cFJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsneC1nb29nLXVwbG9hZC11cmwnXTtcbiAgICAgICAgaWYgKHVwbG9hZFVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgdXBsb2FkIHVybC4gU2VydmVyIGRpZCBub3QgcmV0dXJuIHRoZSB4LWdvb2dsZS11cGxvYWQtdXJsIGluIHRoZSBoZWFkZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwbG9hZFVybDtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB0aHJvd0Vycm9ySWZOb3RPSyhyZXNwb25zZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAocmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3BvbnNlIGlzIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgbGV0IGVycm9yQm9keTtcbiAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IHtcbiAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhd2FpdCByZXNwb25zZS50ZXh0KCksXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGVycm9yQm9keSk7XG4gICAgICAgIGlmIChzdGF0dXMgPj0gNDAwICYmIHN0YXR1cyA8IDYwMCkge1xuICAgICAgICAgICAgY29uc3QgYXBpRXJyb3IgPSBuZXcgQXBpRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgYXBpRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWN1cnNpdmVseSB1cGRhdGVzIHRoZSBgcmVxdWVzdEluaXQuYm9keWAgd2l0aCB2YWx1ZXMgZnJvbSBhbiBgZXh0cmFCb2R5YCBvYmplY3QuXG4gKlxuICogSWYgYHJlcXVlc3RJbml0LmJvZHlgIGlzIGEgc3RyaW5nLCBpdCdzIGFzc3VtZWQgdG8gYmUgSlNPTiBhbmQgd2lsbCBiZSBwYXJzZWQuXG4gKiBUaGUgYGV4dHJhQm9keWAgaXMgdGhlbiBkZWVwbHkgbWVyZ2VkIGludG8gdGhpcyBwYXJzZWQgb2JqZWN0LlxuICogSWYgYHJlcXVlc3RJbml0LmJvZHlgIGlzIGEgQmxvYiwgYGV4dHJhQm9keWAgd2lsbCBiZSBpZ25vcmVkLCBhbmQgYSB3YXJuaW5nIGxvZ2dlZCxcbiAqIGFzIG1lcmdpbmcgc3RydWN0dXJlZCBkYXRhIGludG8gYW4gb3BhcXVlIEJsb2IgaXMgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gZG9lcyBub3QgZW5mb3JjZSB0aGF0IHVwZGF0ZWQgdmFsdWVzIGZyb20gYGV4dHJhQm9keWAgaGF2ZSB0aGVcbiAqIHNhbWUgdHlwZSBhcyBleGlzdGluZyB2YWx1ZXMgaW4gYHJlcXVlc3RJbml0LmJvZHlgLiBUeXBlIG1pc21hdGNoZXMgZHVyaW5nXG4gKiB0aGUgbWVyZ2Ugd2lsbCByZXN1bHQgaW4gYSB3YXJuaW5nLCBidXQgdGhlIHZhbHVlIGZyb20gYGV4dHJhQm9keWAgd2lsbCBvdmVyd3JpdGVcbiAqIHRoZSBvcmlnaW5hbC4gYGV4dHJhQm9keWAgdXNlcnMgYXJlIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyBgZXh0cmFCb2R5YCBoYXMgdGhlIGNvcnJlY3Qgc3RydWN0dXJlLlxuICpcbiAqIEBwYXJhbSByZXF1ZXN0SW5pdCBUaGUgUmVxdWVzdEluaXQgb2JqZWN0IHdob3NlIGJvZHkgd2lsbCBiZSB1cGRhdGVkLlxuICogQHBhcmFtIGV4dHJhQm9keSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdXBkYXRlcyB0byBiZSBtZXJnZWQgaW50byBgcmVxdWVzdEluaXQuYm9keWAuXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0KHJlcXVlc3RJbml0LCBleHRyYUJvZHkpIHtcbiAgICBpZiAoIWV4dHJhQm9keSB8fCBPYmplY3Qua2V5cyhleHRyYUJvZHkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0SW5pdC5ib2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2luY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0OiBleHRyYUJvZHkgcHJvdmlkZWQgYnV0IGN1cnJlbnQgcmVxdWVzdCBib2R5IGlzIGEgQmxvYi4gZXh0cmFCb2R5IHdpbGwgYmUgaWdub3JlZCBhcyBtZXJnaW5nIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIEJsb2IgYm9kaWVzLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjdXJyZW50Qm9keU9iamVjdCA9IHt9O1xuICAgIC8vIElmIGFkZGluZyBuZXcgdHlwZSB0byBIdHRwUmVxdWVzdC5ib2R5LCBwbGVhc2UgY2hlY2sgdGhlIGNvZGUgYmVsb3cgdG9cbiAgICAvLyBzZWUgaWYgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGxvZ2ljLlxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEluaXQuYm9keSA9PT0gJ3N0cmluZycgJiYgcmVxdWVzdEluaXQuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRCb2R5ID0gSlNPTi5wYXJzZShyZXF1ZXN0SW5pdC5ib2R5KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2VkQm9keSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICBwYXJzZWRCb2R5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkocGFyc2VkQm9keSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qm9keU9iamVjdCA9IHBhcnNlZEJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2luY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0OiBPcmlnaW5hbCByZXF1ZXN0IGJvZHkgaXMgdmFsaWQgSlNPTiBidXQgbm90IGEgbm9uLWFycmF5IG9iamVjdC4gU2tpcCBhcHBseWluZyBleHRyYUJvZHkgdG8gdGhlIHJlcXVlc3QgYm9keS4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiAgZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2luY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0OiBPcmlnaW5hbCByZXF1ZXN0IGJvZHkgaXMgbm90IHZhbGlkIEpTT04uIFNraXAgYXBwbHlpbmcgZXh0cmFCb2R5IHRvIHRoZSByZXF1ZXN0IGJvZHkuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVlcE1lcmdlKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gb3V0cHV0W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzb3VyY2VWYWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoc291cmNlVmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRWYWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodGFyZ2V0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gZGVlcE1lcmdlKHRhcmdldFZhbHVlLCBzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0VmFsdWUgIT09IHR5cGVvZiBzb3VyY2VWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBpbmNsdWRlRXh0cmFCb2R5VG9SZXF1ZXN0SW5pdDpkZWVwTWVyZ2U6IFR5cGUgbWlzbWF0Y2ggZm9yIGtleSBcIiR7a2V5fVwiLiBPcmlnaW5hbCB0eXBlOiAke3R5cGVvZiB0YXJnZXRWYWx1ZX0sIE5ldyB0eXBlOiAke3R5cGVvZiBzb3VyY2VWYWx1ZX0uIE92ZXJ3cml0aW5nLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gc291cmNlVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZEJvZHkgPSBkZWVwTWVyZ2UoY3VycmVudEJvZHlPYmplY3QsIGV4dHJhQm9keSk7XG4gICAgcmVxdWVzdEluaXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KG1lcmdlZEJvZHkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBUT0RPOiBiLzQxNjA0MTIyOSAtIERldGVybWluZSBob3cgdG8gcmV0cmlldmUgdGhlIE1DUCBwYWNrYWdlIHZlcnNpb24uXG5jb25zdCBNQ1BfTEFCRUwgPSAnbWNwX3VzZWQvdW5rbm93bic7XG4vLyBXaGV0aGVyIE1DUCB0b29sIHVzYWdlIGlzIGRldGVjdGVkIGZyb20gbWNwVG9Ub29sLiBUaGlzIGlzIHVzZWQgZm9yXG4vLyB0ZWxlbWV0cnkuXG5sZXQgaGFzTWNwVG9vbFVzYWdlRnJvbU1jcFRvVG9vbCA9IGZhbHNlO1xuLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGxpc3Qgb2YgdG9vbHMgY29udGFpbnMgYW55IE1DUCB0b29scy5cbmZ1bmN0aW9uIGhhc01jcFRvb2xVc2FnZSh0b29scykge1xuICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29scykge1xuICAgICAgICBpZiAoaXNNY3BDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG9vbCA9PT0gJ29iamVjdCcgJiYgJ2lucHV0U2NoZW1hJyBpbiB0b29sKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzTWNwVG9vbFVzYWdlRnJvbU1jcFRvVG9vbDtcbn1cbi8vIFNldHMgdGhlIE1DUCB2ZXJzaW9uIGxhYmVsIGluIHRoZSBHb29nbGUgQVBJIGNsaWVudCBoZWFkZXIuXG5mdW5jdGlvbiBzZXRNY3BVc2FnZUhlYWRlcihoZWFkZXJzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGV4aXN0aW5nSGVhZGVyID0gKF9hID0gaGVhZGVyc1tHT09HTEVfQVBJX0NMSUVOVF9IRUFERVJdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICBoZWFkZXJzW0dPT0dMRV9BUElfQ0xJRU5UX0hFQURFUl0gPSAoZXhpc3RpbmdIZWFkZXIgKyBgICR7TUNQX0xBQkVMfWApLnRyaW1TdGFydCgpO1xufVxuLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBNQ1AgQ2FsbGFibGVUb29sLCBvdGhlcndpc2UgZmFsc2UuXG5mdW5jdGlvbiBpc01jcENhbGxhYmxlVG9vbChvYmplY3QpIHtcbiAgICByZXR1cm4gKG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBvYmplY3QgaW5zdGFuY2VvZiBNY3BDYWxsYWJsZVRvb2wpO1xufVxuLy8gTGlzdCBhbGwgdG9vbHMgZnJvbSB0aGUgTUNQIGNsaWVudC5cbmZ1bmN0aW9uIGxpc3RBbGxUb29scyhtY3BDbGllbnQsIG1heFRvb2xzID0gMTAwKSB7XG4gICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogbGlzdEFsbFRvb2xzXzEoKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBudW1Ub29scyA9IDA7XG4gICAgICAgIHdoaWxlIChudW1Ub29scyA8IG1heFRvb2xzKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0geWllbGQgX19hd2FpdChtY3BDbGllbnQubGlzdFRvb2xzKHsgY3Vyc29yIH0pKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiB0LnRvb2xzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh0b29sKTtcbiAgICAgICAgICAgICAgICBudW1Ub29scysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0Lm5leHRDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnNvciA9IHQubmV4dEN1cnNvcjtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBNY3BDYWxsYWJsZVRvb2wgY2FuIGJlIHVzZWQgZm9yIG1vZGVsIGluZmVyZW5jZSBhbmQgaW52b2tpbmcgTUNQIGNsaWVudHMgd2l0aFxuICogZ2l2ZW4gZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpbiBmdXR1cmVcbiAqIHZlcnNpb25zLlxuICovXG5jbGFzcyBNY3BDYWxsYWJsZVRvb2wge1xuICAgIGNvbnN0cnVjdG9yKG1jcENsaWVudHMgPSBbXSwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMubWNwVG9vbHMgPSBbXTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCA9IHt9O1xuICAgICAgICB0aGlzLm1jcENsaWVudHMgPSBtY3BDbGllbnRzO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1jcENhbGxhYmxlVG9vbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKG1jcENsaWVudHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IE1jcENhbGxhYmxlVG9vbChtY3BDbGllbnRzLCBjb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGZ1bmN0aW9uIG5hbWVzIGFyZSBub3QgZHVwbGljYXRlIGFuZCBpbml0aWFsaXplIHRoZSBmdW5jdGlvblxuICAgICAqIG5hbWUgdG8gTUNQIGNsaWVudCBtYXBwaW5nLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBNQ1AgdG9vbHMgZnJvbSB0aGUgTUNQIGNsaWVudHMgaGF2ZSBkdXBsaWNhdGUgdG9vbFxuICAgICAqICAgICBuYW1lcy5cbiAgICAgKi9cbiAgICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICBpZiAodGhpcy5tY3BUb29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25NYXAgPSB7fTtcbiAgICAgICAgY29uc3QgbWNwVG9vbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtY3BDbGllbnQgb2YgdGhpcy5tY3BDbGllbnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgX2UgPSAoZV8xID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKGxpc3RBbGxUb29scyhtY3BDbGllbnQpKSksIF9mOyBfZiA9IGF3YWl0IF9lLm5leHQoKSwgX2EgPSBfZi5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtY3BUb29sID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIG1jcFRvb2xzLnB1c2gobWNwVG9vbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1jcFRvb2xOYW1lID0gbWNwVG9vbC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25NYXBbbWNwVG9vbE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBmdW5jdGlvbiBuYW1lICR7bWNwVG9vbE5hbWV9IGZvdW5kIGluIE1DUCB0b29scy4gUGxlYXNlIGVuc3VyZSBmdW5jdGlvbiBuYW1lcyBhcmUgdW5pcXVlLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTWFwW21jcFRvb2xOYW1lXSA9IG1jcENsaWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gX2UucmV0dXJuKSkgYXdhaXQgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1jcFRvb2xzID0gbWNwVG9vbHM7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnQgPSBmdW5jdGlvbk1hcDtcbiAgICB9XG4gICAgYXN5bmMgdG9vbCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHJldHVybiBtY3BUb29sc1RvR2VtaW5pVG9vbCh0aGlzLm1jcFRvb2xzLCB0aGlzLmNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGxUb29sKGZ1bmN0aW9uQ2FsbHMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmdW5jdGlvbkNhbGwgb2YgZnVuY3Rpb25DYWxscykge1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbC5uYW1lIGluIHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtY3BDbGllbnQgPSB0aGlzLmZ1bmN0aW9uTmFtZVRvTWNwQ2xpZW50W2Z1bmN0aW9uQ2FsbC5uYW1lXTtcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYi80MjQyMzg2NTQgLSBBZGQgc3VwcG9ydCBmb3IgZmluZXIgZ3JhaW5lZCB0aW1lb3V0IGNvbnRyb2wuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLmNvbmZpZy50aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsVG9vbFJlc3BvbnNlID0gYXdhaXQgbWNwQ2xpZW50LmNhbGxUb29sKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25DYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogZnVuY3Rpb25DYWxsLmFyZ3MsXG4gICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSByZXN1bHQgc2NoZW1hIHRvIHVuZGVmaW5lZCB0byBhbGxvdyBNQ1AgdG8gcmVseSBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHNjaGVtYS5cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxSZXNwb25zZVBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbkNhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBjYWxsVG9vbFJlc3BvbnNlLmlzRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgZXJyb3I6IGNhbGxUb29sUmVzcG9uc2UgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2FsbFRvb2xSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxsUmVzcG9uc2VQYXJ0cztcbiAgICB9XG59XG5mdW5jdGlvbiBpc01jcENsaWVudChjbGllbnQpIHtcbiAgICByZXR1cm4gKGNsaWVudCAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgY2xpZW50ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnbGlzdFRvb2xzJyBpbiBjbGllbnQgJiZcbiAgICAgICAgdHlwZW9mIGNsaWVudC5saXN0VG9vbHMgPT09ICdmdW5jdGlvbicpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgTWNwQ2FsbGFibGVUb29sIGZyb20gTUNQIGNsaWVudHMgYW5kIGFuIG9wdGlvbmFsIGNvbmZpZy5cbiAqXG4gKiBUaGUgY2FsbGFibGUgdG9vbCBjYW4gaW52b2tlIHRoZSBNQ1AgY2xpZW50cyB3aXRoIGdpdmVuIGZ1bmN0aW9uIGNhbGxcbiAqIGFyZ3VtZW50cy4gKG9mdGVuIGZvciBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZykuXG4gKiBVc2UgdGhlIGNvbmZpZyB0byBtb2RpZnkgdG9vbCBwYXJhbWV0ZXJzIHN1Y2ggYXMgYmVoYXZpb3IuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpbiBmdXR1cmVcbiAqIHZlcnNpb25zLlxuICovXG5mdW5jdGlvbiBtY3BUb1Rvb2woLi4uYXJncykge1xuICAgIC8vIFNldCBNQ1AgdXNhZ2UgZm9yIHRlbGVtZXRyeS5cbiAgICBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sID0gdHJ1ZTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBNQ1AgY2xpZW50cyBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBjb25zdCBtYXliZUNvbmZpZyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICBpZiAoaXNNY3BDbGllbnQobWF5YmVDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBNY3BDYWxsYWJsZVRvb2wuY3JlYXRlKGFyZ3MsIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIE1jcENhbGxhYmxlVG9vbC5jcmVhdGUoYXJncy5zbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpLCBtYXliZUNvbmZpZyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogSGFuZGxlcyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHBhcnNpbmcgaW5jb21pbmcgbWVzc2FnZXMsIHRyYW5zZm9ybWluZyB0aGVtXG4gKiBpbnRvIExpdmVNdXNpY1NlcnZlck1lc3NhZ2UsIGFuZCB0aGVuIGNhbGxpbmcgdGhlIG9ubWVzc2FnZSBjYWxsYmFjay5cbiAqIE5vdGUgdGhhdCB0aGUgZmlyc3QgbWVzc2FnZSB3aGljaCBpcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgaXMgYVxuICogc2V0dXBDb21wbGV0ZSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBhcGlDbGllbnQgVGhlIEFwaUNsaWVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvbm1lc3NhZ2UgVGhlIHVzZXItcHJvdmlkZWQgb25tZXNzYWdlIGNhbGxiYWNrIChpZiBhbnkpLlxuICogQHBhcmFtIGV2ZW50IFRoZSBNZXNzYWdlRXZlbnQgZnJvbSB0aGUgV2ViU29ja2V0LlxuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVXZWJTb2NrZXRNZXNzYWdlJDEoYXBpQ2xpZW50LCBvbm1lc3NhZ2UsIGV2ZW50KSB7XG4gICAgY29uc3Qgc2VydmVyTWVzc2FnZSA9IG5ldyBMaXZlTXVzaWNTZXJ2ZXJNZXNzYWdlKCk7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKGV2ZW50LmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGF3YWl0IGV2ZW50LmRhdGEudGV4dCgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGxpdmVNdXNpY1NlcnZlck1lc3NhZ2VGcm9tTWxkZXYoZGF0YSk7XG4gICAgT2JqZWN0LmFzc2lnbihzZXJ2ZXJNZXNzYWdlLCByZXNwb25zZSk7XG4gICAgb25tZXNzYWdlKHNlcnZlck1lc3NhZ2UpO1xufVxuLyoqXG4gICBMaXZlTXVzaWMgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSBjb25maWd1cmF0aW9uIGZvciBsaXZlIG11c2ljXG4gICBnZW5lcmF0aW9uIHZpYSBMeXJpYSBMaXZlIG1vZGVscy5cblxuICAgQGV4cGVyaW1lbnRhbFxuICAqL1xuY2xhc3MgTGl2ZU11c2ljIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIGF1dGgsIHdlYlNvY2tldEZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMud2ViU29ja2V0RmFjdG9yeSA9IHdlYlNvY2tldEZhY3Rvcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgIEVzdGFibGlzaGVzIGEgY29ubmVjdGlvbiB0byB0aGUgc3BlY2lmaWVkIG1vZGVsIGFuZCByZXR1cm5zIGFcbiAgICAgICBMaXZlTXVzaWNTZXNzaW9uIG9iamVjdCByZXByZXNlbnRpbmcgdGhhdCBjb25uZWN0aW9uLlxuICBcbiAgICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgIEByZW1hcmtzXG4gIFxuICAgICAgIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbiB0byB0aGUgbW9kZWwuXG4gICAgICAgQHJldHVybiBBIGxpdmUgc2Vzc2lvbi5cbiAgXG4gICAgICAgQGV4YW1wbGVcbiAgICAgICBgYGB0c1xuICAgICAgIGxldCBtb2RlbCA9ICdtb2RlbHMvbHlyaWEtcmVhbHRpbWUtZXhwJztcbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5tdXNpYy5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICBvbm1lc3NhZ2U6IChlOiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXI6ICVzXFxuJywgZGVidWcoZS5kYXRhKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uZXJyb3I6IChlOiBFcnJvckV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIG9jY3VycmVkOiAlc1xcbicsIGRlYnVnKGUuZXJyb3IpKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25jbG9zZTogKGU6IENsb3NlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGlvbiBjbG9zZWQuJyk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICB9LFxuICAgICAgIH0pO1xuICAgICAgIGBgYFxuICAgICAgKi9cbiAgICBhc3luYyBjb25uZWN0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpdmUgbXVzaWMgaXMgbm90IHN1cHBvcnRlZCBmb3IgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybignTGl2ZSBtdXNpYyBnZW5lcmF0aW9uIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuJyk7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldEJhc2VVcmwgPSB0aGlzLmFwaUNsaWVudC5nZXRXZWJzb2NrZXRCYXNlVXJsKCk7XG4gICAgICAgIGNvbnN0IGFwaVZlcnNpb24gPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlWZXJzaW9uKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBtYXBUb0hlYWRlcnMkMSh0aGlzLmFwaUNsaWVudC5nZXREZWZhdWx0SGVhZGVycygpKTtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpS2V5KCk7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3dlYnNvY2tldEJhc2VVcmx9L3dzL2dvb2dsZS5haS5nZW5lcmF0aXZlbGFuZ3VhZ2UuJHthcGlWZXJzaW9ufS5HZW5lcmF0aXZlU2VydmljZS5CaWRpR2VuZXJhdGVNdXNpYz9rZXk9JHthcGlLZXl9YDtcbiAgICAgICAgbGV0IG9ub3BlblJlc29sdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIGNvbnN0IG9ub3BlblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgb25vcGVuUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBwYXJhbXMuY2FsbGJhY2tzO1xuICAgICAgICBjb25zdCBvbm9wZW5Bd2FpdGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlKHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9ub3Blbjogb25vcGVuQXdhaXRlZENhbGxiYWNrLFxuICAgICAgICAgICAgb25tZXNzYWdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2b2lkIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UkMShhcGlDbGllbnQsIGNhbGxiYWNrcy5vbm1lc3NhZ2UsIGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmVycm9yOiAoX2EgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25lcnJvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmNsb3NlOiAoX2IgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25jbG9zZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLndlYlNvY2tldEZhY3RvcnkuY3JlYXRlKHVybCwgaGVhZGVyc1RvTWFwJDEoaGVhZGVycyksIHdlYnNvY2tldENhbGxiYWNrcyk7XG4gICAgICAgIGNvbm4uY29ubmVjdCgpO1xuICAgICAgICAvLyBXYWl0IGZvciB0aGUgd2Vic29ja2V0IHRvIG9wZW4gYmVmb3JlIHNlbmRpbmcgcmVxdWVzdHMuXG4gICAgICAgIGF3YWl0IG9ub3BlblByb21pc2U7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdE1vZGVsKHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMubW9kZWwpO1xuICAgICAgICBjb25zdCBzZXR1cCA9IGxpdmVNdXNpY0NsaWVudFNldHVwVG9NbGRldih7XG4gICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSBsaXZlTXVzaWNDbGllbnRNZXNzYWdlVG9NbGRldih7IHNldHVwIH0pO1xuICAgICAgICBjb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgICAgICByZXR1cm4gbmV3IExpdmVNdXNpY1Nlc3Npb24oY29ubiwgdGhpcy5hcGlDbGllbnQpO1xuICAgIH1cbn1cbi8qKlxuICAgUmVwcmVzZW50cyBhIGNvbm5lY3Rpb24gdG8gdGhlIEFQSS5cblxuICAgQGV4cGVyaW1lbnRhbFxuICAqL1xuY2xhc3MgTGl2ZU11c2ljU2Vzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoY29ubiwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHRoaXMuY29ubiA9IGNvbm47XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNldHMgaW5wdXRzIHRvIHN0ZWVyIG11c2ljIGdlbmVyYXRpb24uIFVwZGF0ZXMgdGhlIHNlc3Npb24ncyBjdXJyZW50XG4gICAgICB3ZWlnaHRlZCBwcm9tcHRzLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBvbmUgcHJvcGVydHksIGB3ZWlnaHRlZFByb21wdHNgLlxuICBcbiAgICAgICAgLSBgd2VpZ2h0ZWRQcm9tcHRzYCB0byBzZW5kIHRvIHRoZSBtb2RlbDsgd2VpZ2h0cyBhcmUgbm9ybWFsaXplZCB0b1xuICAgICAgICAgIHN1bSB0byAxLjAuXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIHNldFdlaWdodGVkUHJvbXB0cyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMud2VpZ2h0ZWRQcm9tcHRzIHx8XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMud2VpZ2h0ZWRQcm9tcHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2VpZ2h0ZWQgcHJvbXB0cyBtdXN0IGJlIHNldCBhbmQgY29udGFpbiBhdCBsZWFzdCBvbmUgZW50cnkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2V0V2VpZ2h0ZWRQcm9tcHRzUGFyYW1ldGVycyA9IGxpdmVNdXNpY1NldFdlaWdodGVkUHJvbXB0c1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGNsaWVudENvbnRlbnQgPSBsaXZlTXVzaWNDbGllbnRDb250ZW50VG9NbGRldihzZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoeyBjbGllbnRDb250ZW50IH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZXRzIGEgY29uZmlndXJhdGlvbiB0byB0aGUgbW9kZWwuIFVwZGF0ZXMgdGhlIHNlc3Npb24ncyBjdXJyZW50XG4gICAgICBtdXNpYyBnZW5lcmF0aW9uIGNvbmZpZy5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgb25lIHByb3BlcnR5LCBgbXVzaWNHZW5lcmF0aW9uQ29uZmlnYC5cbiAgXG4gICAgICAgIC0gYG11c2ljR2VuZXJhdGlvbkNvbmZpZ2AgdG8gc2V0IGluIHRoZSBtb2RlbC4gUGFzc2luZyBhbiBlbXB0eSBvclxuICAgICAgdW5kZWZpbmVkIGNvbmZpZyB0byB0aGUgbW9kZWwgd2lsbCByZXNldCB0aGUgY29uZmlnIHRvIGRlZmF1bHRzLlxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBhc3luYyBzZXRNdXNpY0dlbmVyYXRpb25Db25maWcocGFyYW1zKSB7XG4gICAgICAgIGlmICghcGFyYW1zLm11c2ljR2VuZXJhdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgcGFyYW1zLm11c2ljR2VuZXJhdGlvbkNvbmZpZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNldENvbmZpZ1BhcmFtZXRlcnMgPSBsaXZlTXVzaWNTZXRDb25maWdQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0gbGl2ZU11c2ljQ2xpZW50TWVzc2FnZVRvTWxkZXYoc2V0Q29uZmlnUGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2VuZFBsYXliYWNrQ29udHJvbChwbGF5YmFja0NvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IGxpdmVNdXNpY0NsaWVudE1lc3NhZ2VUb01sZGV2KHtcbiAgICAgICAgICAgIHBsYXliYWNrQ29udHJvbCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIG11c2ljIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlBMQVkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZW1wb3JhcmlseSBoYWx0IHRoZSBtdXNpYyBzdHJlYW0uIFVzZSBgcGxheWAgdG8gcmVzdW1lIGZyb20gdGhlIGN1cnJlbnRcbiAgICAgKiBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5QQVVTRSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIG11c2ljIHN0cmVhbSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBSZXRhaW5zIHRoZSBjdXJyZW50IHByb21wdHNcbiAgICAgKiBhbmQgY29uZmlnLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc2VuZFBsYXliYWNrQ29udHJvbChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wuU1RPUCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgY29udGV4dCBvZiB0aGUgbXVzaWMgZ2VuZXJhdGlvbiB3aXRob3V0IHN0b3BwaW5nIGl0LlxuICAgICAqIFJldGFpbnMgdGhlIGN1cnJlbnQgcHJvbXB0cyBhbmQgY29uZmlnLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHJlc2V0Q29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5SRVNFVF9DT05URVhUKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgVGVybWluYXRlcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgfVxufVxuLy8gQ29udmVydHMgYW4gaGVhZGVycyBvYmplY3QgdG8gYSBcIm1hcFwiIG9iamVjdCBhcyBleHBlY3RlZCBieSB0aGUgV2ViU29ja2V0XG4vLyBjb25zdHJ1Y3Rvci4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGggaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzXG4vLyB3aGlsZSB0aGUgV2ViU29ja2V0IGNvbnN0cnVjdG9yIHRha2VzIGEgbWFwLlxuZnVuY3Rpb24gaGVhZGVyc1RvTWFwJDEoaGVhZGVycykge1xuICAgIGNvbnN0IGhlYWRlck1hcCA9IHt9O1xuICAgIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBoZWFkZXJNYXBba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJNYXA7XG59XG4vLyBDb252ZXJ0cyBhIFwibWFwXCIgb2JqZWN0IHRvIGEgaGVhZGVycyBvYmplY3QuIFdlIHVzZSB0aGlzIGFzIHRoZSBBdXRoXG4vLyBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHMgd2hpbGUgdGhlIEFQSSBjbGllbnQgZGVmYXVsdCBoZWFkZXJzXG4vLyByZXR1cm5zIGEgbWFwLlxuZnVuY3Rpb24gbWFwVG9IZWFkZXJzJDEobWFwKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkge1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IEZVTkNUSU9OX1JFU1BPTlNFX1JFUVVJUkVTX0lEID0gJ0Z1bmN0aW9uUmVzcG9uc2UgcmVxdWVzdCBtdXN0IGhhdmUgYW4gYGlkYCBmaWVsZCBmcm9tIHRoZSByZXNwb25zZSBvZiBhIFRvb2xDYWxsLkZ1bmN0aW9uYWxDYWxscyBpbiBHb29nbGUgQUkuJztcbi8qKlxuICogSGFuZGxlcyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHBhcnNpbmcgaW5jb21pbmcgbWVzc2FnZXMsIHRyYW5zZm9ybWluZyB0aGVtXG4gKiBpbnRvIExpdmVTZXJ2ZXJNZXNzYWdlcywgYW5kIHRoZW4gY2FsbGluZyB0aGUgb25tZXNzYWdlIGNhbGxiYWNrLiBOb3RlIHRoYXRcbiAqIHRoZSBmaXJzdCBtZXNzYWdlIHdoaWNoIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBhIHNldHVwQ29tcGxldGVcbiAqIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGFwaUNsaWVudCBUaGUgQXBpQ2xpZW50IGluc3RhbmNlLlxuICogQHBhcmFtIG9ubWVzc2FnZSBUaGUgdXNlci1wcm92aWRlZCBvbm1lc3NhZ2UgY2FsbGJhY2sgKGlmIGFueSkuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIE1lc3NhZ2VFdmVudCBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UoYXBpQ2xpZW50LCBvbm1lc3NhZ2UsIGV2ZW50KSB7XG4gICAgY29uc3Qgc2VydmVyTWVzc2FnZSA9IG5ldyBMaXZlU2VydmVyTWVzc2FnZSgpO1xuICAgIGxldCBqc29uRGF0YTtcbiAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAganNvbkRhdGEgPSBhd2FpdCBldmVudC5kYXRhLnRleHQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGpzb25EYXRhID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGV2ZW50LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAganNvbkRhdGEgPSBldmVudC5kYXRhO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uRGF0YSk7XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGxpdmVTZXJ2ZXJNZXNzYWdlRnJvbVZlcnRleChkYXRhKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXJ2ZXJNZXNzYWdlLCByZXNwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBsaXZlU2VydmVyTWVzc2FnZUZyb21NbGRldihkYXRhKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXJ2ZXJNZXNzYWdlLCByZXNwKTtcbiAgICB9XG4gICAgb25tZXNzYWdlKHNlcnZlck1lc3NhZ2UpO1xufVxuLyoqXG4gICBMaXZlIGNsYXNzIGVuY2Fwc3VsYXRlcyB0aGUgY29uZmlndXJhdGlvbiBmb3IgbGl2ZSBpbnRlcmFjdGlvbiB3aXRoIHRoZVxuICAgR2VuZXJhdGl2ZSBMYW5ndWFnZSBBUEkuIEl0IGVtYmVkcyBBcGlDbGllbnQgZm9yIGdlbmVyYWwgQVBJIHNldHRpbmdzLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBMaXZlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIGF1dGgsIHdlYlNvY2tldEZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMud2ViU29ja2V0RmFjdG9yeSA9IHdlYlNvY2tldEZhY3Rvcnk7XG4gICAgICAgIHRoaXMubXVzaWMgPSBuZXcgTGl2ZU11c2ljKHRoaXMuYXBpQ2xpZW50LCB0aGlzLmF1dGgsIHRoaXMud2ViU29ja2V0RmFjdG9yeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgIEVzdGFibGlzaGVzIGEgY29ubmVjdGlvbiB0byB0aGUgc3BlY2lmaWVkIG1vZGVsIHdpdGggdGhlIGdpdmVuXG4gICAgICAgY29uZmlndXJhdGlvbiBhbmQgcmV0dXJucyBhIFNlc3Npb24gb2JqZWN0IHJlcHJlc2VudGluZyB0aGF0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWwgQnVpbHQtaW4gTUNQIHN1cHBvcnQgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUsIG1heSBjaGFuZ2UgaW5cbiAgICAgICBmdXR1cmUgdmVyc2lvbnMuXG4gIFxuICAgICAgIEByZW1hcmtzXG4gIFxuICAgICAgIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbiB0byB0aGUgbW9kZWwuXG4gICAgICAgQHJldHVybiBBIGxpdmUgc2Vzc2lvbi5cbiAgXG4gICAgICAgQGV4YW1wbGVcbiAgICAgICBgYGB0c1xuICAgICAgIGxldCBtb2RlbDogc3RyaW5nO1xuICAgICAgIGlmIChHT09HTEVfR0VOQUlfVVNFX1ZFUlRFWEFJKSB7XG4gICAgICAgICBtb2RlbCA9ICdnZW1pbmktMi4wLWZsYXNoLWxpdmUtcHJldmlldy0wNC0wOSc7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS1saXZlLTIuNS1mbGFzaC1wcmV2aWV3JztcbiAgICAgICB9XG4gICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGFpLmxpdmUuY29ubmVjdCh7XG4gICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dLFxuICAgICAgICAgfSxcbiAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICBvbm9wZW46ICgpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGVkIHRvIHRoZSBzb2NrZXQuJyk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9ubWVzc2FnZTogKGU6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlcjogJXNcXG4nLCBkZWJ1ZyhlLmRhdGEpKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25lcnJvcjogKGU6IEVycm9yRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3Igb2NjdXJyZWQ6ICVzXFxuJywgZGVidWcoZS5lcnJvcikpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmNsb3NlOiAoZTogQ2xvc2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW9uIGNsb3NlZC4nKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgIH0sXG4gICAgICAgfSk7XG4gICAgICAgYGBgXG4gICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAvLyBUT0RPOiBiLzQwNDk0Njc0NiAtIFN1cHBvcnQgcGVyIHJlcXVlc3QgSFRUUCBvcHRpb25zLlxuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJiBwYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBMaXZlIG1vZHVsZSBkb2VzIG5vdCBzdXBwb3J0IGh0dHBPcHRpb25zIGF0IHJlcXVlc3QtbGV2ZWwgaW4nICtcbiAgICAgICAgICAgICAgICAnIExpdmVDb25uZWN0Q29uZmlnIHlldC4gUGxlYXNlIHVzZSB0aGUgY2xpZW50LWxldmVsIGh0dHBPcHRpb25zJyArXG4gICAgICAgICAgICAgICAgJyBjb25maWd1cmF0aW9uIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2Vic29ja2V0QmFzZVVybCA9IHRoaXMuYXBpQ2xpZW50LmdldFdlYnNvY2tldEJhc2VVcmwoKTtcbiAgICAgICAgY29uc3QgYXBpVmVyc2lvbiA9IHRoaXMuYXBpQ2xpZW50LmdldEFwaVZlcnNpb24oKTtcbiAgICAgICAgbGV0IHVybDtcbiAgICAgICAgY29uc3QgY2xpZW50SGVhZGVycyA9IHRoaXMuYXBpQ2xpZW50LmdldEhlYWRlcnMoKTtcbiAgICAgICAgaWYgKHBhcmFtcy5jb25maWcgJiZcbiAgICAgICAgICAgIHBhcmFtcy5jb25maWcudG9vbHMgJiZcbiAgICAgICAgICAgIGhhc01jcFRvb2xVc2FnZShwYXJhbXMuY29uZmlnLnRvb2xzKSkge1xuICAgICAgICAgICAgc2V0TWNwVXNhZ2VIZWFkZXIoY2xpZW50SGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG1hcFRvSGVhZGVycyhjbGllbnRIZWFkZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdXJsID0gYCR7d2Vic29ja2V0QmFzZVVybH0vd3MvZ29vZ2xlLmNsb3VkLmFpcGxhdGZvcm0uJHthcGlWZXJzaW9ufS5MbG1CaWRpU2VydmljZS9CaWRpR2VuZXJhdGVDb250ZW50YDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aC5hZGRBdXRoSGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGFwaUtleSA9IHRoaXMuYXBpQ2xpZW50LmdldEFwaUtleSgpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZCA9ICdCaWRpR2VuZXJhdGVDb250ZW50JztcbiAgICAgICAgICAgIGxldCBrZXlOYW1lID0gJ2tleSc7XG4gICAgICAgICAgICBpZiAoYXBpS2V5ID09PSBudWxsIHx8IGFwaUtleSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBpS2V5LnN0YXJ0c1dpdGgoJ2F1dGhfdG9rZW5zLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBFcGhlbWVyYWwgdG9rZW4gc3VwcG9ydCBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLicpO1xuICAgICAgICAgICAgICAgIGlmIChhcGlWZXJzaW9uICE9PSAndjFhbHBoYScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogVGhlIFNESydzIGVwaGVtZXJhbCB0b2tlbiBzdXBwb3J0IGlzIGluIHYxYWxwaGEgb25seS4gUGxlYXNlIHVzZSBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7YXBpS2V5OiB0b2tlbi5uYW1lLCBodHRwT3B0aW9uczogeyBhcGlWZXJzaW9uOiAndjFhbHBoYScgfX0pOyBiZWZvcmUgc2Vzc2lvbiBjb25uZWN0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gJ0JpZGlHZW5lcmF0ZUNvbnRlbnRDb25zdHJhaW5lZCc7XG4gICAgICAgICAgICAgICAga2V5TmFtZSA9ICdhY2Nlc3NfdG9rZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJsID0gYCR7d2Vic29ja2V0QmFzZVVybH0vd3MvZ29vZ2xlLmFpLmdlbmVyYXRpdmVsYW5ndWFnZS4ke2FwaVZlcnNpb259LkdlbmVyYXRpdmVTZXJ2aWNlLiR7bWV0aG9kfT8ke2tleU5hbWV9PSR7YXBpS2V5fWA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9ub3BlblJlc29sdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIGNvbnN0IG9ub3BlblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgb25vcGVuUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBwYXJhbXMuY2FsbGJhY2tzO1xuICAgICAgICBjb25zdCBvbm9wZW5Bd2FpdGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25vcGVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjYWxsYmFja3MpO1xuICAgICAgICAgICAgb25vcGVuUmVzb2x2ZSh7fSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFwaUNsaWVudCA9IHRoaXMuYXBpQ2xpZW50O1xuICAgICAgICBjb25zdCB3ZWJzb2NrZXRDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBvbm9wZW46IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayxcbiAgICAgICAgICAgIG9ubWVzc2FnZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdm9pZCBoYW5kbGVXZWJTb2NrZXRNZXNzYWdlKGFwaUNsaWVudCwgY2FsbGJhY2tzLm9ubWVzc2FnZSwgZXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uZXJyb3I6IChfYSA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbmVycm9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uY2xvc2U6IChfYiA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbmNsb3NlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMud2ViU29ja2V0RmFjdG9yeS5jcmVhdGUodXJsLCBoZWFkZXJzVG9NYXAoaGVhZGVycyksIHdlYnNvY2tldENhbGxiYWNrcyk7XG4gICAgICAgIGNvbm4uY29ubmVjdCgpO1xuICAgICAgICAvLyBXYWl0IGZvciB0aGUgd2Vic29ja2V0IHRvIG9wZW4gYmVmb3JlIHNlbmRpbmcgcmVxdWVzdHMuXG4gICAgICAgIGF3YWl0IG9ub3BlblByb21pc2U7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZE1vZGVsID0gdE1vZGVsKHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMubW9kZWwpO1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmXG4gICAgICAgICAgICB0cmFuc2Zvcm1lZE1vZGVsLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3QgPSB0aGlzLmFwaUNsaWVudC5nZXRQcm9qZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuYXBpQ2xpZW50LmdldExvY2F0aW9uKCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZE1vZGVsID1cbiAgICAgICAgICAgICAgICBgcHJvamVjdHMvJHtwcm9qZWN0fS9sb2NhdGlvbnMvJHtsb2NhdGlvbn0vYCArIHRyYW5zZm9ybWVkTW9kZWw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNsaWVudE1lc3NhZ2UgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSAmJlxuICAgICAgICAgICAgKChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZXNwb25zZU1vZGFsaXRpZXMpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFNldCBkZWZhdWx0IHRvIEFVRElPIHRvIGFsaWduIHdpdGggTUxEZXYgQVBJLlxuICAgICAgICAgICAgaWYgKHBhcmFtcy5jb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcgPSB7IHJlc3BvbnNlTW9kYWxpdGllczogW01vZGFsaXR5LkFVRElPXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy5yZXNwb25zZU1vZGFsaXRpZXMgPSBbTW9kYWxpdHkuQVVESU9dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZ2VuZXJhdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgLy8gUmFpc2UgZGVwcmVjYXRpb24gd2FybmluZyBmb3IgZ2VuZXJhdGlvbkNvbmZpZy5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU2V0dGluZyBgTGl2ZUNvbm5lY3RDb25maWcuZ2VuZXJhdGlvbl9jb25maWdgIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSBzZXQgdGhlIGZpZWxkcyBvbiBgTGl2ZUNvbm5lY3RDb25maWdgIGRpcmVjdGx5LiBUaGlzIHdpbGwgYmVjb21lIGFuIGVycm9yIGluIGEgZnV0dXJlIHZlcnNpb24gKG5vdCBiZWZvcmUgUTMgMjAyNSkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXRUb29scyA9IChfZiA9IChfZSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS50b29scykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogW107XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZFRvb2xzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiBpbnB1dFRvb2xzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxhYmxlVG9vbCA9IHRvb2w7XG4gICAgICAgICAgICAgICAgY29udmVydGVkVG9vbHMucHVzaChhd2FpdCBjYWxsYWJsZVRvb2wudG9vbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlZFRvb2xzLnB1c2godG9vbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnZlcnRlZFRvb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBhcmFtcy5jb25maWcudG9vbHMgPSBjb252ZXJ0ZWRUb29scztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXZlQ29ubmVjdFBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBtb2RlbDogdHJhbnNmb3JtZWRNb2RlbCxcbiAgICAgICAgICAgIGNvbmZpZzogcGFyYW1zLmNvbmZpZyxcbiAgICAgICAgICAgIGNhbGxiYWNrczogcGFyYW1zLmNhbGxiYWNrcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY2xpZW50TWVzc2FnZSA9IGxpdmVDb25uZWN0UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBsaXZlQ29ubmVjdFBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xpZW50TWVzc2FnZSA9IGxpdmVDb25uZWN0UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIGxpdmVDb25uZWN0UGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGNsaWVudE1lc3NhZ2VbJ2NvbmZpZyddO1xuICAgICAgICBjb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgICAgICByZXR1cm4gbmV3IFNlc3Npb24oY29ubiwgdGhpcy5hcGlDbGllbnQpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBiLzQxNjA0MTIyOSAtIEFic3RyYWN0IHRoaXMgbWV0aG9kIHRvIGEgY29tbW9uIHBsYWNlLlxuICAgIGlzQ2FsbGFibGVUb29sKHRvb2wpIHtcbiAgICAgICAgcmV0dXJuICdjYWxsVG9vbCcgaW4gdG9vbCAmJiB0eXBlb2YgdG9vbC5jYWxsVG9vbCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0TGl2ZVNlbmRDbGllbnRDb250ZW50UGFyYW1lcnRlcnMgPSB7XG4gICAgdHVybkNvbXBsZXRlOiB0cnVlLFxufTtcbi8qKlxuICAgUmVwcmVzZW50cyBhIGNvbm5lY3Rpb24gdG8gdGhlIEFQSS5cblxuICAgQGV4cGVyaW1lbnRhbFxuICAqL1xuY2xhc3MgU2Vzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoY29ubiwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHRoaXMuY29ubiA9IGNvbm47XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICB0TGl2ZUNsaWVudENvbnRlbnQoYXBpQ2xpZW50LCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy50dXJucyAhPT0gbnVsbCAmJiBwYXJhbXMudHVybnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRzID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gdENvbnRlbnRzKHBhcmFtcy50dXJucyk7XG4gICAgICAgICAgICAgICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBjb250ZW50cy5tYXAoKGl0ZW0pID0+IGNvbnRlbnRUb1ZlcnRleChpdGVtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLm1hcCgoaXRlbSkgPT4gY29udGVudFRvTWxkZXYkMShpdGVtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgY2xpZW50IGNvbnRlbnQgXCJ0dXJuc1wiLCB0eXBlOiAnJHt0eXBlb2YgcGFyYW1zLnR1cm5zfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2xpZW50Q29udGVudDogeyB0dXJuczogY29udGVudHMsIHR1cm5Db21wbGV0ZTogcGFyYW1zLnR1cm5Db21wbGV0ZSB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50Q29udGVudDogeyB0dXJuQ29tcGxldGU6IHBhcmFtcy50dXJuQ29tcGxldGUgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdExpdmVDbGllbnR0VG9vbFJlc3BvbnNlKGFwaUNsaWVudCwgcGFyYW1zKSB7XG4gICAgICAgIGxldCBmdW5jdGlvblJlc3BvbnNlcyA9IFtdO1xuICAgICAgICBpZiAocGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb25SZXNwb25zZXMgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcykpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VzID0gW3BhcmFtcy5mdW5jdGlvblJlc3BvbnNlc107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlcyA9IHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuY3Rpb25SZXNwb25zZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uUmVzcG9uc2VzIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZnVuY3Rpb25SZXNwb25zZSBvZiBmdW5jdGlvblJlc3BvbnNlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvblJlc3BvbnNlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAhKCduYW1lJyBpbiBmdW5jdGlvblJlc3BvbnNlKSB8fFxuICAgICAgICAgICAgICAgICEoJ3Jlc3BvbnNlJyBpbiBmdW5jdGlvblJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIGZ1bmN0aW9uIHJlc3BvbnNlLCB0eXBlICcke3R5cGVvZiBmdW5jdGlvblJlc3BvbnNlfScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiYgISgnaWQnIGluIGZ1bmN0aW9uUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEZVTkNUSU9OX1JFU1BPTlNFX1JFUVVJUkVTX0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0ge1xuICAgICAgICAgICAgdG9vbFJlc3BvbnNlOiB7IGZ1bmN0aW9uUmVzcG9uc2VzOiBmdW5jdGlvblJlc3BvbnNlcyB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xpZW50TWVzc2FnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZW5kIGEgbWVzc2FnZSBvdmVyIHRoZSBlc3RhYmxpc2hlZCBjb25uZWN0aW9uLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyB0d28gKipvcHRpb25hbCoqIHByb3BlcnRpZXMsIGB0dXJuc2AgYW5kXG4gICAgICAgICAgYHR1cm5Db21wbGV0ZWAuXG4gIFxuICAgICAgICAtIGB0dXJuc2Agd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgQ29udGVudFtdYFxuICAgICAgICAtIGB0dXJuQ29tcGxldGU6IHRydWVgIFtkZWZhdWx0XSBpbmRpY2F0ZXMgdGhhdCB5b3UgYXJlIGRvbmUgc2VuZGluZ1xuICAgICAgICAgIGNvbnRlbnQgYW5kIGV4cGVjdCBhIHJlc3BvbnNlLiBJZiBgdHVybkNvbXBsZXRlOiBmYWxzZWAsIHRoZSBzZXJ2ZXJcbiAgICAgICAgICB3aWxsIHdhaXQgZm9yIGFkZGl0aW9uYWwgbWVzc2FnZXMgYmVmb3JlIHN0YXJ0aW5nIGdlbmVyYXRpb24uXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgIEByZW1hcmtzXG4gICAgICBUaGVyZSBhcmUgdHdvIHdheXMgdG8gc2VuZCBtZXNzYWdlcyB0byB0aGUgbGl2ZSBBUEk6XG4gICAgICBgc2VuZENsaWVudENvbnRlbnRgIGFuZCBgc2VuZFJlYWx0aW1lSW5wdXRgLlxuICBcbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudGAgbWVzc2FnZXMgYXJlIGFkZGVkIHRvIHRoZSBtb2RlbCBjb250ZXh0ICoqaW4gb3JkZXIqKi5cbiAgICAgIEhhdmluZyBhIGNvbnZlcnNhdGlvbiB1c2luZyBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2VzIGlzIHJvdWdobHlcbiAgICAgIGVxdWl2YWxlbnQgdG8gdXNpbmcgdGhlIGBDaGF0LnNlbmRNZXNzYWdlU3RyZWFtYCwgZXhjZXB0IHRoYXQgdGhlIHN0YXRlIG9mXG4gICAgICB0aGUgYGNoYXRgIGhpc3RvcnkgaXMgc3RvcmVkIG9uIHRoZSBBUEkgc2VydmVyIGluc3RlYWQgb2YgbG9jYWxseS5cbiAgXG4gICAgICBCZWNhdXNlIG9mIGBzZW5kQ2xpZW50Q29udGVudGAncyBvcmRlciBndWFyYW50ZWUsIHRoZSBtb2RlbCBjYW5ub3QgcmVzcG9uc1xuICAgICAgYXMgcXVpY2tseSB0byBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2VzIGFzIHRvIGBzZW5kUmVhbHRpbWVJbnB1dGBcbiAgICAgIG1lc3NhZ2VzLiBUaGlzIG1ha2VzIHRoZSBiaWdnZXN0IGRpZmZlcmVuY2Ugd2hlbiBzZW5kaW5nIG9iamVjdHMgdGhhdCBoYXZlXG4gICAgICBzaWduaWZpY2FudCBwcmVwcm9jZXNzaW5nIHRpbWUgKHR5cGljYWxseSBpbWFnZXMpLlxuICBcbiAgICAgIFRoZSBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2Ugc2VuZHMgYSBgQ29udGVudFtdYFxuICAgICAgd2hpY2ggaGFzIG1vcmUgb3B0aW9ucyB0aGFuIHRoZSBgQmxvYmAgc2VudCBieSBgc2VuZFJlYWx0aW1lSW5wdXRgLlxuICBcbiAgICAgIFNvIHRoZSBtYWluIHVzZS1jYXNlcyBmb3IgYHNlbmRDbGllbnRDb250ZW50YCBvdmVyIGBzZW5kUmVhbHRpbWVJbnB1dGAgYXJlOlxuICBcbiAgICAgIC0gU2VuZGluZyBhbnl0aGluZyB0aGF0IGNhbid0IGJlIHJlcHJlc2VudGVkIGFzIGEgYEJsb2JgICh0ZXh0LFxuICAgICAgYHNlbmRDbGllbnRDb250ZW50KHt0dXJucz1cIkhlbGxvP1wifWApKS5cbiAgICAgIC0gTWFuYWdpbmcgdHVybnMgd2hlbiBub3QgdXNpbmcgYXVkaW8gaW5wdXQgYW5kIHZvaWNlIGFjdGl2aXR5IGRldGVjdGlvbi5cbiAgICAgICAgKGBzZW5kQ2xpZW50Q29udGVudCh7dHVybkNvbXBsZXRlOnRydWV9KWAgb3IgdGhlIHNob3J0IGZvcm1cbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudCgpYClcbiAgICAgIC0gUHJlZmlsbGluZyBhIGNvbnZlcnNhdGlvbiBjb250ZXh0XG4gICAgICAgIGBgYFxuICAgICAgICBzZW5kQ2xpZW50Q29udGVudCh7XG4gICAgICAgICAgICB0dXJuczogW1xuICAgICAgICAgICAgICBDb250ZW50KHtyb2xlOnVzZXIsIHBhcnRzOi4uLn0pLFxuICAgICAgICAgICAgICBDb250ZW50KHtyb2xlOnVzZXIsIHBhcnRzOi4uLn0pLFxuICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgICAgYGBgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgc2VuZENsaWVudENvbnRlbnQocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdExpdmVTZW5kQ2xpZW50Q29udGVudFBhcmFtZXJ0ZXJzKSwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHRoaXMudExpdmVDbGllbnRDb250ZW50KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2VuZCBhIHJlYWx0aW1lIG1lc3NhZ2Ugb3ZlciB0aGUgZXN0YWJsaXNoZWQgY29ubmVjdGlvbi5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgb25lIHByb3BlcnR5LCBgbWVkaWFgLlxuICBcbiAgICAgICAgLSBgbWVkaWFgIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYEJsb2JgXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgIEByZW1hcmtzXG4gICAgICBVc2UgYHNlbmRSZWFsdGltZUlucHV0YCBmb3IgcmVhbHRpbWUgYXVkaW8gY2h1bmtzIGFuZCB2aWRlbyBmcmFtZXMgKGltYWdlcykuXG4gIFxuICAgICAgV2l0aCBgc2VuZFJlYWx0aW1lSW5wdXRgIHRoZSBhcGkgd2lsbCByZXNwb25kIHRvIGF1ZGlvIGF1dG9tYXRpY2FsbHlcbiAgICAgIGJhc2VkIG9uIHZvaWNlIGFjdGl2aXR5IGRldGVjdGlvbiAoVkFEKS5cbiAgXG4gICAgICBgc2VuZFJlYWx0aW1lSW5wdXRgIGlzIG9wdGltaXplZCBmb3IgcmVzcG9uc2l2bmVzcyBhdCB0aGUgZXhwZW5zZSBvZlxuICAgICAgZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBndWFyYW50ZWVzLiBBdWRpbyBhbmQgdmlkZW8gdG9rZW5zIGFyZSB0byB0aGVcbiAgICAgIGNvbnRleHQgd2hlbiB0aGV5IGJlY29tZSBhdmFpbGFibGUuXG4gIFxuICAgICAgTm90ZTogVGhlIENhbGwgc2lnbmF0dXJlIGV4cGVjdHMgYSBgQmxvYmAgb2JqZWN0LCBidXQgb25seSBhIHN1YnNldFxuICAgICAgb2YgYXVkaW8gYW5kIGltYWdlIG1pbWV0eXBlcyBhcmUgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBzZW5kUmVhbHRpbWVJbnB1dChwYXJhbXMpIHtcbiAgICAgICAgbGV0IGNsaWVudE1lc3NhZ2UgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY2xpZW50TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAncmVhbHRpbWVJbnB1dCc6IGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgJ3JlYWx0aW1lSW5wdXQnOiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2VuZCBhIGZ1bmN0aW9uIHJlc3BvbnNlIG1lc3NhZ2Ugb3ZlciB0aGUgZXN0YWJsaXNoZWQgY29ubmVjdGlvbi5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgcHJvcGVydHkgYGZ1bmN0aW9uUmVzcG9uc2VzYC5cbiAgXG4gICAgICAgIC0gYGZ1bmN0aW9uUmVzcG9uc2VzYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBmdW5jdGlvblJlc3BvbnNlc1tdYFxuICBcbiAgICAgIEByZW1hcmtzXG4gICAgICBVc2UgYHNlbmRGdW5jdGlvblJlc3BvbnNlYCB0byByZXBseSB0byBgTGl2ZVNlcnZlclRvb2xDYWxsYCBmcm9tIHRoZSBzZXJ2ZXIuXG4gIFxuICAgICAgVXNlIHtAbGluayB0eXBlcy5MaXZlQ29ubmVjdENvbmZpZyN0b29sc30gdG8gY29uZmlndXJlIHRoZSBjYWxsYWJsZSBmdW5jdGlvbnMuXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHNlbmRUb29sUmVzcG9uc2UocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb29sIHJlc3BvbnNlIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB0aGlzLnRMaXZlQ2xpZW50dFRvb2xSZXNwb25zZSh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICBUZXJtaW5hdGVzIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsOiBzdHJpbmc7XG4gICAgICAgaWYgKEdPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUkpIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS0yLjAtZmxhc2gtbGl2ZS1wcmV2aWV3LTA0LTA5JztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLWxpdmUtMi41LWZsYXNoLXByZXZpZXcnO1xuICAgICAgIH1cbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICByZXNwb25zZU1vZGFsaXRpZXM6IFtNb2RhbGl0eS5BVURJT10sXG4gICAgICAgICB9XG4gICAgICAgfSk7XG4gIFxuICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICBgYGBcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgfVxufVxuLy8gQ29udmVydHMgYW4gaGVhZGVycyBvYmplY3QgdG8gYSBcIm1hcFwiIG9iamVjdCBhcyBleHBlY3RlZCBieSB0aGUgV2ViU29ja2V0XG4vLyBjb25zdHJ1Y3Rvci4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGggaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzXG4vLyB3aGlsZSB0aGUgV2ViU29ja2V0IGNvbnN0cnVjdG9yIHRha2VzIGEgbWFwLlxuZnVuY3Rpb24gaGVhZGVyc1RvTWFwKGhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJNYXAgPSB7fTtcbiAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaGVhZGVyTWFwW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyTWFwO1xufVxuLy8gQ29udmVydHMgYSBcIm1hcFwiIG9iamVjdCB0byBhIGhlYWRlcnMgb2JqZWN0LiBXZSB1c2UgdGhpcyBhcyB0aGUgQXV0aFxuLy8gaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzIHdoaWxlIHRoZSBBUEkgY2xpZW50IGRlZmF1bHQgaGVhZGVyc1xuLy8gcmV0dXJucyBhIG1hcC5cbmZ1bmN0aW9uIG1hcFRvSGVhZGVycyhtYXApIHtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgREVGQVVMVF9NQVhfUkVNT1RFX0NBTExTID0gMTA7XG4vKiogUmV0dXJucyB3aGV0aGVyIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIGlzIGRpc2FibGVkLiAqL1xuZnVuY3Rpb24gc2hvdWxkRGlzYWJsZUFmYyhjb25maWcpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBpZiAoKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2FibGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBjYWxsYWJsZVRvb2xzUHJlc2VudCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdG9vbCBvZiAoX2IgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcudG9vbHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKSB7XG4gICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgY2FsbGFibGVUb29sc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjYWxsYWJsZVRvb2xzUHJlc2VudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbWF4Q2FsbHMgPSAoX2MgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWF4aW11bVJlbW90ZUNhbGxzO1xuICAgIGlmICgobWF4Q2FsbHMgJiYgKG1heENhbGxzIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihtYXhDYWxscykpKSB8fFxuICAgICAgICBtYXhDYWxscyA9PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBtYXhpbXVtUmVtb3RlQ2FsbHMgdmFsdWUgcHJvdmlkZWQgZm9yIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nLiBEaXNhYmxlZCBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZy4gUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBpbnRlZ2VyIHZhbHVlIGdyZWF0ZXIgdGhhbiAwLiBtYXhpbXVtUmVtb3RlQ2FsbHMgcHJvdmlkZWQ6JywgbWF4Q2FsbHMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDYWxsYWJsZVRvb2wodG9vbCkge1xuICAgIHJldHVybiAnY2FsbFRvb2wnIGluIHRvb2wgJiYgdHlwZW9mIHRvb2wuY2FsbFRvb2wgPT09ICdmdW5jdGlvbic7XG59XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgQ2FsbGFibGVUb29scy4gV2lsbCByZXR1cm4gdHJ1ZVxuLy8gaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIENhbGxhYmxlVG9vbC5cbmZ1bmN0aW9uIGhhc0NhbGxhYmxlVG9vbHMocGFyYW1zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIChfYyA9IChfYiA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNvbWUoKHRvb2wpID0+IGlzQ2FsbGFibGVUb29sKHRvb2wpKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2U7XG59XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgbm9uLWNhbGxhYmxlIHRvb2xzLiBXaWxsIHJldHVyblxuLy8gdHJ1ZSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbm9uLUNhbGxhYmxlIHRvb2wuXG5mdW5jdGlvbiBoYXNOb25DYWxsYWJsZVRvb2xzKHBhcmFtcykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zb21lKCh0b29sKSA9PiAhaXNDYWxsYWJsZVRvb2wodG9vbCkpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRvIGFwcGVuZCBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyBoaXN0b3J5IHRvIHRoZVxuICogcmVzcG9uc2UuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZEFwcGVuZEFmY0hpc3RvcnkoY29uZmlnKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhKChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZ25vcmVDYWxsSGlzdG9yeSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIE1vZGVscyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2VzIGFuIEFQSSByZXF1ZXN0IHRvIGdlbmVyYXRlIGNvbnRlbnQgd2l0aCBhIGdpdmVuIG1vZGVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIGBtb2RlbGAgcGFyYW1ldGVyLCBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgVmVydGV4IEFJIEFQSSBpbmNsdWRlOlxuICAgICAgICAgKiAtIFRoZSBHZW1pbmkgbW9kZWwgSUQsIGZvciBleGFtcGxlOiAnZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgZnVsbCByZXNvdXJjZSBuYW1lIHN0YXJ0cyB3aXRoICdwcm9qZWN0cy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwcm9qZWN0cy9teS1wcm9qZWN0LWlkL2xvY2F0aW9ucy91cy1jZW50cmFsMS9wdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgcGFydGlhbCByZXNvdXJjZSBuYW1lIHdpdGggJ3B1Ymxpc2hlcnMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAncHVibGlzaGVycy9nb29nbGUvbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnIG9yXG4gICAgICAgICAqICAncHVibGlzaGVycy9tZXRhL21vZGVscy9sbGFtYS0zLjEtNDA1Yi1pbnN0cnVjdC1tYWFzJ1xuICAgICAgICAgKiAtIGAvYCBzZXBhcmF0ZWQgcHVibGlzaGVyIGFuZCBtb2RlbCBuYW1lLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogJ2dvb2dsZS9nZW1pbmktMi4wLWZsYXNoJyBvciAnbWV0YS9sbGFtYS0zLjEtNDA1Yi1pbnN0cnVjdC1tYWFzJ1xuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIGBtb2RlbGAgcGFyYW1ldGVyLCBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgR2VtaW5pIEFQSSBpbmNsdWRlOlxuICAgICAgICAgKiAtIFRoZSBHZW1pbmkgbW9kZWwgSUQsIGZvciBleGFtcGxlOiAnZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgbW9kZWwgbmFtZSBzdGFydHMgd2l0aCAnbW9kZWxzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIEZvciB0dW5lZCBtb2RlbHMsIHRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICd0dW5lZE1vZGVscy8nLFxuICAgICAgICAgKiBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogJ3R1bmVkTW9kZWxzLzEyMzQ1Njc4OTAxMjM0NTY3ODknXG4gICAgICAgICAqXG4gICAgICAgICAqIFNvbWUgbW9kZWxzIHN1cHBvcnQgbXVsdGltb2RhbCBpbnB1dCBhbmQgb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdlbmVyYXRpbmcgY29udGVudC5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSBnZW5lcmF0aW5nIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgICAgICogICBjb250ZW50czogJ3doeSBpcyB0aGUgc2t5IGJsdWU/JyxcbiAgICAgICAgICogICBjb25maWc6IHtcbiAgICAgICAgICogICAgIGNhbmRpZGF0ZUNvdW50OiAyLFxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ29udGVudCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IHRoaXMucHJvY2Vzc1BhcmFtc01heWJlQWRkTWNwVXNhZ2UocGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMubWF5YmVNb3ZlVG9SZXNwb25zZUpzb25TY2hlbShwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKCFoYXNDYWxsYWJsZVRvb2xzKHBhcmFtcykgfHwgc2hvdWxkRGlzYWJsZUFmYyhwYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlQ29udGVudEludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNOb25DYWxsYWJsZVRvb2xzKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIHdpdGggQ2FsbGFibGVUb29scyBhbmQgVG9vbHMgaXMgbm90IHlldCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQ7XG4gICAgICAgICAgICBjb25zdCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID0gdENvbnRlbnRzKHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFJlbW90ZUNhbGxzID0gKF9jID0gKF9iID0gKF9hID0gdHJhbnNmb3JtZWRQYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4aW11bVJlbW90ZUNhbGxzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFM7XG4gICAgICAgICAgICBsZXQgcmVtb3RlQ2FsbHMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHJlbW90ZUNhbGxzIDwgbWF4UmVtb3RlQ2FsbHMpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2UuZnVuY3Rpb25DYWxscyB8fCByZXNwb25zZS5mdW5jdGlvbkNhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50ID0gcmVzcG9uc2UuY2FuZGlkYXRlc1swXS5jb250ZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2VQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiAoX2UgPSAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9vbHMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gYXdhaXQgY2FsbGFibGVUb29sLmNhbGxUb29sKHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZVBhcnRzLnB1c2goLi4ucGFydHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW90ZUNhbGxzKys7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgcGFydHM6IGZ1bmN0aW9uUmVzcG9uc2VQYXJ0cyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzID0gdENvbnRlbnRzKHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cy5wdXNoKHJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMucHVzaChmdW5jdGlvblJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEFwcGVuZEFmY0hpc3RvcnkodHJhbnNmb3JtZWRQYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5LnB1c2gocmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5wdXNoKGZ1bmN0aW9uUmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkQXBwZW5kQWZjSGlzdG9yeSh0cmFuc2Zvcm1lZFBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9XG4gICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlcyBhbiBBUEkgcmVxdWVzdCB0byBnZW5lcmF0ZSBjb250ZW50IHdpdGggYSBnaXZlbiBtb2RlbCBhbmQgeWllbGRzIHRoZVxuICAgICAgICAgKiByZXNwb25zZSBpbiBjaHVua3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBWZXJ0ZXggQUkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBmdWxsIHJlc291cmNlIG5hbWUgc3RhcnRzIHdpdGggJ3Byb2plY3RzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3Byb2plY3RzL215LXByb2plY3QtaWQvbG9jYXRpb25zL3VzLWNlbnRyYWwxL3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBwYXJ0aWFsIHJlc291cmNlIG5hbWUgd2l0aCAncHVibGlzaGVycy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCcgb3JcbiAgICAgICAgICogICdwdWJsaXNoZXJzL21ldGEvbW9kZWxzL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqIC0gYC9gIHNlcGFyYXRlZCBwdWJsaXNoZXIgYW5kIG1vZGVsIG5hbWUsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAnZ29vZ2xlL2dlbWluaS0yLjAtZmxhc2gnIG9yICdtZXRhL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBHZW1pbmkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICdtb2RlbHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAnbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gRm9yIHR1bmVkIG1vZGVscywgdGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ3R1bmVkTW9kZWxzLycsXG4gICAgICAgICAqIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3R1bmVkTW9kZWxzLzEyMzQ1Njc4OTAxMjM0NTY3ODknXG4gICAgICAgICAqXG4gICAgICAgICAqIFNvbWUgbW9kZWxzIHN1cHBvcnQgbXVsdGltb2RhbCBpbnB1dCBhbmQgb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdlbmVyYXRpbmcgY29udGVudCB3aXRoIHN0cmVhbWluZyByZXNwb25zZS5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSBnZW5lcmF0aW5nIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudFN0cmVhbSh7XG4gICAgICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgICAgICogICBjb250ZW50czogJ3doeSBpcyB0aGUgc2t5IGJsdWU/JyxcbiAgICAgICAgICogICBjb25maWc6IHtcbiAgICAgICAgICogICAgIG1heE91dHB1dFRva2VuczogMjAwLFxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzcG9uc2UpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhjaHVuayk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ29udGVudFN0cmVhbSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVNb3ZlVG9SZXNwb25zZUpzb25TY2hlbShwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKHNob3VsZERpc2FibGVBZmMocGFyYW1zLmNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IHRoaXMucHJvY2Vzc1BhcmFtc01heWJlQWRkTWNwVXNhZ2UocGFyYW1zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW1JbnRlcm5hbCh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm9jZXNzQWZjU3RyZWFtKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmF0ZXMgYW4gaW1hZ2UgYmFzZWQgb24gYSB0ZXh0IGRlc2NyaXB0aW9uIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdlbmVyYXRpbmcgaW1hZ2VzLlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50Lm1vZGVscy5nZW5lcmF0ZUltYWdlcyh7XG4gICAgICAgICAqICBtb2RlbDogJ2ltYWdlbi0zLjAtZ2VuZXJhdGUtMDAyJyxcbiAgICAgICAgICogIHByb21wdDogJ1JvYm90IGhvbGRpbmcgYSByZWQgc2thdGVib2FyZCcsXG4gICAgICAgICAqICBjb25maWc6IHtcbiAgICAgICAgICogICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICAgICAqICAgIGluY2x1ZGVSYWlSZWFzb246IHRydWUsXG4gICAgICAgICAqICB9LFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2U/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUltYWdlcyA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlSW1hZ2VzSW50ZXJuYWwocGFyYW1zKS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZEltYWdlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChhcGlSZXNwb25zZSA9PT0gbnVsbCB8fCBhcGlSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBpUmVzcG9uc2UuZ2VuZXJhdGVkSW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZ2VuZXJhdGVkSW1hZ2Ugb2YgYXBpUmVzcG9uc2UuZ2VuZXJhdGVkSW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkSW1hZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYSA9IGdlbmVyYXRlZEltYWdlID09PSBudWxsIHx8IGdlbmVyYXRlZEltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZW5lcmF0ZWRJbWFnZS5zYWZldHlBdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudFR5cGUpID09PSAnUG9zaXRpdmUgUHJvbXB0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyA9IGdlbmVyYXRlZEltYWdlID09PSBudWxsIHx8IGdlbmVyYXRlZEltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZW5lcmF0ZWRJbWFnZS5zYWZldHlBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkSW1hZ2VzLnB1c2goZ2VuZXJhdGVkSW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkSW1hZ2VzOiBnZW5lcmF0ZWRJbWFnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXM6IHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNka0h0dHBSZXNwb25zZTogYXBpUmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXM6IGdlbmVyYXRlZEltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNka0h0dHBSZXNwb25zZTogYXBpUmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBxdWVyeUJhc2U6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWN0dWFsQ29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q29uZmlnKSwgcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29uZmlnOiBhY3R1YWxDb25maWcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIGlmICghYWN0dWFsUGFyYW1zLmNvbmZpZy5xdWVyeUJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IGFjdHVhbFBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsdGVyaW5nIHR1bmVkIG1vZGVscyBsaXN0IGZvciBWZXJ0ZXggQUkgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbFBhcmFtcy5jb25maWcuZmlsdGVyID0gJ2xhYmVscy50dW5lLXR5cGU6Kic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX01PREVMUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChhY3R1YWxQYXJhbXMpLCBhY3R1YWxQYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRWRpdHMgYW4gaW1hZ2UgYmFzZWQgb24gYSBwcm9tcHQsIGxpc3Qgb2YgcmVmZXJlbmNlIGltYWdlcywgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZWRpdGluZyBhbiBpbWFnZS5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5tb2RlbHMuZWRpdEltYWdlKHtcbiAgICAgICAgICogIG1vZGVsOiAnaW1hZ2VuLTMuMC1jYXBhYmlsaXR5LTAwMScsXG4gICAgICAgICAqICBwcm9tcHQ6ICdHZW5lcmF0ZSBhbiBpbWFnZSBjb250YWluaW5nIGEgbXVnIHdpdGggdGhlIHByb2R1Y3QgbG9nbyBbMV0gdmlzaWJsZSBvbiB0aGUgc2lkZSBvZiB0aGUgbXVnLicsXG4gICAgICAgICAqICByZWZlcmVuY2VJbWFnZXM6IFtzdWJqZWN0UmVmZXJlbmNlSW1hZ2VdXG4gICAgICAgICAqICBjb25maWc6IHtcbiAgICAgICAgICogICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICAgICAqICAgIGluY2x1ZGVSYWlSZWFzb246IHRydWUsXG4gICAgICAgICAqICB9LFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2U/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGl0SW1hZ2UgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXNJbnRlcm5hbCA9IHtcbiAgICAgICAgICAgICAgICBtb2RlbDogcGFyYW1zLm1vZGVsLFxuICAgICAgICAgICAgICAgIHByb21wdDogcGFyYW1zLnByb21wdCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VJbWFnZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogcGFyYW1zLmNvbmZpZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocGFyYW1zLnJlZmVyZW5jZUltYWdlcykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMucmVmZXJlbmNlSW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc0ludGVybmFsLnJlZmVyZW5jZUltYWdlcyA9IHBhcmFtcy5yZWZlcmVuY2VJbWFnZXMubWFwKChpbWcpID0+IGltZy50b1JlZmVyZW5jZUltYWdlQVBJKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVkaXRJbWFnZUludGVybmFsKHBhcmFtc0ludGVybmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwc2NhbGVzIGFuIGltYWdlIGJhc2VkIG9uIGFuIGltYWdlLCB1cHNjYWxlIGZhY3RvciwgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIE9ubHkgc3VwcG9ydGVkIGluIFZlcnRleCBBSSBjdXJyZW50bHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdXBzY2FsaW5nIGFuIGltYWdlLlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50Lm1vZGVscy51cHNjYWxlSW1hZ2Uoe1xuICAgICAgICAgKiAgbW9kZWw6ICdpbWFnZW4tMy4wLWdlbmVyYXRlLTAwMicsXG4gICAgICAgICAqICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAqICB1cHNjYWxlRmFjdG9yOiAneDInLFxuICAgICAgICAgKiAgY29uZmlnOiB7XG4gICAgICAgICAqICAgIGluY2x1ZGVSYWlSZWFzb246IHRydWUsXG4gICAgICAgICAqICB9LFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2U/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cHNjYWxlSW1hZ2UgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBsZXQgYXBpQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAgICAgICAgICAgIG1vZGU6ICd1cHNjYWxlJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocGFyYW1zLmNvbmZpZykge1xuICAgICAgICAgICAgICAgIGFwaUNvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXBpQ29uZmlnKSwgcGFyYW1zLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgbW9kZWw6IHBhcmFtcy5tb2RlbCxcbiAgICAgICAgICAgICAgICBpbWFnZTogcGFyYW1zLmltYWdlLFxuICAgICAgICAgICAgICAgIHVwc2NhbGVGYWN0b3I6IHBhcmFtcy51cHNjYWxlRmFjdG9yLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogYXBpQ29uZmlnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnVwc2NhbGVJbWFnZUludGVybmFsKGFwaVBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgR2VuZXJhdGVzIHZpZGVvcyBiYXNlZCBvbiBhIHRleHQgZGVzY3JpcHRpb24gYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyB2aWRlb3MuXG4gICAgICAgICAqIEByZXR1cm4gQSBQcm9taXNlPEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uPiB3aGljaCBhbGxvd3MgeW91IHRvIHRyYWNrIHRoZSBwcm9ncmVzcyBhbmQgZXZlbnR1YWxseSByZXRyaWV2ZSB0aGUgZ2VuZXJhdGVkIHZpZGVvcyB1c2luZyB0aGUgb3BlcmF0aW9ucy5nZXQgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCBvcGVyYXRpb24gPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVWaWRlb3Moe1xuICAgICAgICAgKiAgbW9kZWw6ICd2ZW8tMi4wLWdlbmVyYXRlLTAwMScsXG4gICAgICAgICAqICBzb3VyY2U6IHtcbiAgICAgICAgICogICAgcHJvbXB0OiAnQSBuZW9uIGhvbG9ncmFtIG9mIGEgY2F0IGRyaXZpbmcgYXQgdG9wIHNwZWVkJyxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqICBjb25maWc6IHtcbiAgICAgICAgICogICAgbnVtYmVyT2ZWaWRlb3M6IDFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHdoaWxlICghb3BlcmF0aW9uLmRvbmUpIHtcbiAgICAgICAgICogICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMDApKTtcbiAgICAgICAgICogICBvcGVyYXRpb24gPSBhd2FpdCBhaS5vcGVyYXRpb25zLmdldFZpZGVvc09wZXJhdGlvbih7b3BlcmF0aW9uOiBvcGVyYXRpb259KTtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhvcGVyYXRpb24ucmVzcG9uc2U/LmdlbmVyYXRlZFZpZGVvcz8uWzBdPy52aWRlbz8udXJpKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlVmlkZW9zID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgaWYgKChwYXJhbXMucHJvbXB0IHx8IHBhcmFtcy5pbWFnZSB8fCBwYXJhbXMudmlkZW8pICYmIHBhcmFtcy5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBhbmQgcHJvbXB0L2ltYWdlL3ZpZGVvIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuIFBsZWFzZSBvbmx5IHVzZSBzb3VyY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZVZpZGVvc0ludGVybmFsKHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbG9naWMgaXMgbmVlZGVkIGZvciBHZW5lcmF0ZUNvbnRlbnRDb25maWcgb25seS5cbiAgICAgKiBQcmV2aW91c2x5IHdlIG1hZGUgR2VuZXJhdGVDb250ZW50Q29uZmlnLnJlc3BvbnNlU2NoZW1hIGZpZWxkIHRvIGFjY2VwdFxuICAgICAqIHVua25vd24uIFNpbmNlIHYxLjkuMCwgd2Ugc3dpdGNoIHRvIHVzZSBiYWNrZW5kIEpTT04gc2NoZW1hIHN1cHBvcnQuXG4gICAgICogVG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgd2UgbW92ZSB0aGUgZGF0YSB0aGF0IHdhcyB0cmVhdGVkIGFzXG4gICAgICogSlNPTiBzY2hlbWEgZnJvbSB0aGUgcmVzcG9uc2VTY2hlbWEgZmllbGQgdG8gdGhlIHJlc3BvbnNlSnNvblNjaGVtYSBmaWVsZC5cbiAgICAgKi9cbiAgICBtYXliZU1vdmVUb1Jlc3BvbnNlSnNvblNjaGVtKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJiBwYXJhbXMuY29uZmlnLnJlc3BvbnNlU2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmFtcy5jb25maWcucmVzcG9uc2VKc29uU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcy5jb25maWcucmVzcG9uc2VTY2hlbWEpLmluY2x1ZGVzKCckc2NoZW1hJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy5yZXNwb25zZUpzb25TY2hlbWEgPSBwYXJhbXMuY29uZmlnLnJlc3BvbnNlU2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLmNvbmZpZy5yZXNwb25zZVNjaGVtYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBDYWxsYWJsZVRvb2xzIGluIHRoZSBwYXJhbWV0ZXJzIHRvIGJlIHNpbXBseSBUb29scywgaXRcbiAgICAgKiBjb3BpZXMgdGhlIHBhcmFtcyBpbnRvIGEgbmV3IG9iamVjdCBhbmQgcmVwbGFjZXMgdGhlIHRvb2xzLCBpdCBkb2VzIG5vdFxuICAgICAqIG1vZGlmeSB0aGUgb3JpZ2luYWwgcGFyYW1zLiBBbHNvIHNldHMgdGhlIE1DUCB1c2FnZSBoZWFkZXIgaWYgdGhlcmUgYXJlXG4gICAgICogTUNQIHRvb2xzIGluIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGFzeW5jIHByb2Nlc3NQYXJhbXNNYXliZUFkZE1jcFVzYWdlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgdG9vbHMgPSAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbHM7XG4gICAgICAgIGlmICghdG9vbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRUb29scyA9IGF3YWl0IFByb21pc2UuYWxsKHRvb2xzLm1hcChhc3luYyAodG9vbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgY2FsbGFibGVUb29sLnRvb2woKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b29sO1xuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHtcbiAgICAgICAgICAgIG1vZGVsOiBwYXJhbXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogcGFyYW1zLmNvbnRlbnRzLFxuICAgICAgICAgICAgY29uZmlnOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcy5jb25maWcpLCB7IHRvb2xzOiB0cmFuc2Zvcm1lZFRvb2xzIH0pLFxuICAgICAgICB9O1xuICAgICAgICBuZXdQYXJhbXMuY29uZmlnLnRvb2xzID0gdHJhbnNmb3JtZWRUb29scztcbiAgICAgICAgaWYgKHBhcmFtcy5jb25maWcgJiZcbiAgICAgICAgICAgIHBhcmFtcy5jb25maWcudG9vbHMgJiZcbiAgICAgICAgICAgIGhhc01jcFRvb2xVc2FnZShwYXJhbXMuY29uZmlnLnRvb2xzKSkge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IChfYyA9IChfYiA9IHBhcmFtcy5jb25maWcuaHR0cE9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fTtcbiAgICAgICAgICAgIGxldCBuZXdIZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgaGVhZGVycyk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobmV3SGVhZGVycykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbmV3SGVhZGVycyA9IHRoaXMuYXBpQ2xpZW50LmdldERlZmF1bHRIZWFkZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNY3BVc2FnZUhlYWRlcihuZXdIZWFkZXJzKTtcbiAgICAgICAgICAgIG5ld1BhcmFtcy5jb25maWcuaHR0cE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcy5jb25maWcuaHR0cE9wdGlvbnMpLCB7IGhlYWRlcnM6IG5ld0hlYWRlcnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICB9XG4gICAgYXN5bmMgaW5pdEFmY1Rvb2xzTWFwKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgYWZjVG9vbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiAoX2IgPSAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKSB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYWJsZVRvb2wgPSB0b29sO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xEZWNsYXJhdGlvbiA9IGF3YWl0IGNhbGxhYmxlVG9vbC50b29sKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZWNsYXJhdGlvbiBvZiAoX2MgPSB0b29sRGVjbGFyYXRpb24uZnVuY3Rpb25EZWNsYXJhdGlvbnMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVjbGFyYXRpb24ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBkZWNsYXJhdGlvbiBuYW1lIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZmNUb29scy5oYXMoZGVjbGFyYXRpb24ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIHRvb2wgZGVjbGFyYXRpb24gbmFtZTogJHtkZWNsYXJhdGlvbi5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFmY1Rvb2xzLnNldChkZWNsYXJhdGlvbi5uYW1lLCBjYWxsYWJsZVRvb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWZjVG9vbHM7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NBZmNTdHJlYW0ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtYXhSZW1vdGVDYWxscyA9IChfYyA9IChfYiA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXhpbXVtUmVtb3RlQ2FsbHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IERFRkFVTFRfTUFYX1JFTU9URV9DQUxMUztcbiAgICAgICAgbGV0IHdlcmVGdW5jdGlvbnNDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlbW90ZUNhbGxDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IGFmY1Rvb2xzTWFwID0gYXdhaXQgdGhpcy5pbml0QWZjVG9vbHNNYXAocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAobW9kZWxzLCBhZmNUb29scywgcGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYywgZV8xLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlbW90ZUNhbGxDb3VudCA8IG1heFJlbW90ZUNhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3ZXJlRnVuY3Rpb25zQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVDYWxsQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlcmVGdW5jdGlvbnNDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IHlpZWxkIF9fYXdhaXQobW9kZWxzLnByb2Nlc3NQYXJhbXNNYXliZUFkZE1jcFVzYWdlKHBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIF9fYXdhaXQobW9kZWxzLmdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gdHJ1ZSwgcmVzcG9uc2VfMSA9IChlXzEgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMocmVzcG9uc2UpKSwgcmVzcG9uc2VfMV8xOyByZXNwb25zZV8xXzEgPSB5aWVsZCBfX2F3YWl0KHJlc3BvbnNlXzEubmV4dCgpKSwgX2MgPSByZXNwb25zZV8xXzEuZG9uZSwgIV9jOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZSA9IHJlc3BvbnNlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLmNhbmRpZGF0ZXMgJiYgKChfYSA9IGNodW5rLmNhbmRpZGF0ZXNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUNvbnRlbnRzLnB1c2goY2h1bmsuY2FuZGlkYXRlc1swXS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfYiA9IGNodW5rLmNhbmRpZGF0ZXNbMF0uY29udGVudC5wYXJ0cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdGVDYWxsQ291bnQgPCBtYXhSZW1vdGVDYWxscyAmJiBwYXJ0LmZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFydC5mdW5jdGlvbkNhbGwubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNhbGwgbmFtZSB3YXMgbm90IHJldHVybmVkIGJ5IHRoZSBtb2RlbC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZmNUb29scy5oYXMocGFydC5mdW5jdGlvbkNhbGwubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyB3YXMgcmVxdWVzdGVkLCBidXQgbm90IGFsbCB0aGUgdG9vbHMgdGhlIG1vZGVsIHVzZWQgaW1wbGVtZW50IHRoZSBDYWxsYWJsZVRvb2wgaW50ZXJmYWNlLiBBdmFpbGFibGUgdG9vbHM6ICR7YWZjVG9vbHMua2V5cygpfSwgbWlzaW5nIHRvb2w6ICR7cGFydC5mdW5jdGlvbkNhbGwubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUGFydHMgPSB5aWVsZCBfX2F3YWl0KGFmY1Rvb2xzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KHBhcnQuZnVuY3Rpb25DYWxsLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2FsbFRvb2woW3BhcnQuZnVuY3Rpb25DYWxsXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlcy5wdXNoKC4uLnJlc3BvbnNlUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2MgJiYgKF9kID0gcmVzcG9uc2VfMS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9kLmNhbGwocmVzcG9uc2VfMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvblJlc3BvbnNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZXJlRnVuY3Rpb25zQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcG9uc2VDaHVuayA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWRSZXNwb25zZUNodW5rLmNhbmRpZGF0ZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czogZnVuY3Rpb25SZXNwb25zZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcG9uc2VDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudHMucHVzaCguLi5yZXNwb25zZUNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czogZnVuY3Rpb25SZXNwb25zZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRDb250ZW50cyA9IHRDb250ZW50cyhwYXJhbXMuY29udGVudHMpLmNvbmNhdChuZXdDb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY29udGVudHMgPSB1cGRhdGVkQ29udGVudHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSh0aGlzLCBhZmNUb29sc01hcCwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Z2VuZXJhdGVDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpnZW5lcmF0ZUNvbnRlbnQnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUNvbnRlbnRTdHJlYW1JbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpzdHJlYW1HZW5lcmF0ZUNvbnRlbnQ/YWx0PXNzZScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGNvbnN0IGFwaUNsaWVudCA9IHRoaXMuYXBpQ2xpZW50O1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhcGlDbGllbnQucmVxdWVzdFN0cmVhbSh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oZnVuY3Rpb24gKGFwaVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBhcGlSZXNwb25zZV8xID0gX19hc3luY1ZhbHVlcyhhcGlSZXNwb25zZSksIGFwaVJlc3BvbnNlXzFfMTsgYXBpUmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChhcGlSZXNwb25zZV8xLm5leHQoKSksIF9hID0gYXBpUmVzcG9uc2VfMV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBhcGlSZXNwb25zZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoKHlpZWxkIF9fYXdhaXQoY2h1bmsuanNvbigpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BbJ3Nka0h0dHBSZXNwb25zZSddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBjaHVuay5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQodHlwZWRSZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gYXBpUmVzcG9uc2VfMS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoYXBpUmVzcG9uc2VfMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06c3RyZWFtR2VuZXJhdGVDb250ZW50P2FsdD1zc2UnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXBpQ2xpZW50LnJlcXVlc3RTdHJlYW0oe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKGZ1bmN0aW9uIChhcGlSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBlXzMsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgYXBpUmVzcG9uc2VfMiA9IF9fYXN5bmNWYWx1ZXMoYXBpUmVzcG9uc2UpLCBhcGlSZXNwb25zZV8yXzE7IGFwaVJlc3BvbnNlXzJfMSA9IHlpZWxkIF9fYXdhaXQoYXBpUmVzcG9uc2VfMi5uZXh0KCkpLCBfYSA9IGFwaVJlc3BvbnNlXzJfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gYXBpUmVzcG9uc2VfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoKHlpZWxkIF9fYXdhaXQoY2h1bmsuanNvbigpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BbJ3Nka0h0dHBSZXNwb25zZSddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBjaHVuay5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQodHlwZWRSZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gYXBpUmVzcG9uc2VfMi5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoYXBpUmVzcG9uc2VfMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGVtYmVkZGluZ3MgZm9yIHRoZSBnaXZlbiBjb250ZW50cy4gT25seSB0ZXh0IGlzIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZW1iZWRkaW5nIGNvbnRlbnRzLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5lbWJlZENvbnRlbnQoe1xuICAgICAqICBtb2RlbDogJ3RleHQtZW1iZWRkaW5nLTAwNCcsXG4gICAgICogIGNvbnRlbnRzOiBbXG4gICAgICogICAgJ1doYXQgaXMgeW91ciBuYW1lPycsXG4gICAgICogICAgJ1doYXQgaXMgeW91ciBmYXZvcml0ZSBjb2xvcj8nLFxuICAgICAqICBdLFxuICAgICAqICBjb25maWc6IHtcbiAgICAgKiAgICBvdXRwdXREaW1lbnNpb25hbGl0eTogNjQsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGVtYmVkQ29udGVudChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRW1iZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpiYXRjaEVtYmVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBlbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVtYmVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCBmb3IgZ2VuZXJhdGluZyBpbWFnZXMuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVJbWFnZXNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgZm9yIGVkaXRpbmcgYW4gaW1hZ2UuXG4gICAgICovXG4gICAgYXN5bmMgZWRpdEltYWdlSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlZGl0SW1hZ2VQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGVkaXRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVkaXRJbWFnZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCBmb3IgdXBzY2FsaW5nIGFuIGltYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHVwc2NhbGVJbWFnZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBzY2FsZUltYWdlQVBJUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB1cHNjYWxlSW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBVcHNjYWxlSW1hZ2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb250ZXh0dWFsaXplcyBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSB0d28gdHlwZXMgb2YgcmVjb250ZXh0dWFsaXphdGlvbiBjdXJyZW50bHkgc3VwcG9ydGVkOlxuICAgICAqIDEpIEltYWdlbiBQcm9kdWN0IFJlY29udGV4dCAtIEdlbmVyYXRlIGltYWdlcyBvZiBwcm9kdWN0cyBpbiBuZXcgc2NlbmVzXG4gICAgICogICAgYW5kIGNvbnRleHRzLlxuICAgICAqIDIpIFZpcnR1YWwgVHJ5LU9uOiBHZW5lcmF0ZSBpbWFnZXMgb2YgcGVyc29ucyBtb2RlbGluZyBmYXNoaW9uIHByb2R1Y3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciByZWNvbnRleHR1YWxpemluZyBhbiBpbWFnZS5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UxID0gYXdhaXQgYWkubW9kZWxzLnJlY29udGV4dEltYWdlKHtcbiAgICAgKiAgbW9kZWw6ICdpbWFnZW4tcHJvZHVjdC1yZWNvbnRleHQtcHJldmlldy0wNi0zMCcsXG4gICAgICogIHNvdXJjZToge1xuICAgICAqICAgIHByb21wdDogJ0luIGEgbW9kZXJuIGtpdGNoZW4gc2V0dGluZy4nLFxuICAgICAqICAgIHByb2R1Y3RJbWFnZXM6IFtwcm9kdWN0SW1hZ2VdLFxuICAgICAqICB9LFxuICAgICAqICBjb25maWc6IHtcbiAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZTE/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZTIgPSBhd2FpdCBhaS5tb2RlbHMucmVjb250ZXh0SW1hZ2Uoe1xuICAgICAqICBtb2RlbDogJ3ZpcnR1YWwtdHJ5LW9uLXByZXZpZXctMDgtMDQnLFxuICAgICAqICBzb3VyY2U6IHtcbiAgICAgKiAgICBwZXJzb25JbWFnZTogcGVyc29uSW1hZ2UsXG4gICAgICogICAgcHJvZHVjdEltYWdlczogW3Byb2R1Y3RJbWFnZV0sXG4gICAgICogIH0sXG4gICAgICogIGNvbmZpZzoge1xuICAgICAqICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlMj8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyByZWNvbnRleHRJbWFnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHJlY29udGV4dEltYWdlUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSByZWNvbnRleHRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IFJlY29udGV4dEltYWdlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlZ21lbnRzIGFuIGltYWdlLCBjcmVhdGluZyBhIG1hc2sgb2YgYSBzcGVjaWZpZWQgYXJlYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3Igc2VnbWVudGluZyBhbiBpbWFnZS5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuc2VnbWVudEltYWdlKHtcbiAgICAgKiAgbW9kZWw6ICdpbWFnZS1zZWdtZW50YXRpb24tMDAxJyxcbiAgICAgKiAgc291cmNlOiB7XG4gICAgICogICAgaW1hZ2U6IGltYWdlLFxuICAgICAqICB9LFxuICAgICAqICBjb25maWc6IHtcbiAgICAgKiAgICBtb2RlOiAnZm9yZWdyb3VuZCcsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2U/LmdlbmVyYXRlZE1hc2tzPy5bMF0/Lm1hc2s/LmltYWdlQnl0ZXMpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNlZ21lbnRJbWFnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHNlZ21lbnRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gc2VnbWVudEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgU2VnbWVudEltYWdlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgaW5mb3JtYXRpb24gYWJvdXQgYSBtb2RlbCBieSBuYW1lLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IG1vZGVsSW5mbyA9IGF3YWl0IGFpLm1vZGVscy5nZXQoe21vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCd9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRNb2RlbFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbHNfdXJsfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RNb2RlbHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsc191cmx9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0TW9kZWxzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0TW9kZWxzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSB0dW5lZCBtb2RlbCBieSBpdHMgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdXBkYXRpbmcgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy51cGRhdGUoe1xuICAgICAqICAgbW9kZWw6ICd0dW5lZC1tb2RlbC1uYW1lJyxcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICBkaXNwbGF5TmFtZTogJ05ldyBkaXNwbGF5IG5hbWUnLFxuICAgICAqICAgICBkZXNjcmlwdGlvbjogJ05ldyBkZXNjcmlwdGlvbicsXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgdHVuZWQgbW9kZWwgYnkgaXRzIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGRlbGV0aW5nIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZGVsZXRlKHttb2RlbDogJ3R1bmVkLW1vZGVsLW5hbWUnfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVNb2RlbFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVNb2RlbFJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlTW9kZWxSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBnaXZlbiBjb250ZW50cy4gTXVsdGltb2RhbCBpbnB1dCBpc1xuICAgICAqIHN1cHBvcnRlZCBmb3IgR2VtaW5pIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY291bnRpbmcgdG9rZW5zLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5jb3VudFRva2Vucyh7XG4gICAgICogIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogIGNvbnRlbnRzOiAnVGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNvdW50VG9rZW5zKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjb3VudFRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Y291bnRUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENvdW50VG9rZW5zUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmNvdW50VG9rZW5zJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY291bnRUb2tlbnNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENvdW50VG9rZW5zUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgbGlzdCBvZiBjb250ZW50cywgcmV0dXJucyBhIGNvcnJlc3BvbmRpbmcgVG9rZW5zSW5mbyBjb250YWluaW5nXG4gICAgICogdGhlIGxpc3Qgb2YgdG9rZW5zIGFuZCBsaXN0IG9mIHRva2VuIGlkcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjb21wdXRpbmcgdG9rZW5zLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5jb21wdXRlVG9rZW5zKHtcbiAgICAgKiAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgY29udGVudHM6ICdXaGF0IGlzIHlvdXIgbmFtZT8nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNvbXB1dGVUb2tlbnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjb21wdXRlVG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpjb21wdXRlVG9rZW5zJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY29tcHV0ZVRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENvbXB1dGVUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgZm9yIGdlbmVyYXRpbmcgdmlkZW9zLlxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlVmlkZW9zSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0TG9uZ1J1bm5pbmcnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0TG9uZ1J1bm5pbmcnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBPcGVyYXRpb25zIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0dXMgb2YgYSBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgb3BlcmF0aW9uIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgdXBkYXRlZCBPcGVyYXRpb24gb2JqZWN0LCB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIG9yIHJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRWaWRlb3NPcGVyYXRpb24ocGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBwYXJhbWV0ZXJzLm9wZXJhdGlvbjtcbiAgICAgICAgY29uc3QgY29uZmlnID0gcGFyYW1ldGVycy5jb25maWc7XG4gICAgICAgIGlmIChvcGVyYXRpb24ubmFtZSA9PT0gdW5kZWZpbmVkIHx8IG9wZXJhdGlvbi5uYW1lID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gbmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvdXJjZU5hbWUgPSBvcGVyYXRpb24ubmFtZS5zcGxpdCgnL29wZXJhdGlvbnMvJylbMF07XG4gICAgICAgICAgICBsZXQgaHR0cE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29uZmlnICYmICdodHRwT3B0aW9ucycgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSBjb25maWcuaHR0cE9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICByZXNvdXJjZU5hbWU6IHJlc291cmNlTmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IHsgaHR0cE9wdGlvbnM6IGh0dHBPcHRpb25zIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24uX2Zyb21BUElSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgYXBpUmVzcG9uc2U6IHJhd09wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBpc1ZlcnRleEFJOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmdldFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5fZnJvbUFQSVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBhcGlSZXNwb25zZTogcmF3T3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIGlzVmVydGV4QUk6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdHVzIG9mIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IG9wZXJhdGlvbiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgT3BlcmF0aW9uIG9iamVjdCwgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBvciByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcGFyYW1ldGVycy5vcGVyYXRpb247XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHBhcmFtZXRlcnMuY29uZmlnO1xuICAgICAgICBpZiAob3BlcmF0aW9uLm5hbWUgPT09IHVuZGVmaW5lZCB8fCBvcGVyYXRpb24ubmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb3VyY2VOYW1lID0gb3BlcmF0aW9uLm5hbWUuc3BsaXQoJy9vcGVyYXRpb25zLycpWzBdO1xuICAgICAgICAgICAgbGV0IGh0dHBPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNvbmZpZyAmJiAnaHR0cE9wdGlvbnMnIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zID0gY29uZmlnLmh0dHBPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3T3BlcmF0aW9uID0gYXdhaXQgdGhpcy5mZXRjaFByZWRpY3RWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VOYW1lOiByZXNvdXJjZU5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlnOiB7IGh0dHBPcHRpb25zOiBodHRwT3B0aW9ucyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLl9mcm9tQVBJUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlOiByYXdPcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgaXNWZXJ0ZXhBSTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmF3T3BlcmF0aW9uID0gYXdhaXQgdGhpcy5nZXRWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24uX2Zyb21BUElSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgYXBpUmVzcG9uc2U6IHJhd09wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBpc1ZlcnRleEFJOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFZpZGVvc09wZXJhdGlvbkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tvcGVyYXRpb25OYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne29wZXJhdGlvbk5hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZmV0Y2hQcmVkaWN0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7cmVzb3VyY2VOYW1lfTpmZXRjaFByZWRpY3RPcGVyYXRpb24nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb01sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXV0aFRva2VuRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvblRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc2FibGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNhYmxlZCddKTtcbiAgICBpZiAoZnJvbURpc2FibGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzYWJsZWQnXSwgZnJvbURpc2FibGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHknXSwgZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5kT2ZTcGVlY2hTZW5zaXRpdml0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2ZTcGVlY2hTZW5zaXRpdml0eSddLCBmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVmaXhQYWRkaW5nTXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVmaXhQYWRkaW5nTXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlZml4UGFkZGluZ01zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlZml4UGFkZGluZ01zJ10sIGZyb21QcmVmaXhQYWRkaW5nTXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2lsZW5jZUR1cmF0aW9uTXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzaWxlbmNlRHVyYXRpb25NcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TaWxlbmNlRHVyYXRpb25NcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NpbGVuY2VEdXJhdGlvbk1zJ10sIGZyb21TaWxlbmNlRHVyYXRpb25Ncyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZXJVc2VUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FbnZpcm9ubWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW52aXJvbm1lbnQnXSk7XG4gICAgaWYgKGZyb21FbnZpcm9ubWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vudmlyb25tZW50J10sIGZyb21FbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zJ10sIGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRleHRXaW5kb3dDb21wcmVzc2lvbkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRyaWdnZXJUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0cmlnZ2VyVG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyaWdnZXJUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cmlnZ2VyVG9rZW5zJ10sIGZyb21UcmlnZ2VyVG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNsaWRpbmdXaW5kb3cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzbGlkaW5nV2luZG93JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNsaWRpbmdXaW5kb3cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzbGlkaW5nV2luZG93J10sIHNsaWRpbmdXaW5kb3dUb01sZGV2KGZyb21TbGlkaW5nV2luZG93KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUF1dGhUb2tlbkNvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5ld1Nlc3Npb25FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV3U2Vzc2lvbkV4cGlyZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbmV3U2Vzc2lvbkV4cGlyZVRpbWUnXSwgZnJvbU5ld1Nlc3Npb25FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VzZXMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Vc2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3VzZXMnXSwgZnJvbVVzZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGl2ZUNvbm5lY3RDb25zdHJhaW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xpdmVDb25uZWN0Q29uc3RyYWludHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGl2ZUNvbm5lY3RDb25zdHJhaW50cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXSwgbGl2ZUNvbm5lY3RDb25zdHJhaW50c1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tTGl2ZUNvbm5lY3RDb25zdHJhaW50cykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsb2NrQWRkaXRpb25hbEZpZWxkcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Mb2NrQWRkaXRpb25hbEZpZWxkcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydmaWVsZE1hc2snXSwgZnJvbUxvY2tBZGRpdGlvbmFsRmllbGRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQXV0aFRva2VuUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgY3JlYXRlQXV0aFRva2VuQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHluYW1pY1RocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1RocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNUaHJlc2hvbGQnXSwgZnJvbUR5bmFtaWNUaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJlaGF2aW9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKTtcbiAgICBpZiAoZnJvbUJlaGF2aW9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmVoYXZpb3InXSwgZnJvbUJlaGF2aW9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1JldHJpZXZhbENvbmZpZyddLCBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldihmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGludGVydmFsVG9NbGRldihmcm9tVGltZVJhbmdlRmlsdGVyKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbnRlcnZhbFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBmcm9tR2VuZXJhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb01sZGV2KHRMaXZlU3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGhpbmtpbmdDb25maWcnXSwgdGhpbmtpbmdDb25maWdUb01sZGV2KGZyb21UaGlua2luZ0NvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZyddLCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvTWxkZXYodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldihmcm9tU2Vzc2lvblJlc3VtcHRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9NbGRldigpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvTWxkZXYoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWFsdGltZUlucHV0Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVhbHRpbWVJbnB1dENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWFsdGltZUlucHV0Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3JlYWx0aW1lSW5wdXRDb25maWcnXSwgcmVhbHRpbWVJbnB1dENvbmZpZ1RvTWxkZXYoZnJvbVJlYWx0aW1lSW5wdXRDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJ10sIGNvbnRleHRXaW5kb3dDb21wcmVzc2lvbkNvbmZpZ1RvTWxkZXYoZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvYWN0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb2FjdGl2aXR5J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvYWN0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncHJvYWN0aXZpdHknXSwgcHJvYWN0aXZpdHlDb25maWdUb01sZGV2KGZyb21Qcm9hY3Rpdml0eSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdENvbnN0cmFpbnRzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGl2ZUNvbm5lY3RDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3BlYWtlclZvaWNlQ29uZmlncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NwZWFrZXJWb2ljZUNvbmZpZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3BlYWtlclZvaWNlQ29uZmlncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU3BlYWtlclZvaWNlQ29uZmlncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVha2VyVm9pY2VDb25maWdUb01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlYWtlclZvaWNlQ29uZmlncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YVRvTWxkZXYoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldihmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlTmFtZSddKTtcbiAgICBpZiAoZnJvbVZvaWNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlTmFtZSddLCBmcm9tVm9pY2VOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJvYWN0aXZpdHlDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9hY3RpdmVBdWRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb2FjdGl2ZUF1ZGlvJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb2FjdGl2ZUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvYWN0aXZlQXVkaW8nXSwgZnJvbVByb2FjdGl2ZUF1ZGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVhbHRpbWVJbnB1dENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiddLCBhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvblRvTWxkZXYoZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eUhhbmRsaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWN0aXZpdHlIYW5kbGluZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eUhhbmRsaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlIYW5kbGluZyddLCBmcm9tQWN0aXZpdHlIYW5kbGluZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ292ZXJhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1cm5Db3ZlcmFnZSddKTtcbiAgICBpZiAoZnJvbVR1cm5Db3ZlcmFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1cm5Db3ZlcmFnZSddLCBmcm9tVHVybkNvdmVyYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21IYW5kbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2hhbmRsZSddKTtcbiAgICBpZiAoZnJvbUhhbmRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2hhbmRsZSddLCBmcm9tSGFuZGxlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJhbnNwYXJlbnQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zcGFyZW50IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNsaWRpbmdXaW5kb3dUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXJnZXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RhcmdldFRva2VucyddKTtcbiAgICBpZiAoZnJvbVRhcmdldFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RhcmdldFRva2VucyddLCBmcm9tVGFyZ2V0VG9rZW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3BlYWtlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlYWtlciddKTtcbiAgICBpZiAoZnJvbVNwZWFrZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVha2VyJ10sIGZyb21TcGVha2VyKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2KGZyb21Wb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21Wb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10sIHZvaWNlQ29uZmlnVG9NbGRldihmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyddLCBtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdGhpbmtpbmdDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbmNsdWRlVGhvdWdodHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlVGhvdWdodHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5jbHVkZVRob3VnaHRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5jbHVkZVRob3VnaHRzJ10sIGZyb21JbmNsdWRlVGhvdWdodHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdCdWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0J1ZGdldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0J1ZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQnVkZ2V0J10sIGZyb21UaGlua2luZ0J1ZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2KGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldihmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ29vZ2xlTWFwcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIHVybENvbnRleHRUb01sZGV2KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBjb21wdXRlclVzZVRvTWxkZXYoZnJvbUNvbXB1dGVyVXNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRUb01sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZvaWNlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWJ1aWx0Vm9pY2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWJ1aWx0Vm9pY2VDb25maWcnXSwgcHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIFJldHVybnMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBmaWVsZCBtYXNrcyBmcm9tIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBzZXR1cCBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgZmllbGQgbWFza3MgZnJvbS5cbiAqIEByZXR1cm4gQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBmaWVsZCBtYXNrcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RmllbGRNYXNrcyhzZXR1cCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNldHVwKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dXAsIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc2V0dXBba2V5XTtcbiAgICAgICAgICAgIC8vIDJuZCBsYXllciwgcmVjdXJzaXZlbHkgZ2V0IGZpZWxkIG1hc2tzIHNlZSBUT0RPKGIvNDE4MjkwMTAwKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKGtrKSA9PiBgJHtrZXl9LiR7a2t9YCk7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goLi4uZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goa2V5KTsgLy8gMXN0IGxheWVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcy5qb2luKCcsJyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cC5cbiAqIEBwYXJhbSByZXF1ZXN0RGljdCAtIFRoZSByZXF1ZXN0IGRpY3Rpb25hcnkuXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICogQHJldHVybiAtIFRoZSBtb2RpZmllZCByZXF1ZXN0IGRpY3Rpb25hcnkuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRCaWRpU2V0dXBUb1Rva2VuU2V0dXAocmVxdWVzdERpY3QsIGNvbmZpZykge1xuICAgIC8vIENvbnZlcnQgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwIGZyb20gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwLnNldHVwLlxuICAgIGxldCBzZXR1cEZvck1hc2tHZW5lcmF0aW9uID0gbnVsbDtcbiAgICBjb25zdCBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSA9IHJlcXVlc3REaWN0WydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXTtcbiAgICBpZiAodHlwZW9mIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAnc2V0dXAnIGluIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlKSB7XG4gICAgICAgIC8vIE5vdyB3ZSBrbm93IGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlIGlzIGFuIG9iamVjdCBhbmQgaGFzIGEgJ3NldHVwJ1xuICAgICAgICAvLyBwcm9wZXJ0eS5cbiAgICAgICAgY29uc3QgaW5uZXJTZXR1cCA9IGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlXG4gICAgICAgICAgICAuc2V0dXA7XG4gICAgICAgIGlmICh0eXBlb2YgaW5uZXJTZXR1cCA9PT0gJ29iamVjdCcgJiYgaW5uZXJTZXR1cCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVmFsaWQgaW5uZXIgc2V0dXAgZm91bmQuXG4gICAgICAgICAgICByZXF1ZXN0RGljdFsnYmlkaUdlbmVyYXRlQ29udGVudFNldHVwJ10gPSBpbm5lclNldHVwO1xuICAgICAgICAgICAgc2V0dXBGb3JNYXNrR2VuZXJhdGlvbiA9IGlubmVyU2V0dXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUuc2V0dXBgIGlzIG5vdCBhIHZhbGlkIG9iamVjdDsgdHJlYXQgYXNcbiAgICAgICAgICAgIC8vIGlmIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCBpcyBpbnZhbGlkLlxuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBgIGV4aXN0cyBidXQgbm90IGluIHRoZSBleHBlY3RlZFxuICAgICAgICAvLyBzaGFwZSB7c2V0dXA6IHsuLi59fTsgdHJlYXQgYXMgaW52YWxpZC5cbiAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXTtcbiAgICB9XG4gICAgY29uc3QgcHJlRXhpc3RpbmdGaWVsZE1hc2sgPSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgLy8gSGFuZGxlIG1hc2sgZ2VuZXJhdGlvbiBzZXR1cC5cbiAgICBpZiAoc2V0dXBGb3JNYXNrR2VuZXJhdGlvbikge1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWRNYXNrRnJvbUJpZGkgPSBnZXRGaWVsZE1hc2tzKHNldHVwRm9yTWFza0dlbmVyYXRpb24pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHMpICYmXG4gICAgICAgICAgICAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIENhc2UgMTogbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXMgYW4gZW1wdHkgYXJyYXkuIExvY2sgb25seSBmaWVsZHMgZnJvbVxuICAgICAgICAgICAgLy8gYmlkaSBzZXR1cC5cbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRNYXNrRnJvbUJpZGkpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFzc2lnbiBpZiBtYXNrIGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgICAgIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXSA9IGdlbmVyYXRlZE1hc2tGcm9tQmlkaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107IC8vIElmIG1hc2sgaXMgZW1wdHksIGVmZmVjdGl2ZWx5IG5vXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgZmllbGRzIGxvY2tlZCBieSBiaWRpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkcykgJiZcbiAgICAgICAgICAgIGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBwcmVFeGlzdGluZ0ZpZWxkTWFzayAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShwcmVFeGlzdGluZ0ZpZWxkTWFzaykgJiZcbiAgICAgICAgICAgIHByZUV4aXN0aW5nRmllbGRNYXNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIENhc2UgMjogTG9jayBmaWVsZHMgZnJvbSBiaWRpIHNldHVwICsgYWRkaXRpb25hbCBmaWVsZHNcbiAgICAgICAgICAgIC8vIChwcmVFeGlzdGluZ0ZpZWxkTWFzaykuXG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0aW9uQ29uZmlnRmllbGRzID0gW1xuICAgICAgICAgICAgICAgICd0ZW1wZXJhdHVyZScsXG4gICAgICAgICAgICAgICAgJ3RvcEsnLFxuICAgICAgICAgICAgICAgICd0b3BQJyxcbiAgICAgICAgICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICAgICAgICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICAgICAgICAgICAgICAnc2VlZCcsXG4gICAgICAgICAgICAgICAgJ3NwZWVjaENvbmZpZycsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgbGV0IG1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByZUV4aXN0aW5nRmllbGRNYXNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmcgPSBwcmVFeGlzdGluZ0ZpZWxkTWFzay5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0aW9uQ29uZmlnRmllbGRzLmluY2x1ZGVzKGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBnZW5lcmF0aW9uQ29uZmlnLiR7ZmllbGR9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQ7IC8vIEtlZXAgb3JpZ2luYWwgZmllbGQgbmFtZSBpZiBub3QgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGlvbkNvbmZpZ0ZpZWxkc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmluYWxNYXNrUGFydHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRNYXNrRnJvbUJpZGkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbE1hc2tQYXJ0cy5wdXNoKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaW5hbE1hc2tQYXJ0cy5wdXNoKC4uLm1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmluYWxNYXNrUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXSA9IGZpbmFsTWFza1BhcnRzLmpvaW4oJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIGZpZWxkcyBmcm9tIGJpZGkgYW5kIG5vIHZhbGlkIGFkZGl0aW9uYWwgZmllbGRzIGZyb21cbiAgICAgICAgICAgICAgICAvLyBwcmUtZXhpc3RpbmcgbWFzay5cbiAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FzZSAzOiBcIkxvY2sgYWxsIGZpZWxkc1wiIChtZWFuaW5nLCBkb24ndCBzZW5kIGEgZmllbGRfbWFzaywgbGV0IHNlcnZlclxuICAgICAgICAgICAgLy8gZGVmYXVsdHMgYXBwbHkgb3IgYWxsIGFyZSBtdXRhYmxlKS4gVGhpcyBpcyBoaXQgaWY6XG4gICAgICAgICAgICAvLyAgLSBgY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzYCBpcyB1bmRlZmluZWQuXG4gICAgICAgICAgICAvLyAgLSBgY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzYCBpcyBub24tZW1wdHksIEJVVFxuICAgICAgICAgICAgLy8gIGBwcmVFeGlzdGluZ0ZpZWxkTWFza2AgaXMgbnVsbCwgbm90IGEgc3RyaW5nLCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBObyB2YWxpZCBgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwYCB3YXMgZm91bmQgb3IgZXh0cmFjdGVkLlxuICAgICAgICAvLyBcIkxvY2sgYWRkaXRpb25hbCBudWxsIGZpZWxkcyBpZiBhbnlcIi5cbiAgICAgICAgaWYgKHByZUV4aXN0aW5nRmllbGRNYXNrICE9PSBudWxsICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByZUV4aXN0aW5nRmllbGRNYXNrKSAmJlxuICAgICAgICAgICAgcHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHByZS1leGlzdGluZyBmaWVsZCBtYXNrLCBpdCdzIGEgc3RyaW5nLCBhbmQgaXQncyBub3RcbiAgICAgICAgICAgIC8vIGVtcHR5LCB0aGVuIHdlIHNob3VsZCBsb2NrIGFsbCBmaWVsZHMuXG4gICAgICAgICAgICByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ10gPSBwcmVFeGlzdGluZ0ZpZWxkTWFzay5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0RGljdDtcbn1cbmNsYXNzIFRva2VucyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlcGhlbWVyYWwgYXV0aCB0b2tlbiByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRXBoZW1lcmFsIGF1dGggdG9rZW5zIGlzIG9ubHkgc3VwcG9ydGVkIGluIHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS5cbiAgICAgKiBJdCBjYW4gYmUgdXNlZCBmb3IgdGhlIHNlc3Npb24gY29ubmVjdGlvbiB0byB0aGUgTGl2ZSBjb25zdHJhaW5lZCBBUEkuXG4gICAgICogU3VwcG9ydCBpbiB2MWFscGhhIG9ubHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjcmVhdGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGF1dGggdG9rZW4uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgYWkgPSBuZXcgR29vZ2xlR2VuQUkoe1xuICAgICAqICAgICBhcGlLZXk6IHRva2VuLm5hbWUsXG4gICAgICogICAgIGh0dHBPcHRpb25zOiB7IGFwaVZlcnNpb246ICd2MWFscGhhJyB9ICAvLyBTdXBwb3J0IGluIHYxYWxwaGEgb25seS5cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIENhc2UgMTogSWYgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnMgaXMgdW5zZXQsIHVubG9jayBMaXZlQ29ubmVjdENvbmZpZ1xuICAgICAqIC8vIHdoZW4gdXNpbmcgdGhlIHRva2VuIGluIExpdmUgQVBJIHNlc3Npb25zLiBFYWNoIHNlc3Npb24gY29ubmVjdGlvbiBjYW5cbiAgICAgKiAvLyB1c2UgYSBkaWZmZXJlbnQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9IHtcbiAgICAgKiAgICAgdXNlczogMyxcbiAgICAgKiAgICAgZXhwaXJlVGltZTogJzIwMjUtMDUtMDFUMDA6MDA6MDBaJyxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDI6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCwgbG9jayBhbGwgZmllbGRzIGluXG4gICAgICogLy8gTGl2ZUNvbm5lY3RDb25maWcgd2hlbiB1c2luZyB0aGUgdG9rZW4gaW4gTGl2ZSBBUEkgc2Vzc2lvbnMuIEZvclxuICAgICAqIC8vIGV4YW1wbGUsIGNoYW5naW5nIGBvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb25gIGluIHRoZSBMaXZlIEFQSVxuICAgICAqIC8vIGNvbm5lY3Rpb24gd2lsbCBiZSBpZ25vcmVkIGJ5IHRoZSBBUEkuXG4gICAgICogY29uc3QgY29uZmlnOiBDcmVhdGVBdXRoVG9rZW5Db25maWcgPVxuICAgICAqICAgICB1c2VzOiAzLFxuICAgICAqICAgICBleHBpcmVUaW1lOiAnMjAyNS0wNS0wMVQwMDowMDowMFonLFxuICAgICAqICAgICBMaXZlRXBoZW1lcmFsUGFyYW1ldGVyczoge1xuICAgICAqICAgICAgICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gtMDAxJyxcbiAgICAgKiAgICAgICAgY29uZmlnOiB7XG4gICAgICogICAgICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnOiBbJ0FVRElPJ10sXG4gICAgICogICAgICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbic6ICdBbHdheXMgYW5zd2VyIGluIEVuZ2xpc2guJyxcbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqIGNvbnN0IHRva2VuID0gYXdhaXQgYWkudG9rZW5zLmNyZWF0ZShjb25maWcpO1xuICAgICAqXG4gICAgICogLy8gQ2FzZSAzOiBJZiBMaXZlRXBoZW1lcmFsUGFyYW1ldGVycyBpcyBzZXQgYW5kIGxvY2tBZGRpdGlvbmFsRmllbGRzIGlzXG4gICAgICogLy8gc2V0LCBsb2NrIExpdmVDb25uZWN0Q29uZmlnIHdpdGggc2V0IGFuZCBhZGRpdGlvbmFsIGZpZWxkcyAoZS5nLlxuICAgICAqIC8vIHJlc3BvbnNlTW9kYWxpdGllcywgc3lzdGVtSW5zdHJ1Y3Rpb24sIHRlbXBlcmF0dXJlIGluIHRoaXMgZXhhbXBsZSkgd2hlblxuICAgICAqIC8vIHVzaW5nIHRoZSB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGxvY2tBZGRpdGlvbmFsRmllbGRzOiBbJ3RlbXBlcmF0dXJlJ10sXG4gICAgICogfVxuICAgICAqIGNvbnN0IHRva2VuID0gYXdhaXQgYWkudG9rZW5zLmNyZWF0ZShjb25maWcpO1xuICAgICAqXG4gICAgICogLy8gQ2FzZSA0OiBJZiBMaXZlRXBoZW1lcmFsUGFyYW1ldGVycyBpcyBzZXQgYW5kIGxvY2tBZGRpdGlvbmFsRmllbGRzIGlzXG4gICAgICogLy8gZW1wdHkgYXJyYXksIGxvY2sgTGl2ZUNvbm5lY3RDb25maWcgd2l0aCBzZXQgZmllbGRzIChlLmcuXG4gICAgICogLy8gcmVzcG9uc2VNb2RhbGl0aWVzLCBzeXN0ZW1JbnN0cnVjdGlvbiBpbiB0aGlzIGV4YW1wbGUpIHdoZW4gdXNpbmcgdGhlXG4gICAgICogLy8gdG9rZW4gaW4gTGl2ZSBBUEkgc2Vzc2lvbnMuXG4gICAgICogY29uc3QgY29uZmlnOiBDcmVhdGVBdXRoVG9rZW5Db25maWcgPVxuICAgICAqICAgICB1c2VzOiAzLFxuICAgICAqICAgICBleHBpcmVUaW1lOiAnMjAyNS0wNS0wMVQwMDowMDowMFonLFxuICAgICAqICAgICBMaXZlRXBoZW1lcmFsUGFyYW1ldGVyczoge1xuICAgICAqICAgICAgICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gtMDAxJyxcbiAgICAgKiAgICAgICAgY29uZmlnOiB7XG4gICAgICogICAgICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnOiBbJ0FVRElPJ10sXG4gICAgICogICAgICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbic6ICdBbHdheXMgYW5zd2VyIGluIEVuZ2xpc2guJyxcbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICB9LFxuICAgICAqICAgICBsb2NrQWRkaXRpb25hbEZpZWxkczogW10sXG4gICAgICogfVxuICAgICAqIGNvbnN0IHRva2VuID0gYXdhaXQgYWkudG9rZW5zLmNyZWF0ZShjb25maWcpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2xpZW50LnRva2Vucy5jcmVhdGUgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVBdXRoVG9rZW5QYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2F1dGhfdG9rZW5zJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRCb2R5ID0gY29udmVydEJpZGlTZXR1cFRvVG9rZW5TZXR1cChib2R5LCBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodHJhbnNmb3JtZWRCb2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBhdXRoVG9rZW5Gcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IEdPT0dMRV9BUElfS0VZX0hFQURFUiA9ICd4LWdvb2ctYXBpLWtleSc7XG5jb25zdCBSRVFVSVJFRF9WRVJURVhfQUlfU0NPUEUgPSAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9jbG91ZC1wbGF0Zm9ybSc7XG5jbGFzcyBOb2RlQXV0aCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBpZiAob3B0cy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSBvcHRzLmFwaUtleTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJ0ZXhBdXRoT3B0aW9ucyA9IGJ1aWxkR29vZ2xlQXV0aE9wdGlvbnMob3B0cy5nb29nbGVBdXRoT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ29vZ2xlQXV0aCA9IG5ldyBHb29nbGVBdXRoKHZlcnRleEF1dGhPcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgYWRkQXV0aEhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICBpZiAodGhpcy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpS2V5LnN0YXJ0c1dpdGgoJ2F1dGhfdG9rZW5zLycpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcGhlbWVyYWwgdG9rZW5zIGFyZSBvbmx5IHN1cHBvcnRlZCBieSB0aGUgbGl2ZSBBUEkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZEtleUhlYWRlcihoZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGRHb29nbGVBdXRoSGVhZGVycyhoZWFkZXJzKTtcbiAgICB9XG4gICAgYWRkS2V5SGVhZGVyKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKGhlYWRlcnMuZ2V0KEdPT0dMRV9BUElfS0VZX0hFQURFUikgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcGlLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCB0aGlzIG1ldGhvZCBpcyBvbmx5IGNhbGxlZFxuICAgICAgICAgICAgLy8gd2hlbiBhcGlLZXkgaXMgc2V0LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gc2V0IEFQSSBrZXkgaGVhZGVyIGJ1dCBhcGlLZXkgaXMgbm90IHNldCcpO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKEdPT0dMRV9BUElfS0VZX0hFQURFUiwgdGhpcy5hcGlLZXkpO1xuICAgIH1cbiAgICBhc3luYyBhZGRHb29nbGVBdXRoSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmdvb2dsZUF1dGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBhZGRHb29nbGVBdXRoSGVhZGVycyBzaG91bGQgb25seSBiZVxuICAgICAgICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYXBpS2V5IHNldCBhbmQgaW4gdGhlc2UgY2FzZXMgZ29vZ2xlQXV0aFxuICAgICAgICAgICAgLy8gaXMgc2V0LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gc2V0IGdvb2dsZS1hdXRoIGhlYWRlcnMgYnV0IGdvb2dsZUF1dGggaXMgdW5zZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRoSGVhZGVycyA9IGF3YWl0IHRoaXMuZ29vZ2xlQXV0aC5nZXRSZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdXRoSGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMuZ2V0KGtleSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgYXV0aEhlYWRlcnNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZEdvb2dsZUF1dGhPcHRpb25zKGdvb2dsZUF1dGhPcHRpb25zKSB7XG4gICAgbGV0IGF1dGhPcHRpb25zO1xuICAgIGlmICghZ29vZ2xlQXV0aE9wdGlvbnMpIHtcbiAgICAgICAgYXV0aE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzY29wZXM6IFtSRVFVSVJFRF9WRVJURVhfQUlfU0NPUEVdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXV0aE9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdXRoT3B0aW9ucyA9IGdvb2dsZUF1dGhPcHRpb25zO1xuICAgICAgICBpZiAoIWF1dGhPcHRpb25zLnNjb3Blcykge1xuICAgICAgICAgICAgYXV0aE9wdGlvbnMuc2NvcGVzID0gW1JFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRV07XG4gICAgICAgICAgICByZXR1cm4gYXV0aE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHR5cGVvZiBhdXRoT3B0aW9ucy5zY29wZXMgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBhdXRoT3B0aW9ucy5zY29wZXMgIT09IFJFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRSkgfHxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGF1dGhPcHRpb25zLnNjb3BlcykgJiZcbiAgICAgICAgICAgICAgICBhdXRoT3B0aW9ucy5zY29wZXMuaW5kZXhPZihSRVFVSVJFRF9WRVJURVhfQUlfU0NPUEUpIDwgMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhdXRoIHNjb3Blcy4gU2NvcGVzIG11c3QgaW5jbHVkZTogJHtSRVFVSVJFRF9WRVJURVhfQUlfU0NPUEV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dGhPcHRpb25zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTm9kZURvd25sb2FkZXIge1xuICAgIGFzeW5jIGRvd25sb2FkKHBhcmFtcywgYXBpQ2xpZW50KSB7XG4gICAgICAgIGlmIChwYXJhbXMuZG93bmxvYWRQYXRoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRvd25sb2FkRmlsZShwYXJhbXMsIGFwaUNsaWVudCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3cml0ZXIgPSBjcmVhdGVXcml0ZVN0cmVhbShwYXJhbXMuZG93bmxvYWRQYXRoKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZS5mcm9tV2ViKHJlc3BvbnNlLnJlc3BvbnNlSW50ZXJuYWwuYm9keSkucGlwZSh3cml0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JpdGVGaWxlKHBhcmFtcy5kb3dubG9hZFBhdGgsIHJlc3BvbnNlLCB7IGVuY29kaW5nOiAnYmFzZTY0JyB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB3cml0ZSBmaWxlIHRvICR7cGFyYW1zLmRvd25sb2FkUGF0aH06ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkRmlsZShwYXJhbXMsIGFwaUNsaWVudCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IG5hbWUgPSB0RmlsZU5hbWUocGFyYW1zLmZpbGUpO1xuICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHBhdGg6IGBmaWxlcy8ke25hbWV9OmRvd25sb2FkYCxcbiAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAnYWx0JzogJ21lZGlhJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzR2VuZXJhdGVkVmlkZW8ocGFyYW1zLmZpbGUpKSB7XG4gICAgICAgIGNvbnN0IHZpZGVvQnl0ZXMgPSAoX2MgPSBwYXJhbXMuZmlsZS52aWRlbykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnZpZGVvQnl0ZXM7XG4gICAgICAgIGlmICh0eXBlb2YgdmlkZW9CeXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWRlb0J5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZG93bmxvYWQgZ2VuZXJhdGVkIHZpZGVvLCBVcmkgb3IgdmlkZW9CeXRlcyBub3QgZm91bmQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNWaWRlbyhwYXJhbXMuZmlsZSkpIHtcbiAgICAgICAgY29uc3QgdmlkZW9CeXRlcyA9IHBhcmFtcy5maWxlLnZpZGVvQnl0ZXM7XG4gICAgICAgIGlmICh0eXBlb2YgdmlkZW9CeXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWRlb0J5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZG93bmxvYWQgdmlkZW8sIFVyaSBvciB2aWRlb0J5dGVzIG5vdCBmb3VuZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBmaWxlIHR5cGUnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIE5vZGVXZWJTb2NrZXRGYWN0b3J5IHtcbiAgICBjcmVhdGUodXJsLCBoZWFkZXJzLCBjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlV2ViU29ja2V0KHVybCwgaGVhZGVycywgY2FsbGJhY2tzKTtcbiAgICB9XG59XG5jbGFzcyBOb2RlV2ViU29ja2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMsIGNhbGxiYWNrcykge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMud3MgPSBuZXcgTm9kZVdzLldlYlNvY2tldCh0aGlzLnVybCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gdGhpcy5jYWxsYmFja3Mub25vcGVuO1xuICAgICAgICB0aGlzLndzLm9uZXJyb3IgPSB0aGlzLmNhbGxiYWNrcy5vbmVycm9yO1xuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSB0aGlzLmNhbGxiYWNrcy5vbmNsb3NlO1xuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMuY2FsbGJhY2tzLm9ubWVzc2FnZTtcbiAgICB9XG4gICAgc2VuZChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLndzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzLnNlbmQobWVzc2FnZSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy53cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIEdvb2dsZSBHZW4gQUkgU0RLIGdlbmVyYXRvciBETyBOT1QgRURJVC5cbmZ1bmN0aW9uIGNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmFsaWRhdGlvbkRhdGFzZXQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbGlkYXRpb25EYXRhc2V0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzY3JpcHRpb24gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVwb2NoQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vwb2NoQ291bnQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FcG9jaENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2Vwb2NoQ291bnQnXSwgZnJvbUVwb2NoQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInXSwgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cG9ydExhc3RDaGVja3BvaW50T25seSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkYXB0ZXJTaXplJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGFwdGVyU2l6ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmF0Y2hTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXRjaFNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXRjaFNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnYmF0Y2hTaXplJ10sIGZyb21CYXRjaFNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsZWFybmluZ1JhdGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MZWFybmluZ1JhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlJ10sIGZyb21MZWFybmluZ1JhdGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVscyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WYWxpZGF0aW9uRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZhbGlkYXRpb25EYXRhc2V0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZhbGlkYXRpb25EYXRhc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJ10sIHR1bmluZ1ZhbGlkYXRpb25EYXRhc2V0VG9WZXJ0ZXgoZnJvbVZhbGlkYXRpb25EYXRhc2V0LCB0b09iamVjdCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuZWRNb2RlbERpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dW5lZE1vZGVsRGlzcGxheU5hbWUnXSwgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXBvY2hDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2hDb3VudCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVwb2NoQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2Vwb2NoQ291bnQnXSwgZnJvbUVwb2NoQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlTXVsdGlwbGllciddLCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ2V4cG9ydExhc3RDaGVja3BvaW50T25seSddLCBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkYXB0ZXJTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGFwdGVyU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFkYXB0ZXJTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdhZGFwdGVyU2l6ZSddLCBmcm9tQWRhcHRlclNpemUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXRjaFNpemUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhdGNoU2l6ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xlYXJuaW5nUmF0ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGVhcm5pbmdSYXRlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVUdW5lZE1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVUdW5lZE1vZGVsJ10sIGZyb21QcmVUdW5lZE1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRyYWluaW5nRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RyYWluaW5nRGF0YXNldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UcmFpbmluZ0RhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5pbmdUYXNrJywgJ3RyYWluaW5nRGF0YSddLCB0dW5pbmdEYXRhc2V0VG9NbGRldihmcm9tVHJhaW5pbmdEYXRhc2V0KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVUdW5lZE1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVUdW5lZE1vZGVsJ10sIGZyb21QcmVUdW5lZE1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRyYWluaW5nRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RyYWluaW5nRGF0YXNldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UcmFpbmluZ0RhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICd0cmFpbmluZ0RhdGFzZXRVcmknXSwgdHVuaW5nRGF0YXNldFRvVmVydGV4KGZyb21UcmFpbmluZ0RhdGFzZXQsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdFR1bmluZ0pvYnNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdFR1bmluZ0pvYnNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5pbmdKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dW5lZE1vZGVscyddKTtcbiAgICBpZiAoZnJvbVR1bmluZ0pvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVR1bmluZ0pvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nSm9iRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmluZ0pvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1bmluZ0pvYnMnXSk7XG4gICAgaWYgKGZyb21UdW5pbmdKb2JzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21UdW5pbmdKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmluZ0pvYkZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5pbmdKb2JzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxDaGVja3BvaW50RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2hlY2twb2ludElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaGVja3BvaW50SWQnXSk7XG4gICAgaWYgKGZyb21DaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaGVja3BvaW50SWQnXSwgZnJvbUNoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcG9jaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2gnXSk7XG4gICAgaWYgKGZyb21FcG9jaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vwb2NoJ10sIGZyb21FcG9jaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGVwID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGVwJ10pO1xuICAgIGlmIChmcm9tU3RlcCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0ZXAnXSwgZnJvbVN0ZXApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kcG9pbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZHBvaW50J10pO1xuICAgIGlmIChmcm9tRW5kcG9pbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludCddLCBmcm9tRW5kcG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZHBvaW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tRW5kcG9pbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludCddLCBmcm9tRW5kcG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kcG9pbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZHBvaW50J10pO1xuICAgIGlmIChmcm9tRW5kcG9pbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludCddLCBmcm9tRW5kcG9pbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2hlY2twb2ludHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NoZWNrcG9pbnRzJ10pO1xuICAgIGlmIChmcm9tQ2hlY2twb2ludHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNoZWNrcG9pbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmVkTW9kZWxDaGVja3BvaW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NoZWNrcG9pbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0RhdGFzZXRUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZlcnRleERhdGFzZXRSZXNvdXJjZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmVydGV4RGF0YXNldFJlc291cmNlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGFtcGxlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhhbXBsZXMnXSk7XG4gICAgaWYgKGZyb21FeGFtcGxlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRXhhbXBsZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nRXhhbXBsZVRvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGFtcGxlcycsICdleGFtcGxlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdEYXRhc2V0VG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmVydGV4RGF0YXNldFJlc291cmNlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICd0cmFpbmluZ0RhdGFzZXRVcmknXSwgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4YW1wbGVzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGFtcGxlcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0V4YW1wbGVUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZXh0SW5wdXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHRJbnB1dCddKTtcbiAgICBpZiAoZnJvbVRleHRJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHRJbnB1dCddLCBmcm9tVGV4dElucHV0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0J10pO1xuICAgIGlmIChmcm9tT3V0cHV0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0J10sIGZyb21PdXRwdXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdKb2JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0VHVuaW5nSm9iU3RhdHVzKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmluZ1Rhc2snLFxuICAgICAgICAnc3RhcnRUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5pbmdUYXNrJyxcbiAgICAgICAgJ2NvbXBsZXRlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlTW9kZWwnXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsJ10sIHR1bmVkTW9kZWxGcm9tTWxkZXYoZnJvbVR1bmVkTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUN1c3RvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2N1c3RvbUJhc2VNb2RlbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DdXN0b21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjdXN0b21CYXNlTW9kZWwnXSwgZnJvbUN1c3RvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBlcmltZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBlcmltZW50J10pO1xuICAgIGlmIChmcm9tRXhwZXJpbWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4cGVyaW1lbnQnXSwgZnJvbUV4cGVyaW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dFVyaSddKTtcbiAgICBpZiAoZnJvbU91dHB1dFVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ291dHB1dFVyaSddLCBmcm9tT3V0cHV0VXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBpcGVsaW5lSm9iID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwaXBlbGluZUpvYiddKTtcbiAgICBpZiAoZnJvbVBpcGVsaW5lSm9iICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGlwZWxpbmVKb2InXSwgZnJvbVBpcGVsaW5lSm9iKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlcnZpY2VBY2NvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2VydmljZUFjY291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VydmljZUFjY291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXJ2aWNlQWNjb3VudCddLCBmcm9tU2VydmljZUFjY291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuZWRNb2RlbERpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZSddLCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZlb1R1bmluZ1NwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2ZW9UdW5pbmdTcGVjJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZlb1R1bmluZ1NwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2ZW9UdW5pbmdTcGVjJ10sIGZyb21WZW9UdW5pbmdTcGVjKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nSm9iRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIHRUdW5pbmdKb2JTdGF0dXMoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVuZWRNb2RlbCddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsJ10sIHR1bmVkTW9kZWxGcm9tVmVydGV4KGZyb21UdW5lZE1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVUdW5lZE1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlVHVuZWRNb2RlbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVUdW5lZE1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlVHVuZWRNb2RlbCddLCBmcm9tUHJlVHVuZWRNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdXBlcnZpc2VkVHVuaW5nU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N1cGVydmlzZWRUdW5pbmdTcGVjJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN1cGVydmlzZWRUdW5pbmdTcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnXSwgZnJvbVN1cGVydmlzZWRUdW5pbmdTcGVjKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmluZ0RhdGFTdGF0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmluZ0RhdGFTdGF0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UdW5pbmdEYXRhU3RhdHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5pbmdEYXRhU3RhdHMnXSwgZnJvbVR1bmluZ0RhdGFTdGF0cyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmNyeXB0aW9uU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuY3J5cHRpb25TcGVjJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuY3J5cHRpb25TcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5jcnlwdGlvblNwZWMnXSwgZnJvbUVuY3J5cHRpb25TcGVjKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcnRuZXJNb2RlbFR1bmluZ1NwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJ0bmVyTW9kZWxUdW5pbmdTcGVjJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcnRuZXJNb2RlbFR1bmluZ1NwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0bmVyTW9kZWxUdW5pbmdTcGVjJ10sIGZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUN1c3RvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2N1c3RvbUJhc2VNb2RlbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DdXN0b21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjdXN0b21CYXNlTW9kZWwnXSwgZnJvbUN1c3RvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBlcmltZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBlcmltZW50J10pO1xuICAgIGlmIChmcm9tRXhwZXJpbWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4cGVyaW1lbnQnXSwgZnJvbUV4cGVyaW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dFVyaSddKTtcbiAgICBpZiAoZnJvbU91dHB1dFVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ291dHB1dFVyaSddLCBmcm9tT3V0cHV0VXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBpcGVsaW5lSm9iID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwaXBlbGluZUpvYiddKTtcbiAgICBpZiAoZnJvbVBpcGVsaW5lSm9iICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGlwZWxpbmVKb2InXSwgZnJvbVBpcGVsaW5lSm9iKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlcnZpY2VBY2NvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2VydmljZUFjY291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VydmljZUFjY291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXJ2aWNlQWNjb3VudCddLCBmcm9tU2VydmljZUFjY291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuZWRNb2RlbERpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZSddLCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZlb1R1bmluZ1NwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2ZW9UdW5pbmdTcGVjJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZlb1R1bmluZ1NwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2ZW9UdW5pbmdTcGVjJ10sIGZyb21WZW9UdW5pbmdTcGVjKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nT3BlcmF0aW9uRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ1ZhbGlkYXRpb25EYXRhc2V0VG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2YWxpZGF0aW9uRGF0YXNldFVyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZlcnRleERhdGFzZXRSZXNvdXJjZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIFR1bmluZ3MgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGEgVHVuaW5nSm9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSByZXNvdXJjZSBuYW1lIG9mIHRoZSB0dW5pbmcgam9iLlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBUdW5pbmdKb2Igb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsIC0gVGhlIFNESydzIHR1bmluZyBpbXBsZW1lbnRhdGlvbiBpcyBleHBlcmltZW50YWwsIGFuZCBtYXlcbiAgICAgICAgICogY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0SW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIHR1bmluZyBqb2JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIGxpc3Qgb2YgdHVuaW5nIGpvYnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgLSBUaGUgU0RLJ3MgdHVuaW5nIGltcGxlbWVudGF0aW9uIGlzIGV4cGVyaW1lbnRhbCwgYW5kIG1heVxuICAgICAgICAgKiBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX1RVTklOR19KT0JTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgc3VwZXJ2aXNlZCBmaW5lLXR1bmluZyBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIHR1bmluZyBqb2IuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIFR1bmluZ0pvYiBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgLSBUaGUgU0RLJ3MgdHVuaW5nIGltcGxlbWVudGF0aW9uIGlzIGV4cGVyaW1lbnRhbCwgYW5kIG1heVxuICAgICAgICAgKiBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50dW5lID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmFzZU1vZGVsLnN0YXJ0c1dpdGgoJ3Byb2plY3RzLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZVR1bmVkTW9kZWwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0dW5lZE1vZGVsTmFtZTogcGFyYW1zLmJhc2VNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVUdW5lZE1vZGVsLmNoZWNrcG9pbnRJZCA9IHBhcmFtcy5jb25maWcucHJlVHVuZWRNb2RlbENoZWNrcG9pbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNQcml2YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IHByZVR1bmVkTW9kZWw6IHByZVR1bmVkTW9kZWwgfSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1ByaXZhdGUuYmFzZU1vZGVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50dW5lSW50ZXJuYWwocGFyYW1zUHJpdmF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNQcml2YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHVuZUludGVybmFsKHBhcmFtc1ByaXZhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc1ByaXZhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IHRoaXMudHVuZU1sZGV2SW50ZXJuYWwocGFyYW1zUHJpdmF0ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHR1bmVkTW9kZWxOYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvblsnbWV0YWRhdGEnXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblsnbWV0YWRhdGEnXVsndHVuZWRNb2RlbCddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHVuZWRNb2RlbE5hbWUgPSBvcGVyYXRpb25bJ21ldGFkYXRhJ11bJ3R1bmVkTW9kZWwnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uWyduYW1lJ10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25bJ25hbWUnXS5pbmNsdWRlcygnL29wZXJhdGlvbnMvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHVuZWRNb2RlbE5hbWUgPSBvcGVyYXRpb25bJ25hbWUnXS5zcGxpdCgnL29wZXJhdGlvbnMvJylbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHR1bmluZ0pvYiA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdHVuZWRNb2RlbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBKb2JTdGF0ZS5KT0JfU1RBVEVfUVVFVUVELFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmluZ0pvYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB0dW5pbmdKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ0pvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5pbmdKb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RUdW5pbmdKb2JzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmVkTW9kZWxzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhIHR1bmluZyBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjYW5jZWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBlbXB0eSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLnR1bmluZ3MuY2FuY2VsKHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNhbmNlbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9OmNhbmNlbCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjYW5jZWxUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9OmNhbmNlbCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB0dW5lSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5pbmdKb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdHVuaW5nSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB0dW5lTWxkZXZJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5lZE1vZGVscycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ09wZXJhdGlvbkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxMDI0ICogMTAyNCAqIDg7IC8vIGJ5dGVzXG5jb25zdCBNQVhfUkVUUllfQ09VTlQgPSAzO1xuY29uc3QgSU5JVElBTF9SRVRSWV9ERUxBWV9NUyA9IDEwMDA7XG5jb25zdCBERUxBWV9NVUxUSVBMSUVSID0gMjtcbmNvbnN0IFhfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRCA9ICd4LWdvb2ctdXBsb2FkLXN0YXR1cyc7XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRCbG9iKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgbGV0IGZpbGVTaXplID0gMDtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBsZXQgcmVzcG9uc2UgPSBuZXcgSHR0cFJlc3BvbnNlKG5ldyBSZXNwb25zZSgpKTtcbiAgICBsZXQgdXBsb2FkQ29tbWFuZCA9ICd1cGxvYWQnO1xuICAgIGZpbGVTaXplID0gZmlsZS5zaXplO1xuICAgIHdoaWxlIChvZmZzZXQgPCBmaWxlU2l6ZSkge1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBNYXRoLm1pbihNQVhfQ0hVTktfU0laRSwgZmlsZVNpemUgLSBvZmZzZXQpO1xuICAgICAgICBjb25zdCBjaHVuayA9IGZpbGUuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjaHVua1NpemUpO1xuICAgICAgICBpZiAob2Zmc2V0ICsgY2h1bmtTaXplID49IGZpbGVTaXplKSB7XG4gICAgICAgICAgICB1cGxvYWRDb21tYW5kICs9ICcsIGZpbmFsaXplJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50RGVsYXlNcyA9IElOSVRJQUxfUkVUUllfREVMQVlfTVM7XG4gICAgICAgIHdoaWxlIChyZXRyeUNvdW50IDwgTUFYX1JFVFJZX0NPVU5UKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnJyxcbiAgICAgICAgICAgICAgICBib2R5OiBjaHVuayxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXBpVmVyc2lvbjogJycsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VVcmw6IHVwbG9hZFVybCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6IHVwbG9hZENvbW1hbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1PZmZzZXQnOiBTdHJpbmcob2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IFN0cmluZyhjaHVua1NpemUpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKGN1cnJlbnREZWxheU1zKTtcbiAgICAgICAgICAgIGN1cnJlbnREZWxheU1zID0gY3VycmVudERlbGF5TXMgKiBERUxBWV9NVUxUSVBMSUVSO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICAgIC8vIFRoZSBgeC1nb29nLXVwbG9hZC1zdGF0dXNgIGhlYWRlciBmaWVsZCBjYW4gYmUgYGFjdGl2ZWAsIGBmaW5hbGAgYW5kXG4gICAgICAgIC8vYGNhbmNlbGxlZGAgaW4gcmVzcG9zbmUuXG4gICAgICAgIGlmICgoKF9iID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oYi80MDEzOTE0MzApIEludmVzdGlnYXRlIHdoeSB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkXG4gICAgICAgIC8vIGV2ZW4gdGhvdWdoIGFsbCBjb250ZW50IGhhcyBiZWVuIHVwbG9hZGVkLlxuICAgICAgICBpZiAoZmlsZVNpemUgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBjb250ZW50IGhhcyBiZWVuIHVwbG9hZGVkLCBidXQgdGhlIHVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXNwb25zZUpzb24gPSAoYXdhaXQgKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5qc29uKCkpKTtcbiAgICBpZiAoKChfYyA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdmaW5hbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIGZpbGU6IFVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlSnNvblsnZmlsZSddO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QmxvYlN0YXQoZmlsZSkge1xuICAgIGNvbnN0IGZpbGVTdGF0ID0geyBzaXplOiBmaWxlLnNpemUsIHR5cGU6IGZpbGUudHlwZSB9O1xuICAgIHJldHVybiBmaWxlU3RhdDtcbn1cbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlUHJvbWlzZSkgPT4gc2V0VGltZW91dChyZXNvbHZlUHJvbWlzZSwgbXMpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTm9kZVVwbG9hZGVyIHtcbiAgICBhc3luYyBzdGF0KGZpbGUpIHtcbiAgICAgICAgY29uc3QgZmlsZVN0YXQgPSB7IHNpemU6IDAsIHR5cGU6IHVuZGVmaW5lZCB9O1xuICAgICAgICBpZiAodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0YXQgPSBhd2FpdCBmcy5zdGF0KGZpbGUpO1xuICAgICAgICAgICAgZmlsZVN0YXQuc2l6ZSA9IG9yaWdpbmFsU3RhdC5zaXplO1xuICAgICAgICAgICAgZmlsZVN0YXQudHlwZSA9IHRoaXMuaW5mZXJNaW1lVHlwZShmaWxlKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlU3RhdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBnZXRCbG9iU3RhdChmaWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGxvYWQoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudXBsb2FkRmlsZUZyb21QYXRoKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWRCbG9iKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmZlcnMgdGhlIE1JTUUgdHlwZSBvZiBhIGZpbGUgYmFzZWQgb24gaXRzIGV4dGVuc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCBUaGUgcGF0aCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgTUlNRSB0eXBlIG9mIHRoZSBmaWxlLCBvciB1bmRlZmluZWQgaWYgaXQgY2Fubm90IGJlIGluZmVycmVkLlxuICAgICAqL1xuICAgIGluZmVyTWltZVR5cGUoZmlsZVBhdGgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBmaWxlIGV4dGVuc2lvbi5cbiAgICAgICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IGZpbGVQYXRoLnNsaWNlKGZpbGVQYXRoLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbWFwIG9mIGZpbGUgZXh0ZW5zaW9ucyB0byBNSU1FIHR5cGVzLlxuICAgICAgICBjb25zdCBtaW1lVHlwZXMgPSB7XG4gICAgICAgICAgICAnYWFjJzogJ2F1ZGlvL2FhYycsXG4gICAgICAgICAgICAnYWJ3JzogJ2FwcGxpY2F0aW9uL3gtYWJpd29yZCcsXG4gICAgICAgICAgICAnYXJjJzogJ2FwcGxpY2F0aW9uL3gtZnJlZWFyYycsXG4gICAgICAgICAgICAnYXZpJzogJ3ZpZGVvL3gtbXN2aWRlbycsXG4gICAgICAgICAgICAnYXp3JzogJ2FwcGxpY2F0aW9uL3ZuZC5hbWF6b24uZWJvb2snLFxuICAgICAgICAgICAgJ2Jpbic6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgICAgICAgJ2JtcCc6ICdpbWFnZS9ibXAnLFxuICAgICAgICAgICAgJ2J6JzogJ2FwcGxpY2F0aW9uL3gtYnppcCcsXG4gICAgICAgICAgICAnYnoyJzogJ2FwcGxpY2F0aW9uL3gtYnppcDInLFxuICAgICAgICAgICAgJ2NzaCc6ICdhcHBsaWNhdGlvbi94LWNzaCcsXG4gICAgICAgICAgICAnY3NzJzogJ3RleHQvY3NzJyxcbiAgICAgICAgICAgICdjc3YnOiAndGV4dC9jc3YnLFxuICAgICAgICAgICAgJ2RvYyc6ICdhcHBsaWNhdGlvbi9tc3dvcmQnLFxuICAgICAgICAgICAgJ2RvY3gnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICAgICAgICAgICAgJ2VvdCc6ICdhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdCcsXG4gICAgICAgICAgICAnZXB1Yic6ICdhcHBsaWNhdGlvbi9lcHViK3ppcCcsXG4gICAgICAgICAgICAnZ3onOiAnYXBwbGljYXRpb24vZ3ppcCcsXG4gICAgICAgICAgICAnZ2lmJzogJ2ltYWdlL2dpZicsXG4gICAgICAgICAgICAnaHRtJzogJ3RleHQvaHRtbCcsXG4gICAgICAgICAgICAnaHRtbCc6ICd0ZXh0L2h0bWwnLFxuICAgICAgICAgICAgJ2ljbyc6ICdpbWFnZS92bmQubWljcm9zb2Z0Lmljb24nLFxuICAgICAgICAgICAgJ2ljcyc6ICd0ZXh0L2NhbGVuZGFyJyxcbiAgICAgICAgICAgICdqYXInOiAnYXBwbGljYXRpb24vamF2YS1hcmNoaXZlJyxcbiAgICAgICAgICAgICdqcGVnJzogJ2ltYWdlL2pwZWcnLFxuICAgICAgICAgICAgJ2pwZyc6ICdpbWFnZS9qcGVnJyxcbiAgICAgICAgICAgICdqcyc6ICd0ZXh0L2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgJ2pzb24nOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnanNvbmxkJzogJ2FwcGxpY2F0aW9uL2xkK2pzb24nLFxuICAgICAgICAgICAgJ2ttbCc6ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttbCt4bWwnLFxuICAgICAgICAgICAgJ2tteic6ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmtteit4bWwnLFxuICAgICAgICAgICAgJ21qcyc6ICd0ZXh0L2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgJ21wMyc6ICdhdWRpby9tcGVnJyxcbiAgICAgICAgICAgICdtcDQnOiAndmlkZW8vbXA0JyxcbiAgICAgICAgICAgICdtcGVnJzogJ3ZpZGVvL21wZWcnLFxuICAgICAgICAgICAgJ21wa2cnOiAnYXBwbGljYXRpb24vdm5kLmFwcGxlLmluc3RhbGxlcit4bWwnLFxuICAgICAgICAgICAgJ29kdCc6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQnLFxuICAgICAgICAgICAgJ29nYSc6ICdhdWRpby9vZ2cnLFxuICAgICAgICAgICAgJ29ndic6ICd2aWRlby9vZ2cnLFxuICAgICAgICAgICAgJ29neCc6ICdhcHBsaWNhdGlvbi9vZ2cnLFxuICAgICAgICAgICAgJ29wdXMnOiAnYXVkaW8vb3B1cycsXG4gICAgICAgICAgICAnb3RmJzogJ2ZvbnQvb3RmJyxcbiAgICAgICAgICAgICdwbmcnOiAnaW1hZ2UvcG5nJyxcbiAgICAgICAgICAgICdwZGYnOiAnYXBwbGljYXRpb24vcGRmJyxcbiAgICAgICAgICAgICdwaHAnOiAnYXBwbGljYXRpb24veC1odHRwZC1waHAnLFxuICAgICAgICAgICAgJ3BwdCc6ICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludCcsXG4gICAgICAgICAgICAncHB0eCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uJyxcbiAgICAgICAgICAgICdyYXInOiAnYXBwbGljYXRpb24vdm5kLnJhcicsXG4gICAgICAgICAgICAncnRmJzogJ2FwcGxpY2F0aW9uL3J0ZicsXG4gICAgICAgICAgICAnc2gnOiAnYXBwbGljYXRpb24veC1zaCcsXG4gICAgICAgICAgICAnc3ZnJzogJ2ltYWdlL3N2Zyt4bWwnLFxuICAgICAgICAgICAgJ3N3Zic6ICdhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCcsXG4gICAgICAgICAgICAndGFyJzogJ2FwcGxpY2F0aW9uL3gtdGFyJyxcbiAgICAgICAgICAgICd0aWYnOiAnaW1hZ2UvdGlmZicsXG4gICAgICAgICAgICAndGlmZic6ICdpbWFnZS90aWZmJyxcbiAgICAgICAgICAgICd0cyc6ICd2aWRlby9tcDJ0JyxcbiAgICAgICAgICAgICd0dGYnOiAnZm9udC90dGYnLFxuICAgICAgICAgICAgJ3R4dCc6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgICAgICd2c2QnOiAnYXBwbGljYXRpb24vdm5kLnZpc2lvJyxcbiAgICAgICAgICAgICd3YXYnOiAnYXVkaW8vd2F2JyxcbiAgICAgICAgICAgICd3ZWJhJzogJ2F1ZGlvL3dlYm0nLFxuICAgICAgICAgICAgJ3dlYm0nOiAndmlkZW8vd2VibScsXG4gICAgICAgICAgICAnd2VicCc6ICdpbWFnZS93ZWJwJyxcbiAgICAgICAgICAgICd3b2ZmJzogJ2ZvbnQvd29mZicsXG4gICAgICAgICAgICAnd29mZjInOiAnZm9udC93b2ZmMicsXG4gICAgICAgICAgICAneGh0bWwnOiAnYXBwbGljYXRpb24veGh0bWwreG1sJyxcbiAgICAgICAgICAgICd4bHMnOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgICAgICAgICAgICd4bHN4JzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0JyxcbiAgICAgICAgICAgICd4bWwnOiAnYXBwbGljYXRpb24veG1sJyxcbiAgICAgICAgICAgICd4dWwnOiAnYXBwbGljYXRpb24vdm5kLm1vemlsbGEueHVsK3htbCcsXG4gICAgICAgICAgICAnemlwJzogJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICAgICAgICAgICAnM2dwJzogJ3ZpZGVvLzNncHAnLFxuICAgICAgICAgICAgJzNnMic6ICd2aWRlby8zZ3BwMicsXG4gICAgICAgICAgICAnN3onOiAnYXBwbGljYXRpb24veC03ei1jb21wcmVzc2VkJyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgTUlNRSB0eXBlIGJhc2VkIG9uIHRoZSBmaWxlIGV4dGVuc2lvbi5cbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBtaW1lVHlwZXNbZmlsZUV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBNSU1FIHR5cGUuXG4gICAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkRmlsZUZyb21QYXRoKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgZmlsZVNpemUgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gbmV3IEh0dHBSZXNwb25zZShuZXcgUmVzcG9uc2UoKSk7XG4gICAgICAgIGxldCB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCc7XG4gICAgICAgIGxldCBmaWxlSGFuZGxlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmlsZUhhbmRsZSA9IGF3YWl0IGZzLm9wZW4oZmlsZSwgJ3InKTtcbiAgICAgICAgICAgIGlmICghZmlsZUhhbmRsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIG9wZW4gZmlsZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZVNpemUgPSAoYXdhaXQgZmlsZUhhbmRsZS5zdGF0KCkpLnNpemU7XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgZmlsZVNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1NpemUgPSBNYXRoLm1pbihNQVhfQ0hVTktfU0laRSwgZmlsZVNpemUgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgKyBjaHVua1NpemUgPj0gZmlsZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkQ29tbWFuZCArPSAnLCBmaW5hbGl6ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBieXRlc1JlYWQ6IGJ5dGVzUmVhZCB9ID0gYXdhaXQgZmlsZUhhbmRsZS5yZWFkKGJ1ZmZlciwgMCwgY2h1bmtTaXplLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChieXRlc1JlYWQgIT09IGNodW5rU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZWFkICR7Y2h1bmtTaXplfSBieXRlcyBmcm9tIGZpbGUgYXQgb2Zmc2V0ICR7b2Zmc2V0fS4gYnl0ZXMgYWN0dWFsbHkgcmVhZDogJHtieXRlc1JlYWR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gbmV3IEJsb2IoW2J1ZmZlcl0pO1xuICAgICAgICAgICAgICAgIGxldCByZXRyeUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudERlbGF5TXMgPSBJTklUSUFMX1JFVFJZX0RFTEFZX01TO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZXRyeUNvdW50IDwgTUFYX1JFVFJZX0NPVU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpVmVyc2lvbjogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybDogdXBsb2FkVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6IHVwbG9hZENvbW1hbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLU9mZnNldCc6IFN0cmluZyhvZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1MZW5ndGgnOiBTdHJpbmcoYnl0ZXNSZWFkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAoY3VycmVudERlbGF5TXMpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVsYXlNcyA9IGN1cnJlbnREZWxheU1zICogREVMQVlfTVVMVElQTElFUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYHgtZ29vZy11cGxvYWQtc3RhdHVzYCBoZWFkZXIgZmllbGQgY2FuIGJlIGBhY3RpdmVgLCBgZmluYWxgIGFuZFxuICAgICAgICAgICAgICAgIC8vYGNhbmNlbGxlZGAgaW4gcmVzcG9zbmUuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2IgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVTaXplIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBjb250ZW50IGhhcyBiZWVuIHVwbG9hZGVkLCBidXQgdGhlIHVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUpzb24gPSAoYXdhaXQgKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5qc29uKCkpKTtcbiAgICAgICAgICAgIGlmICgoKF9jID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1tYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSAhPT0gJ2ZpbmFsJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VKc29uWydmaWxlJ107XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGZpbGUgaGFuZGxlIGlzIGFsd2F5cyBjbG9zZWRcbiAgICAgICAgICAgIGlmIChmaWxlSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmlsZUhhbmRsZS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBMQU5HVUFHRV9MQUJFTF9QUkVGSVggPSAnZ2wtbm9kZS8nO1xuLyoqXG4gKiBUaGUgR29vZ2xlIEdlbkFJIFNESy5cbiAqXG4gKiBAcmVtYXJrc1xuICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBHZW5BSSBmZWF0dXJlcyB0aHJvdWdoIGVpdGhlciB0aGUge0BsaW5rXG4gKiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2RvY3MvcmVmZXJlbmNlL3Jlc3QgfCBHZW1pbmkgQVBJfSBvclxuICogdGhlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2RvY3MvcmVmZXJlbmNlL3Jlc3QgfCBWZXJ0ZXggQUlcbiAqIEFQSX0uXG4gKlxuICogVGhlIHtAbGluayBHb29nbGVHZW5BSU9wdGlvbnMudmVydGV4YWl9IHZhbHVlIGRldGVybWluZXMgd2hpY2ggb2YgdGhlIEFQSVxuICogc2VydmljZXMgdG8gdXNlLlxuICpcbiAqIFdoZW4gdXNpbmcgdGhlIEdlbWluaSBBUEksIGEge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9ucy5hcGlLZXl9IG11c3QgYWxzbyBiZVxuICogc2V0LiBXaGVuIHVzaW5nIFZlcnRleCBBSSwgYm90aCB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zLnByb2plY3R9IGFuZCB7QGxpbmtcbiAqIEdvb2dsZUdlbkFJT3B0aW9ucy5sb2NhdGlvbn0gbXVzdCBiZSBzZXQsIG9yIGEge0BsaW5rXG4gKiBHb29nbGVHZW5BSU9wdGlvbnMuYXBpS2V5fSBtdXN0IGJlIHNldCB3aGVuIHVzaW5nIEV4cHJlc3MgTW9kZS5cbiAqXG4gKiBFeHBsaWNpdGx5IHBhc3NlZCBpbiB2YWx1ZXMgaW4ge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9uc30gd2lsbCBhbHdheXMgdGFrZVxuICogcHJlY2VkZW5jZSBvdmVyIGVudmlyb25tZW50IHZhcmlhYmxlcy4gSWYgYm90aCBwcm9qZWN0L2xvY2F0aW9uIGFuZCBhcGlfa2V5XG4gKiBleGlzdCBpbiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLCB0aGUgcHJvamVjdC9sb2NhdGlvbiB3aWxsIGJlIHVzZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIEluaXRpYWxpemluZyB0aGUgU0RLIGZvciB1c2luZyB0aGUgR2VtaW5pIEFQSTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6ICdHRU1JTklfQVBJX0tFWSd9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJbml0aWFsaXppbmcgdGhlIFNESyBmb3IgdXNpbmcgdGhlIFZlcnRleCBBSSBBUEk6XG4gKiBgYGB0c1xuICogaW1wb3J0IHtHb29nbGVHZW5BSX0gZnJvbSAnQGdvb2dsZS9nZW5haSc7XG4gKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7XG4gKiAgIHZlcnRleGFpOiB0cnVlLFxuICogICBwcm9qZWN0OiAnUFJPSkVDVF9JRCcsXG4gKiAgIGxvY2F0aW9uOiAnUFJPSkVDVF9MT0NBVElPTidcbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5jbGFzcyBHb29nbGVHZW5BSSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgLy8gVmFsaWRhdGUgZXhwbGljaXRseSBzZXQgaW5pdGlhbGl6ZXIgdmFsdWVzLlxuICAgICAgICBpZiAoKG9wdGlvbnMucHJvamVjdCB8fCBvcHRpb25zLmxvY2F0aW9uKSAmJiBvcHRpb25zLmFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0L2xvY2F0aW9uIGFuZCBBUEkga2V5IGFyZSBtdXR1YWxseSBleGNsdXNpdmUgaW4gdGhlIGNsaWVudCBpbml0aWFsaXplci4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnRleGFpID1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IG9wdGlvbnMudmVydGV4YWkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGdldEJvb2xlYW5FbnYoJ0dPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUknKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IGVudkFwaUtleSA9IGdldEFwaUtleUZyb21FbnYoKTtcbiAgICAgICAgY29uc3QgZW52UHJvamVjdCA9IGdldEVudignR09PR0xFX0NMT1VEX1BST0pFQ1QnKTtcbiAgICAgICAgY29uc3QgZW52TG9jYXRpb24gPSBnZXRFbnYoJ0dPT0dMRV9DTE9VRF9MT0NBVElPTicpO1xuICAgICAgICB0aGlzLmFwaUtleSA9IChfYyA9IG9wdGlvbnMuYXBpS2V5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBlbnZBcGlLZXk7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IChfZCA9IG9wdGlvbnMucHJvamVjdCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZW52UHJvamVjdDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IChfZSA9IG9wdGlvbnMubG9jYXRpb24pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGVudkxvY2F0aW9uO1xuICAgICAgICAvLyBIYW5kbGUgd2hlbiB0byB1c2UgVmVydGV4IEFJIGluIGV4cHJlc3MgbW9kZSAoYXBpIGtleSlcbiAgICAgICAgaWYgKG9wdGlvbnMudmVydGV4YWkpIHtcbiAgICAgICAgICAgIGlmICgoX2YgPSBvcHRpb25zLmdvb2dsZUF1dGhPcHRpb25zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCBjcmVkZW50aWFscyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBpbXBsaWNpdCBhcGlfa2V5LlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1RoZSB1c2VyIHByb3ZpZGVkIEdvb2dsZSBDbG91ZCBjcmVkZW50aWFscyB3aWxsIHRha2UgcHJlY2VkZW5jZScgK1xuICAgICAgICAgICAgICAgICAgICAnIG92ZXIgdGhlIEFQSSBrZXkgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeHBsaWNpdCBhcGlfa2V5IGFuZCBleHBsaWNpdCBwcm9qZWN0L2xvY2F0aW9uIGFscmVhZHkgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgICAgIGlmICgoZW52UHJvamVjdCB8fCBlbnZMb2NhdGlvbikgJiYgb3B0aW9ucy5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCBhcGlfa2V5IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBpbXBsaWNpdCBwcm9qZWN0L2xvY2F0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1RoZSB1c2VyIHByb3ZpZGVkIFZlcnRleCBBSSBBUEkga2V5IHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXInICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aGUgcHJvamVjdC9sb2NhdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgob3B0aW9ucy5wcm9qZWN0IHx8IG9wdGlvbnMubG9jYXRpb24pICYmIGVudkFwaUtleSkge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IHByb2plY3QvbG9jYXRpb24gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IGFwaV9rZXkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHVzZXIgcHJvdmlkZWQgcHJvamVjdC9sb2NhdGlvbiB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyJyArXG4gICAgICAgICAgICAgICAgICAgICcgdGhlIEFQSSBrZXkgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBpS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKGVudlByb2plY3QgfHwgZW52TG9jYXRpb24pICYmIGVudkFwaUtleSkge1xuICAgICAgICAgICAgICAgIC8vIEltcGxpY2l0IHByb2plY3QvbG9jYXRpb24gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IGFwaV9rZXkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHByb2plY3QvbG9jYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpbGwgdGFrZScgK1xuICAgICAgICAgICAgICAgICAgICAnIHByZWNlZGVuY2Ugb3ZlciB0aGUgQVBJIGtleSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwob3B0aW9ucy5odHRwT3B0aW9ucywgb3B0aW9ucy52ZXJ0ZXhhaSwgZ2V0RW52KCdHT09HTEVfVkVSVEVYX0JBU0VfVVJMJyksIGdldEVudignR09PR0xFX0dFTUlOSV9CQVNFX1VSTCcpKTtcbiAgICAgICAgaWYgKGJhc2VVcmwpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHR0cE9wdGlvbnMgPSB7IGJhc2VVcmw6IGJhc2VVcmwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaVZlcnNpb24gPSBvcHRpb25zLmFwaVZlcnNpb247XG4gICAgICAgIGNvbnN0IGF1dGggPSBuZXcgTm9kZUF1dGgoe1xuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIGdvb2dsZUF1dGhPcHRpb25zOiBvcHRpb25zLmdvb2dsZUF1dGhPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgQXBpQ2xpZW50KHtcbiAgICAgICAgICAgIGF1dGg6IGF1dGgsXG4gICAgICAgICAgICBwcm9qZWN0OiB0aGlzLnByb2plY3QsXG4gICAgICAgICAgICBsb2NhdGlvbjogdGhpcy5sb2NhdGlvbixcbiAgICAgICAgICAgIGFwaVZlcnNpb246IHRoaXMuYXBpVmVyc2lvbixcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICB2ZXJ0ZXhhaTogdGhpcy52ZXJ0ZXhhaSxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zOiBvcHRpb25zLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgdXNlckFnZW50RXh0cmE6IExBTkdVQUdFX0xBQkVMX1BSRUZJWCArIHByb2Nlc3MudmVyc2lvbixcbiAgICAgICAgICAgIHVwbG9hZGVyOiBuZXcgTm9kZVVwbG9hZGVyKCksXG4gICAgICAgICAgICBkb3dubG9hZGVyOiBuZXcgTm9kZURvd25sb2FkZXIoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWxzID0gbmV3IE1vZGVscyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMubGl2ZSA9IG5ldyBMaXZlKHRoaXMuYXBpQ2xpZW50LCBhdXRoLCBuZXcgTm9kZVdlYlNvY2tldEZhY3RvcnkoKSk7XG4gICAgICAgIHRoaXMuYmF0Y2hlcyA9IG5ldyBCYXRjaGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5jaGF0cyA9IG5ldyBDaGF0cyh0aGlzLm1vZGVscywgdGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmNhY2hlcyA9IG5ldyBDYWNoZXModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmZpbGVzID0gbmV3IEZpbGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gbmV3IE9wZXJhdGlvbnModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmF1dGhUb2tlbnMgPSBuZXcgVG9rZW5zKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy50dW5pbmdzID0gbmV3IFR1bmluZ3ModGhpcy5hcGlDbGllbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVudihlbnYpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gcHJvY2VzcyA9PT0gbnVsbCB8fCBwcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Vudl0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50cmltKCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEJvb2xlYW5FbnYoZW52KSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvQm9vbGVhbihnZXRFbnYoZW52KSk7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0Jvb2xlYW4oc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG5mdW5jdGlvbiBnZXRBcGlLZXlGcm9tRW52KCkge1xuICAgIGNvbnN0IGVudkdvb2dsZUFwaUtleSA9IGdldEVudignR09PR0xFX0FQSV9LRVknKTtcbiAgICBjb25zdCBlbnZHZW1pbmlBcGlLZXkgPSBnZXRFbnYoJ0dFTUlOSV9BUElfS0VZJyk7XG4gICAgaWYgKGVudkdvb2dsZUFwaUtleSAmJiBlbnZHZW1pbmlBcGlLZXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdCb3RoIEdPT0dMRV9BUElfS0VZIGFuZCBHRU1JTklfQVBJX0tFWSBhcmUgc2V0LiBVc2luZyBHT09HTEVfQVBJX0tFWS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudkdvb2dsZUFwaUtleSB8fCBlbnZHZW1pbmlBcGlLZXkgfHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgeyBBY3Rpdml0eUhhbmRsaW5nLCBBZGFwdGVyU2l6ZSwgQXBpRXJyb3IsIEFwaVNwZWMsIEF1dGhUeXBlLCBCYXRjaGVzLCBCZWhhdmlvciwgQmxvY2tlZFJlYXNvbiwgQ2FjaGVzLCBDaGF0LCBDaGF0cywgQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlLCBDb250ZW50UmVmZXJlbmNlSW1hZ2UsIENvbnRyb2xSZWZlcmVuY2VJbWFnZSwgQ29udHJvbFJlZmVyZW5jZVR5cGUsIENvdW50VG9rZW5zUmVzcG9uc2UsIENyZWF0ZUZpbGVSZXNwb25zZSwgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlLCBEZWxldGVGaWxlUmVzcG9uc2UsIERlbGV0ZU1vZGVsUmVzcG9uc2UsIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlLCBFZGl0SW1hZ2VSZXNwb25zZSwgRWRpdE1vZGUsIEVtYmVkQ29udGVudFJlc3BvbnNlLCBFbmRTZW5zaXRpdml0eSwgRW52aXJvbm1lbnQsIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlLCBGaWxlU291cmNlLCBGaWxlU3RhdGUsIEZpbGVzLCBGaW5pc2hSZWFzb24sIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUsIEZ1bmN0aW9uUmVzcG9uc2UsIEZ1bmN0aW9uUmVzcG9uc2VCbG9iLCBGdW5jdGlvblJlc3BvbnNlRmlsZURhdGEsIEZ1bmN0aW9uUmVzcG9uc2VQYXJ0LCBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZywgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UsIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlUHJvbXB0RmVlZGJhY2ssIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlVXNhZ2VNZXRhZGF0YSwgR2VuZXJhdGVJbWFnZXNSZXNwb25zZSwgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24sIEdlbmVyYXRlVmlkZW9zUmVzcG9uc2UsIEdvb2dsZUdlbkFJLCBIYXJtQmxvY2tNZXRob2QsIEhhcm1CbG9ja1RocmVzaG9sZCwgSGFybUNhdGVnb3J5LCBIYXJtUHJvYmFiaWxpdHksIEhhcm1TZXZlcml0eSwgSHR0cFJlc3BvbnNlLCBJbWFnZVByb21wdExhbmd1YWdlLCBJbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2UsIElubGluZWRSZXNwb25zZSwgSm9iU3RhdGUsIExhbmd1YWdlLCBMaXN0QmF0Y2hKb2JzUmVzcG9uc2UsIExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlLCBMaXN0RmlsZXNSZXNwb25zZSwgTGlzdE1vZGVsc1Jlc3BvbnNlLCBMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlLCBMaXZlLCBMaXZlQ2xpZW50VG9vbFJlc3BvbnNlLCBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wsIExpdmVNdXNpY1NlcnZlck1lc3NhZ2UsIExpdmVTZW5kVG9vbFJlc3BvbnNlUGFyYW1ldGVycywgTGl2ZVNlcnZlck1lc3NhZ2UsIE1hc2tSZWZlcmVuY2VJbWFnZSwgTWFza1JlZmVyZW5jZU1vZGUsIE1lZGlhTW9kYWxpdHksIE1lZGlhUmVzb2x1dGlvbiwgTW9kYWxpdHksIE1vZGUsIE1vZGVscywgTXVzaWNHZW5lcmF0aW9uTW9kZSwgT3BlcmF0aW9ucywgT3V0Y29tZSwgUGFnZWRJdGVtLCBQYWdlciwgUGVyc29uR2VuZXJhdGlvbiwgUmF3UmVmZXJlbmNlSW1hZ2UsIFJlY29udGV4dEltYWdlUmVzcG9uc2UsIFJlcGxheVJlc3BvbnNlLCBTYWZldHlGaWx0ZXJMZXZlbCwgU2NhbGUsIFNlZ21lbnRJbWFnZVJlc3BvbnNlLCBTZWdtZW50TW9kZSwgU2Vzc2lvbiwgU2luZ2xlRW1iZWRDb250ZW50UmVzcG9uc2UsIFN0YXJ0U2Vuc2l0aXZpdHksIFN0eWxlUmVmZXJlbmNlSW1hZ2UsIFN1YmplY3RSZWZlcmVuY2VJbWFnZSwgU3ViamVjdFJlZmVyZW5jZVR5cGUsIFRva2VucywgVHJhZmZpY1R5cGUsIFR1bmluZ01vZGUsIFR1bmluZ1Rhc2ssIFR1cm5Db21wbGV0ZVJlYXNvbiwgVHVybkNvdmVyYWdlLCBUeXBlLCBVcHNjYWxlSW1hZ2VSZXNwb25zZSwgVXJsUmV0cmlldmFsU3RhdHVzLCBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSwgVmlkZW9HZW5lcmF0aW9uTWFza01vZGUsIFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGUsIGNyZWF0ZU1vZGVsQ29udGVudCwgY3JlYXRlUGFydEZyb21CYXNlNjQsIGNyZWF0ZVBhcnRGcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCwgY3JlYXRlUGFydEZyb21FeGVjdXRhYmxlQ29kZSwgY3JlYXRlUGFydEZyb21GdW5jdGlvbkNhbGwsIGNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25SZXNwb25zZSwgY3JlYXRlUGFydEZyb21UZXh0LCBjcmVhdGVQYXJ0RnJvbVVyaSwgY3JlYXRlVXNlckNvbnRlbnQsIG1jcFRvVG9vbCwgc2V0RGVmYXVsdEJhc2VVcmxzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiR29vZ2xlQXV0aCIsImNyZWF0ZVdyaXRlU3RyZWFtIiwid3JpdGVGaWxlIiwiUmVhZGFibGUiLCJOb2RlV3MiLCJmcyIsIl9kZWZhdWx0QmFzZUdlbWluaVVybCIsInVuZGVmaW5lZCIsIl9kZWZhdWx0QmFzZVZlcnRleFVybCIsInNldERlZmF1bHRCYXNlVXJscyIsImJhc2VVcmxQYXJhbXMiLCJnZW1pbmlVcmwiLCJ2ZXJ0ZXhVcmwiLCJnZXREZWZhdWx0QmFzZVVybHMiLCJnZXRCYXNlVXJsIiwiaHR0cE9wdGlvbnMiLCJ2ZXJ0ZXhhaSIsInZlcnRleEJhc2VVcmxGcm9tRW52IiwiZ2VtaW5pQmFzZVVybEZyb21FbnYiLCJfYSIsIl9iIiwiYmFzZVVybCIsImRlZmF1bHRCYXNlVXJscyIsIkJhc2VNb2R1bGUiLCJmb3JtYXRNYXAiLCJ0ZW1wbGF0ZVN0cmluZyIsInZhbHVlTWFwIiwicmVnZXgiLCJyZXBsYWNlIiwibWF0Y2giLCJrZXkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsIlN0cmluZyIsIkVycm9yIiwic2V0VmFsdWVCeVBhdGgiLCJkYXRhIiwia2V5cyIsImkiLCJsZW5ndGgiLCJlbmRzV2l0aCIsImtleU5hbWUiLCJzbGljZSIsIkFycmF5IiwiaXNBcnJheSIsImZyb20iLCJhcnJheURhdGEiLCJqIiwiZW50cnkiLCJkIiwia2V5VG9TZXQiLCJleGlzdGluZ0RhdGEiLCJhc3NpZ24iLCJ2YWx1ZUFzUmVjb3JkIiwiZ2V0VmFsdWVCeVBhdGgiLCJtYXAiLCJlcnJvciIsIlR5cGVFcnJvciIsInRCeXRlcyQxIiwiZnJvbUJ5dGVzIiwiZmV0Y2hQcmVkaWN0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4IiwiZnJvbU9iamVjdCIsInRvT2JqZWN0IiwiZnJvbU9wZXJhdGlvbk5hbWUiLCJmcm9tUmVzb3VyY2VOYW1lIiwiZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYkMSIsImZyb21OYW1lIiwiZnJvbU1ldGFkYXRhIiwiZnJvbURvbmUiLCJmcm9tRXJyb3IiLCJmcm9tUmVzcG9uc2UiLCJnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2JDEiLCJnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgkMSIsImdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4JDEiLCJmcm9tR2VuZXJhdGVkVmlkZW9zIiwidHJhbnNmb3JtZWRMaXN0IiwiaXRlbSIsImdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2JDEiLCJmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50IiwiZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zIiwiZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4JDEiLCJmcm9tVmlkZW8iLCJ2aWRlb0Zyb21NbGRldiQxIiwidmlkZW9Gcm9tVmVydGV4JDEiLCJnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9NbGRldiIsImdldE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleCIsImZyb21VcmkiLCJmcm9tVmlkZW9CeXRlcyIsImZyb21NaW1lVHlwZSIsIk91dGNvbWUiLCJMYW5ndWFnZSIsIlR5cGUiLCJIYXJtQ2F0ZWdvcnkiLCJIYXJtQmxvY2tNZXRob2QiLCJIYXJtQmxvY2tUaHJlc2hvbGQiLCJNb2RlIiwiQXV0aFR5cGUiLCJBcGlTcGVjIiwiVXJsUmV0cmlldmFsU3RhdHVzIiwiRmluaXNoUmVhc29uIiwiSGFybVByb2JhYmlsaXR5IiwiSGFybVNldmVyaXR5IiwiQmxvY2tlZFJlYXNvbiIsIlRyYWZmaWNUeXBlIiwiTW9kYWxpdHkiLCJNZWRpYVJlc29sdXRpb24iLCJKb2JTdGF0ZSIsIlR1bmluZ01vZGUiLCJBZGFwdGVyU2l6ZSIsIlR1bmluZ1Rhc2siLCJGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSIsIkJlaGF2aW9yIiwiRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUiLCJFbnZpcm9ubWVudCIsIkZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUiLCJTYWZldHlGaWx0ZXJMZXZlbCIsIlBlcnNvbkdlbmVyYXRpb24iLCJJbWFnZVByb21wdExhbmd1YWdlIiwiTWFza1JlZmVyZW5jZU1vZGUiLCJDb250cm9sUmVmZXJlbmNlVHlwZSIsIlN1YmplY3RSZWZlcmVuY2VUeXBlIiwiRWRpdE1vZGUiLCJTZWdtZW50TW9kZSIsIlZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGUiLCJWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSIsIlZpZGVvQ29tcHJlc3Npb25RdWFsaXR5IiwiRmlsZVN0YXRlIiwiRmlsZVNvdXJjZSIsIlR1cm5Db21wbGV0ZVJlYXNvbiIsIk1lZGlhTW9kYWxpdHkiLCJTdGFydFNlbnNpdGl2aXR5IiwiRW5kU2Vuc2l0aXZpdHkiLCJBY3Rpdml0eUhhbmRsaW5nIiwiVHVybkNvdmVyYWdlIiwiRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmciLCJTY2FsZSIsIk11c2ljR2VuZXJhdGlvbk1vZGUiLCJMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wiLCJGdW5jdGlvblJlc3BvbnNlQmxvYiIsIkZ1bmN0aW9uUmVzcG9uc2VGaWxlRGF0YSIsIkZ1bmN0aW9uUmVzcG9uc2VQYXJ0IiwiRnVuY3Rpb25SZXNwb25zZSIsImNyZWF0ZVBhcnRGcm9tVXJpIiwidXJpIiwibWltZVR5cGUiLCJmaWxlRGF0YSIsImZpbGVVcmkiLCJjcmVhdGVQYXJ0RnJvbVRleHQiLCJ0ZXh0IiwiY3JlYXRlUGFydEZyb21GdW5jdGlvbkNhbGwiLCJuYW1lIiwiYXJncyIsImZ1bmN0aW9uQ2FsbCIsImNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25SZXNwb25zZSIsImlkIiwicmVzcG9uc2UiLCJmdW5jdGlvblJlc3BvbnNlIiwiY3JlYXRlUGFydEZyb21CYXNlNjQiLCJpbmxpbmVEYXRhIiwiY3JlYXRlUGFydEZyb21Db2RlRXhlY3V0aW9uUmVzdWx0Iiwib3V0Y29tZSIsIm91dHB1dCIsImNvZGVFeGVjdXRpb25SZXN1bHQiLCJjcmVhdGVQYXJ0RnJvbUV4ZWN1dGFibGVDb2RlIiwiY29kZSIsImxhbmd1YWdlIiwiZXhlY3V0YWJsZUNvZGUiLCJfaXNQYXJ0Iiwib2JqIiwiX3RvUGFydHMiLCJwYXJ0T3JTdHJpbmciLCJwYXJ0cyIsInB1c2giLCJwYXJ0IiwiY3JlYXRlVXNlckNvbnRlbnQiLCJyb2xlIiwiY3JlYXRlTW9kZWxDb250ZW50IiwiSHR0cFJlc3BvbnNlIiwiY29uc3RydWN0b3IiLCJoZWFkZXJzIiwicGFpciIsImVudHJpZXMiLCJyZXNwb25zZUludGVybmFsIiwianNvbiIsIkdlbmVyYXRlQ29udGVudFJlc3BvbnNlUHJvbXB0RmVlZGJhY2siLCJHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVVzYWdlTWV0YWRhdGEiLCJHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsImNhbmRpZGF0ZXMiLCJjb250ZW50IiwiY29uc29sZSIsIndhcm4iLCJhbnlUZXh0UGFydFRleHQiLCJub25UZXh0UGFydHMiLCJmaWVsZE5hbWUiLCJmaWVsZFZhbHVlIiwidGhvdWdodCIsIm5vbkRhdGFQYXJ0cyIsImF0b2IiLCJidG9hIiwiZnVuY3Rpb25DYWxscyIsImZpbHRlciIsIl9qIiwiRW1iZWRDb250ZW50UmVzcG9uc2UiLCJHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlIiwiRWRpdEltYWdlUmVzcG9uc2UiLCJVcHNjYWxlSW1hZ2VSZXNwb25zZSIsIlJlY29udGV4dEltYWdlUmVzcG9uc2UiLCJTZWdtZW50SW1hZ2VSZXNwb25zZSIsIkxpc3RNb2RlbHNSZXNwb25zZSIsIkRlbGV0ZU1vZGVsUmVzcG9uc2UiLCJDb3VudFRva2Vuc1Jlc3BvbnNlIiwiQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlIiwiR2VuZXJhdGVWaWRlb3NSZXNwb25zZSIsIkdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uIiwiX2Zyb21BUElSZXNwb25zZSIsImFwaVJlc3BvbnNlIiwiaXNWZXJ0ZXhBSSIsIm9wZXJhdGlvbiIsIm9wIiwiTGlzdFR1bmluZ0pvYnNSZXNwb25zZSIsIkRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSIsIkxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlIiwiTGlzdEZpbGVzUmVzcG9uc2UiLCJDcmVhdGVGaWxlUmVzcG9uc2UiLCJEZWxldGVGaWxlUmVzcG9uc2UiLCJJbmxpbmVkUmVzcG9uc2UiLCJTaW5nbGVFbWJlZENvbnRlbnRSZXNwb25zZSIsIklubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZSIsIkxpc3RCYXRjaEpvYnNSZXNwb25zZSIsIlJlcGxheVJlc3BvbnNlIiwiUmF3UmVmZXJlbmNlSW1hZ2UiLCJ0b1JlZmVyZW5jZUltYWdlQVBJIiwicmVmZXJlbmNlSW1hZ2VBUEkiLCJyZWZlcmVuY2VUeXBlIiwicmVmZXJlbmNlSW1hZ2UiLCJyZWZlcmVuY2VJZCIsIk1hc2tSZWZlcmVuY2VJbWFnZSIsIm1hc2tJbWFnZUNvbmZpZyIsImNvbmZpZyIsIkNvbnRyb2xSZWZlcmVuY2VJbWFnZSIsImNvbnRyb2xJbWFnZUNvbmZpZyIsIlN0eWxlUmVmZXJlbmNlSW1hZ2UiLCJzdHlsZUltYWdlQ29uZmlnIiwiU3ViamVjdFJlZmVyZW5jZUltYWdlIiwic3ViamVjdEltYWdlQ29uZmlnIiwiQ29udGVudFJlZmVyZW5jZUltYWdlIiwiTGl2ZVNlcnZlck1lc3NhZ2UiLCJhbnlUZXh0UGFydEZvdW5kIiwic2VydmVyQ29udGVudCIsIm1vZGVsVHVybiIsIkxpdmVDbGllbnRUb29sUmVzcG9uc2UiLCJMaXZlU2VuZFRvb2xSZXNwb25zZVBhcmFtZXRlcnMiLCJmdW5jdGlvblJlc3BvbnNlcyIsIkxpdmVNdXNpY1NlcnZlck1lc3NhZ2UiLCJhdWRpb0NodW5rIiwiYXVkaW9DaHVua3MiLCJ0TW9kZWwiLCJhcGlDbGllbnQiLCJtb2RlbCIsInN0YXJ0c1dpdGgiLCJpbmRleE9mIiwic3BsaXQiLCJ0Q2FjaGVzTW9kZWwiLCJ0cmFuc2Zvcm1lZE1vZGVsIiwiZ2V0UHJvamVjdCIsImdldExvY2F0aW9uIiwidEJsb2JzIiwiYmxvYnMiLCJibG9iIiwidEJsb2IiLCJ0SW1hZ2VCbG9iIiwidHJhbnNmb3JtZWRCbG9iIiwidEF1ZGlvQmxvYiIsInRQYXJ0Iiwib3JpZ2luIiwidFBhcnRzIiwiX2lzQ29udGVudCIsIl9pc0Z1bmN0aW9uQ2FsbFBhcnQiLCJfaXNGdW5jdGlvblJlc3BvbnNlUGFydCIsInRDb250ZW50IiwidENvbnRlbnRzRm9yRW1iZWQiLCJmbGF0TWFwIiwidENvbnRlbnRzIiwicmVzdWx0IiwiYWNjdW11bGF0ZWRQYXJ0cyIsImlzQ29udGVudEFycmF5IiwiaXNDb250ZW50IiwiZmxhdHRlblR5cGVBcnJheVRvQW55T2YiLCJ0eXBlTGlzdCIsInJlc3VsdGluZ1NjaGVtYSIsImluY2x1ZGVzIiwibGlzdFdpdGhvdXROdWxsIiwidHlwZSIsInZhbHVlcyIsInRvVXBwZXJDYXNlIiwiVFlQRV9VTlNQRUNJRklFRCIsInByb2Nlc3NKc29uU2NoZW1hIiwiX2pzb25TY2hlbWEiLCJnZW5BSVNjaGVtYSIsInNjaGVtYUZpZWxkTmFtZXMiLCJsaXN0U2NoZW1hRmllbGROYW1lcyIsImRpY3RTY2hlbWFGaWVsZE5hbWVzIiwiaW5jb21pbmdBbnlPZiIsImxpc3RTY2hlbWFGaWVsZFZhbHVlIiwiZGljdFNjaGVtYUZpZWxkVmFsdWUiLCJ0U2NoZW1hIiwic2NoZW1hIiwidFNwZWVjaENvbmZpZyIsInNwZWVjaENvbmZpZyIsInZvaWNlQ29uZmlnIiwicHJlYnVpbHRWb2ljZUNvbmZpZyIsInZvaWNlTmFtZSIsInRMaXZlU3BlZWNoQ29uZmlnIiwidFRvb2wiLCJ0b29sIiwiZnVuY3Rpb25EZWNsYXJhdGlvbnMiLCJmdW5jdGlvbkRlY2xhcmF0aW9uIiwicGFyYW1ldGVycyIsInBhcmFtZXRlcnNKc29uU2NoZW1hIiwicmVzcG9uc2VKc29uU2NoZW1hIiwidFRvb2xzIiwidG9vbHMiLCJyZXNvdXJjZU5hbWUiLCJjbGllbnQiLCJyZXNvdXJjZVByZWZpeCIsInNwbGl0c0FmdGVyUHJlZml4Iiwic2hvdWxkQXBwZW5kUHJlZml4IiwidENhY2hlZENvbnRlbnROYW1lIiwidFR1bmluZ0pvYlN0YXR1cyIsInN0YXR1cyIsInRCeXRlcyIsImZyb21JbWFnZUJ5dGVzIiwiX2lzRmlsZSIsImlzR2VuZXJhdGVkVmlkZW8iLCJpc1ZpZGVvIiwidEZpbGVOYW1lIiwidmlkZW8iLCJzdWZmaXgiLCJ0TW9kZWxzVXJsIiwiYmFzZU1vZGVscyIsInJlcyIsInRFeHRyYWN0TW9kZWxzIiwiaGFzRmllbGQiLCJtY3BUb0dlbWluaVRvb2wiLCJtY3BUb29sIiwibWNwVG9vbFNjaGVtYSIsImRlc2NyaXB0aW9uIiwiYmVoYXZpb3IiLCJnZW1pbmlUb29sIiwibWNwVG9vbHNUb0dlbWluaVRvb2wiLCJtY3BUb29scyIsInRvb2xOYW1lcyIsIlNldCIsIm1jcFRvb2xOYW1lIiwiaGFzIiwiYWRkIiwidEJhdGNoSm9iU291cmNlIiwic3JjIiwic291cmNlT2JqIiwiZm9ybWF0IiwiZ2NzVXJpIiwiYmlncXVlcnlVcmkiLCJmaWxlTmFtZSIsImlubGluZWRSZXF1ZXN0cyIsInZlcnRleFNvdXJjZXNDb3VudCIsIkJvb2xlYW4iLCJtbGRldlNvdXJjZXNDb3VudCIsInRCYXRjaEpvYkRlc3RpbmF0aW9uIiwiZGVzdCIsImRlc3RTdHJpbmciLCJ0UmVjdkJhdGNoSm9iRGVzdGluYXRpb24iLCJpbmxpbmVSZXNwb25zZXNWYWwiLCJpbmxpbmVSZXNwb25zZXNPYmoiLCJyZXNwb25zZXNBcnJheSIsImhhc0VtYmVkZGluZyIsInJlc3BvbnNlSXRlbSIsInJlc3BvbnNlSXRlbU9iaiIsInJlc3BvbnNlVmFsIiwicmVzcG9uc2VPYmoiLCJ0QmF0Y2hKb2JOYW1lIiwibmFtZVN0cmluZyIsIm1sZGV2UGF0dGVybiIsInRlc3QiLCJwb3AiLCJ2ZXJ0ZXhQYXR0ZXJuIiwidEpvYlN0YXRlIiwic3RhdGUiLCJzdGF0ZVN0cmluZyIsImJhdGNoSm9iRGVzdGluYXRpb25Gcm9tTWxkZXYiLCJmcm9tRmlsZU5hbWUiLCJmcm9tSW5saW5lZFJlc3BvbnNlcyIsImlubGluZWRSZXNwb25zZUZyb21NbGRldiIsImZyb21JbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzIiwiaW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2IiwiYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21WZXJ0ZXgiLCJmcm9tRm9ybWF0IiwiZnJvbUdjc1VyaSIsImZyb21CaWdxdWVyeVVyaSIsImJhdGNoSm9iRGVzdGluYXRpb25Ub1ZlcnRleCIsImJhdGNoSm9iRnJvbU1sZGV2IiwiZnJvbURpc3BsYXlOYW1lIiwiZnJvbVN0YXRlIiwiZnJvbUNyZWF0ZVRpbWUiLCJmcm9tRW5kVGltZSIsImZyb21VcGRhdGVUaW1lIiwiZnJvbU1vZGVsIiwiZnJvbURlc3QiLCJiYXRjaEpvYkZyb21WZXJ0ZXgiLCJqb2JFcnJvckZyb21WZXJ0ZXgiLCJmcm9tU3RhcnRUaW1lIiwiZnJvbVNyYyIsImJhdGNoSm9iU291cmNlRnJvbVZlcnRleCIsImJhdGNoSm9iU291cmNlVG9NbGRldiIsImZyb21JbmxpbmVkUmVxdWVzdHMiLCJpbmxpbmVkUmVxdWVzdFRvTWxkZXYiLCJiYXRjaEpvYlNvdXJjZVRvVmVydGV4IiwiYmxvYkZyb21NbGRldiQyIiwiZnJvbURhdGEiLCJibG9iVG9NbGRldiQ0IiwiY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4IiwiY2FuZGlkYXRlRnJvbU1sZGV2JDEiLCJmcm9tQ29udGVudCIsImNvbnRlbnRGcm9tTWxkZXYkMiIsImZyb21DaXRhdGlvbk1ldGFkYXRhIiwiY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxIiwiZnJvbVRva2VuQ291bnQiLCJmcm9tRmluaXNoUmVhc29uIiwiZnJvbVVybENvbnRleHRNZXRhZGF0YSIsInVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldiQyIiwiZnJvbUF2Z0xvZ3Byb2JzIiwiZnJvbUdyb3VuZGluZ01ldGFkYXRhIiwiZnJvbUluZGV4IiwiZnJvbUxvZ3Byb2JzUmVzdWx0IiwiZnJvbVNhZmV0eVJhdGluZ3MiLCJmcm9tQ2l0YXRpb25zIiwiY29tcHV0ZXJVc2VUb01sZGV2JDQiLCJmcm9tRW52aXJvbm1lbnQiLCJmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zIiwiY29udGVudEVtYmVkZGluZ0Zyb21NbGRldiQxIiwiZnJvbVZhbHVlcyIsImZyb21QYXJ0cyIsInBhcnRGcm9tTWxkZXYkMiIsImZyb21Sb2xlIiwiY29udGVudFRvTWxkZXYkNCIsInBhcnRUb01sZGV2JDQiLCJjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvTWxkZXYiLCJwYXJlbnRPYmplY3QiLCJjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvVmVydGV4IiwiY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21Db25maWciLCJjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCIsImNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYkNvbmZpZ1RvTWxkZXYiLCJjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImVtYmVkZGluZ3NCYXRjaEpvYlNvdXJjZVRvTWxkZXYiLCJkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2IiwiZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJkZWxldGVSZXNvdXJjZUpvYkZyb21NbGRldiIsImZyb21TZGtIdHRwUmVzcG9uc2UiLCJqb2JFcnJvckZyb21NbGRldiIsImRlbGV0ZVJlc291cmNlSm9iRnJvbVZlcnRleCIsImR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDQiLCJmcm9tTW9kZSIsImZyb21EeW5hbWljVGhyZXNob2xkIiwiZW1iZWRDb250ZW50QmF0Y2hUb01sZGV2IiwiZnJvbUNvbnRlbnRzIiwiZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldiQxIiwiZnJvbVRhc2tUeXBlIiwiZnJvbVRpdGxlIiwiZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5IiwiZmlsZURhdGFGcm9tTWxkZXYkMiIsImZyb21GaWxlVXJpIiwiZmlsZURhdGFUb01sZGV2JDQiLCJmdW5jdGlvbkNhbGxGcm9tTWxkZXYkMiIsImZyb21JZCIsImZyb21BcmdzIiwiZnVuY3Rpb25DYWxsVG9NbGRldiQ0IiwiZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQyIiwiZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzIiwiZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkNCIsImZyb21CZWhhdmlvciIsImZyb21EZXNjcmlwdGlvbiIsImZyb21QYXJhbWV0ZXJzIiwiZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hIiwiZnJvbVJlc3BvbnNlSnNvblNjaGVtYSIsImdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYkMSIsImZyb21TeXN0ZW1JbnN0cnVjdGlvbiIsImZyb21UZW1wZXJhdHVyZSIsImZyb21Ub3BQIiwiZnJvbVRvcEsiLCJmcm9tQ2FuZGlkYXRlQ291bnQiLCJmcm9tTWF4T3V0cHV0VG9rZW5zIiwiZnJvbVN0b3BTZXF1ZW5jZXMiLCJmcm9tUmVzcG9uc2VMb2dwcm9icyIsImZyb21Mb2dwcm9icyIsImZyb21QcmVzZW5jZVBlbmFsdHkiLCJmcm9tRnJlcXVlbmN5UGVuYWx0eSIsImZyb21TZWVkIiwiZnJvbVJlc3BvbnNlTWltZVR5cGUiLCJmcm9tUmVzcG9uc2VTY2hlbWEiLCJzY2hlbWFUb01sZGV2JDEiLCJmcm9tU2FmZXR5U2V0dGluZ3MiLCJzYWZldHlTZXR0aW5nVG9NbGRldiQxIiwiZnJvbVRvb2xzIiwidG9vbFRvTWxkZXYkNCIsImZyb21Ub29sQ29uZmlnIiwidG9vbENvbmZpZ1RvTWxkZXYkMiIsImZyb21DYWNoZWRDb250ZW50IiwiZnJvbVJlc3BvbnNlTW9kYWxpdGllcyIsImZyb21NZWRpYVJlc29sdXRpb24iLCJmcm9tU3BlZWNoQ29uZmlnIiwic3BlZWNoQ29uZmlnVG9NbGRldiQzIiwiZnJvbVRoaW5raW5nQ29uZmlnIiwidGhpbmtpbmdDb25maWdUb01sZGV2JDMiLCJmcm9tSW1hZ2VDb25maWciLCJpbWFnZUNvbmZpZ1RvTWxkZXYkMSIsImdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2JDEiLCJmcm9tQ2FuZGlkYXRlcyIsImZyb21Nb2RlbFZlcnNpb24iLCJmcm9tUHJvbXB0RmVlZGJhY2siLCJmcm9tUmVzcG9uc2VJZCIsImZyb21Vc2FnZU1ldGFkYXRhIiwiZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImdldEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4IiwiZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQ0IiwiZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWciLCJnb29nbGVTZWFyY2hUb01sZGV2JDQiLCJmcm9tVGltZVJhbmdlRmlsdGVyIiwiaW50ZXJ2YWxUb01sZGV2JDQiLCJmcm9tQXNwZWN0UmF0aW8iLCJzaW5nbGVFbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldiIsImZyb21EZXRhaWxzIiwiZnJvbUNvZGUiLCJmcm9tTWVzc2FnZSIsImxhdExuZ1RvTWxkZXYkMiIsImZyb21MYXRpdHVkZSIsImZyb21Mb25naXR1ZGUiLCJsaXN0QmF0Y2hKb2JzQ29uZmlnVG9NbGRldiIsImZyb21QYWdlU2l6ZSIsImZyb21QYWdlVG9rZW4iLCJsaXN0QmF0Y2hKb2JzQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tRmlsdGVyIiwibGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb1ZlcnRleCIsImxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21NbGRldiIsImZyb21OZXh0UGFnZVRva2VuIiwiZnJvbUJhdGNoSm9icyIsImxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21WZXJ0ZXgiLCJtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMyIsImZyb21TcGVha2VyVm9pY2VDb25maWdzIiwic3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQzIiwiZnJvbVZpZGVvTWV0YWRhdGEiLCJ2aWRlb01ldGFkYXRhRnJvbU1sZGV2JDIiLCJmcm9tVGhvdWdodCIsImZyb21JbmxpbmVEYXRhIiwiZnJvbUZpbGVEYXRhIiwiZnJvbVRob3VnaHRTaWduYXR1cmUiLCJmcm9tRnVuY3Rpb25DYWxsIiwiZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQiLCJmcm9tRXhlY3V0YWJsZUNvZGUiLCJmcm9tRnVuY3Rpb25SZXNwb25zZSIsImZyb21UZXh0IiwidmlkZW9NZXRhZGF0YVRvTWxkZXYkNCIsInByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2JDMiLCJmcm9tVm9pY2VOYW1lIiwicmV0cmlldmFsQ29uZmlnVG9NbGRldiQyIiwiZnJvbUxhdExuZyIsImZyb21MYW5ndWFnZUNvZGUiLCJmcm9tQ2F0ZWdvcnkiLCJmcm9tVGhyZXNob2xkIiwiZnJvbUFueU9mIiwiZnJvbURlZmF1bHQiLCJmcm9tRW51bSIsImZyb21FeGFtcGxlIiwiZnJvbUl0ZW1zIiwiZnJvbU1heEl0ZW1zIiwiZnJvbU1heExlbmd0aCIsImZyb21NYXhQcm9wZXJ0aWVzIiwiZnJvbU1heGltdW0iLCJmcm9tTWluSXRlbXMiLCJmcm9tTWluTGVuZ3RoIiwiZnJvbU1pblByb3BlcnRpZXMiLCJmcm9tTWluaW11bSIsImZyb21OdWxsYWJsZSIsImZyb21QYXR0ZXJuIiwiZnJvbVByb3BlcnRpZXMiLCJmcm9tUHJvcGVydHlPcmRlcmluZyIsImZyb21SZXF1aXJlZCIsImZyb21UeXBlIiwiZnJvbUVtYmVkZGluZyIsImZyb21TcGVha2VyIiwiZnJvbVZvaWNlQ29uZmlnIiwidm9pY2VDb25maWdUb01sZGV2JDMiLCJmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWciLCJmcm9tSW5jbHVkZVRob3VnaHRzIiwiZnJvbVRoaW5raW5nQnVkZ2V0IiwiZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyIsImZyb21SZXRyaWV2YWxDb25maWciLCJmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMiLCJmcm9tR29vZ2xlU2VhcmNoIiwiZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCIsImZyb21VcmxDb250ZXh0IiwidXJsQ29udGV4dFRvTWxkZXYkNCIsImZyb21Db21wdXRlclVzZSIsImZyb21Db2RlRXhlY3V0aW9uIiwiZnJvbVVybE1ldGFkYXRhIiwidXJsTWV0YWRhdGFGcm9tTWxkZXYkMiIsImZyb21SZXRyaWV2ZWRVcmwiLCJmcm9tVXJsUmV0cmlldmFsU3RhdHVzIiwiZnJvbUZwcyIsImZyb21FbmRPZmZzZXQiLCJmcm9tU3RhcnRPZmZzZXQiLCJmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyIsIlBhZ2VkSXRlbSIsIlBhZ2VyIiwicmVxdWVzdCIsInBhcmFtcyIsInBhZ2VJbnRlcm5hbCIsInBhcmFtc0ludGVybmFsIiwicmVxdWVzdEludGVybmFsIiwiaW5pdCIsIm5hbWVJbnRlcm5hbCIsInNka0h0dHBSZXNwb25zZUludGVybmFsIiwic2RrSHR0cFJlc3BvbnNlIiwiaWR4SW50ZXJuYWwiLCJyZXF1ZXN0UGFyYW1zIiwicGFnZUludGVybmFsU2l6ZSIsImluaXROZXh0UGFnZSIsInBhZ2UiLCJwYWdlU2l6ZSIsInBhZ2VMZW5ndGgiLCJnZXRJdGVtIiwiaW5kZXgiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwibmV4dCIsImhhc05leHRQYWdlIiwibmV4dFBhZ2UiLCJkb25lIiwicmV0dXJuIiwiQmF0Y2hlcyIsImNyZWF0ZSIsImZvcm1hdERlc3RpbmF0aW9uIiwiY3JlYXRlSW50ZXJuYWwiLCJpc19pbmxpbmVkIiwiY3JlYXRlSW5saW5lZEdlbmVyYXRlQ29udGVudFJlcXVlc3QiLCJwYXRoIiwicmVxdWVzdEJvZHkiLCJib2R5IiwicXVlcnlQYXJhbXMiLCJKU09OIiwic3RyaW5naWZ5IiwiaHR0cE1ldGhvZCIsImFib3J0U2lnbmFsIiwidGhlbiIsImh0dHBSZXNwb25zZSIsInJlc3AiLCJjcmVhdGVFbWJlZGRpbmdzIiwiY3JlYXRlRW1iZWRkaW5nc0ludGVybmFsIiwiY3JlYXRlSW5saW5lZEVtYmVkQ29udGVudFJlcXVlc3QiLCJsaXN0IiwiUEFHRURfSVRFTV9CQVRDSF9KT0JTIiwieCIsImxpc3RJbnRlcm5hbCIsInVybFBhcmFtcyIsImJhdGNoIiwiaW5wdXRDb25maWciLCJyZXF1ZXN0c1dyYXBwZXIiLCJyZXF1ZXN0cyIsIm5ld1JlcXVlc3RzIiwicmVxdWVzdERpY3QiLCJzeXN0ZW1JbnN0cnVjdGlvblZhbHVlIiwicmVxdWVzdENvbnRlbnQiLCJpbm5lclJlcXVlc3QiLCJnZXRHY3NVcmkiLCJnZXRCaWdxdWVyeVVyaSIsIm5ld0NvbmZpZyIsInRpbWVzdGFtcFN0ciIsIkRhdGUiLCJub3ciLCJ0b1N0cmluZyIsImRpc3BsYXlOYW1lIiwiZ2V0IiwiY2FuY2VsIiwianNvblJlc3BvbnNlIiwidHlwZWRSZXNwIiwiZGVsZXRlIiwiYXBpS2V5Q29uZmlnVG9WZXJ0ZXgkMiIsImZyb21BcGlLZXlTdHJpbmciLCJhdXRoQ29uZmlnVG9WZXJ0ZXgkMiIsImZyb21BcGlLZXlDb25maWciLCJmcm9tQXV0aFR5cGUiLCJmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWciLCJmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyIsImZyb21PYXV0aENvbmZpZyIsImZyb21PaWRjQ29uZmlnIiwiYmxvYlRvTWxkZXYkMyIsImJsb2JUb1ZlcnRleCQyIiwiY2FjaGVkQ29udGVudEZyb21NbGRldiIsImZyb21FeHBpcmVUaW1lIiwiY2FjaGVkQ29udGVudEZyb21WZXJ0ZXgiLCJjb21wdXRlclVzZVRvTWxkZXYkMyIsImNvbXB1dGVyVXNlVG9WZXJ0ZXgkMiIsImNvbnRlbnRUb01sZGV2JDMiLCJwYXJ0VG9NbGRldiQzIiwiY29udGVudFRvVmVydGV4JDIiLCJwYXJ0VG9WZXJ0ZXgkMiIsImNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2IiwiZnJvbVR0bCIsInRvb2xUb01sZGV2JDMiLCJ0b29sQ29uZmlnVG9NbGRldiQxIiwiY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4IiwidG9vbFRvVmVydGV4JDIiLCJ0b29sQ29uZmlnVG9WZXJ0ZXgkMSIsImZyb21LbXNLZXlOYW1lIiwiY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwiY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsImRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJkZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYiLCJkZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4IiwiZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMyIsImR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleCQyIiwiZW50ZXJwcmlzZVdlYlNlYXJjaFRvVmVydGV4JDIiLCJmcm9tRXhjbHVkZURvbWFpbnMiLCJmaWxlRGF0YVRvTWxkZXYkMyIsImZpbGVEYXRhVG9WZXJ0ZXgkMiIsImZ1bmN0aW9uQ2FsbFRvTWxkZXYkMyIsImZ1bmN0aW9uQ2FsbFRvVmVydGV4JDIiLCJmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDEiLCJmdW5jdGlvbkNhbGxpbmdDb25maWdUb1ZlcnRleCQxIiwiZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkMyIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQyIiwiZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwiZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImdvb2dsZU1hcHNUb1ZlcnRleCQyIiwiZnJvbUF1dGhDb25maWciLCJnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDMiLCJnb29nbGVTZWFyY2hSZXRyaWV2YWxUb1ZlcnRleCQyIiwiZ29vZ2xlU2VhcmNoVG9NbGRldiQzIiwiaW50ZXJ2YWxUb01sZGV2JDMiLCJnb29nbGVTZWFyY2hUb1ZlcnRleCQyIiwiaW50ZXJ2YWxUb1ZlcnRleCQyIiwibGF0TG5nVG9NbGRldiQxIiwibGF0TG5nVG9WZXJ0ZXgkMSIsImxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvTWxkZXYiLCJsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb1ZlcnRleCIsImxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvVmVydGV4IiwibGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tQ2FjaGVkQ29udGVudHMiLCJsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21WZXJ0ZXgiLCJ2aWRlb01ldGFkYXRhVG9NbGRldiQzIiwidmlkZW9NZXRhZGF0YVRvVmVydGV4JDIiLCJyZXRyaWV2YWxDb25maWdUb01sZGV2JDEiLCJyZXRyaWV2YWxDb25maWdUb1ZlcnRleCQxIiwidXJsQ29udGV4dFRvTWxkZXYkMyIsImZyb21SZXRyaWV2YWwiLCJmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCIsImZyb21Hb29nbGVNYXBzIiwidXJsQ29udGV4dFRvVmVydGV4JDIiLCJ1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldiIsInVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleCIsInVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsInVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJDYWNoZXMiLCJQQUdFRF9JVEVNX0NBQ0hFRF9DT05URU5UUyIsInVwZGF0ZSIsIl9fdmFsdWVzIiwibyIsInMiLCJpdGVyYXRvciIsIm0iLCJfX2F3YWl0IiwidiIsIl9fYXN5bmNHZW5lcmF0b3IiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsImdlbmVyYXRvciIsImciLCJhcHBseSIsInEiLCJBc3luY0l0ZXJhdG9yIiwidmVyYiIsImF3YWl0UmV0dXJuIiwiZiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibiIsImEiLCJiIiwicmVzdW1lIiwic3RlcCIsImUiLCJzZXR0bGUiLCJyIiwiZnVsZmlsbCIsInNoaWZ0IiwiX19hc3luY1ZhbHVlcyIsIlN1cHByZXNzZWRFcnJvciIsInN1cHByZXNzZWQiLCJtZXNzYWdlIiwiaXNWYWxpZFJlc3BvbnNlIiwiaXNWYWxpZENvbnRlbnQiLCJ2YWxpZGF0ZUhpc3RvcnkiLCJoaXN0b3J5IiwiZXh0cmFjdEN1cmF0ZWRIaXN0b3J5IiwiY29tcHJlaGVuc2l2ZUhpc3RvcnkiLCJjdXJhdGVkSGlzdG9yeSIsIm1vZGVsT3V0cHV0IiwiaXNWYWxpZCIsIkNoYXRzIiwibW9kZWxzTW9kdWxlIiwiQ2hhdCIsInN0cnVjdHVyZWRDbG9uZSIsInNlbmRQcm9taXNlIiwic2VuZE1lc3NhZ2UiLCJpbnB1dENvbnRlbnQiLCJyZXNwb25zZVByb21pc2UiLCJnZW5lcmF0ZUNvbnRlbnQiLCJjb250ZW50cyIsImdldEhpc3RvcnkiLCJjb25jYXQiLCJvdXRwdXRDb250ZW50IiwiZnVsbEF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkiLCJhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5IiwicmVjb3JkSGlzdG9yeSIsImNhdGNoIiwic2VuZE1lc3NhZ2VTdHJlYW0iLCJzdHJlYW1SZXNwb25zZSIsImdlbmVyYXRlQ29udGVudFN0cmVhbSIsInByb2Nlc3NTdHJlYW1SZXNwb25zZSIsImN1cmF0ZWQiLCJhcmd1bWVudHMiLCJwcm9jZXNzU3RyZWFtUmVzcG9uc2VfMSIsImVfMSIsInN0cmVhbVJlc3BvbnNlXzEiLCJzdHJlYW1SZXNwb25zZV8xXzEiLCJjaHVuayIsImVfMV8xIiwidXNlcklucHV0Iiwib3V0cHV0Q29udGVudHMiLCJldmVyeSIsIkFwaUVycm9yIiwib3B0aW9ucyIsInNldFByb3RvdHlwZU9mIiwiY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbUZpbGUiLCJmaWxlVG9NbGRldiIsImNyZWF0ZUZpbGVSZXNwb25zZUZyb21NbGRldiIsImRlbGV0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldiIsImRlbGV0ZUZpbGVSZXNwb25zZUZyb21NbGRldiIsImZpbGVGcm9tTWxkZXYiLCJmcm9tU2l6ZUJ5dGVzIiwiZnJvbUV4cGlyYXRpb25UaW1lIiwiZnJvbVNoYTI1Nkhhc2giLCJmcm9tRG93bmxvYWRVcmkiLCJmcm9tU291cmNlIiwiZmlsZVN0YXR1c0Zyb21NbGRldiIsImZpbGVTdGF0dXNUb01sZGV2IiwiZ2V0RmlsZVBhcmFtZXRlcnNUb01sZGV2IiwibGlzdEZpbGVzQ29uZmlnVG9NbGRldiIsImxpc3RGaWxlc1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdEZpbGVzUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tRmlsZXMiLCJGaWxlcyIsIlBBR0VEX0lURU1fRklMRVMiLCJ1cGxvYWQiLCJ1cGxvYWRGaWxlIiwiZmlsZSIsImRvd25sb2FkIiwiZG93bmxvYWRGaWxlIiwiYWN0aXZpdHlFbmRUb01sZGV2IiwiYWN0aXZpdHlFbmRUb1ZlcnRleCIsImFjdGl2aXR5U3RhcnRUb01sZGV2IiwiYWN0aXZpdHlTdGFydFRvVmVydGV4IiwiYXBpS2V5Q29uZmlnVG9WZXJ0ZXgkMSIsImF1ZGlvQ2h1bmtGcm9tTWxkZXYiLCJmcm9tU291cmNlTWV0YWRhdGEiLCJsaXZlTXVzaWNTb3VyY2VNZXRhZGF0YUZyb21NbGRldiIsImF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvTWxkZXYkMSIsImF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvVmVydGV4IiwiYXV0aENvbmZpZ1RvVmVydGV4JDEiLCJhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvblRvTWxkZXYkMSIsImZyb21EaXNhYmxlZCIsImZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkiLCJmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSIsImZyb21QcmVmaXhQYWRkaW5nTXMiLCJmcm9tU2lsZW5jZUR1cmF0aW9uTXMiLCJhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvblRvVmVydGV4IiwiYmxvYkZyb21NbGRldiQxIiwiYmxvYkZyb21WZXJ0ZXgkMSIsImJsb2JUb01sZGV2JDIiLCJibG9iVG9WZXJ0ZXgkMSIsImNvbXB1dGVyVXNlVG9NbGRldiQyIiwiY29tcHV0ZXJVc2VUb1ZlcnRleCQxIiwiY29udGVudEZyb21NbGRldiQxIiwicGFydEZyb21NbGRldiQxIiwiY29udGVudEZyb21WZXJ0ZXgkMSIsInBhcnRGcm9tVmVydGV4JDEiLCJjb250ZW50VG9NbGRldiQyIiwicGFydFRvTWxkZXYkMiIsImNvbnRlbnRUb1ZlcnRleCQxIiwicGFydFRvVmVydGV4JDEiLCJjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb01sZGV2JDEiLCJmcm9tVHJpZ2dlclRva2VucyIsImZyb21TbGlkaW5nV2luZG93Iiwic2xpZGluZ1dpbmRvd1RvTWxkZXYkMSIsImNvbnRleHRXaW5kb3dDb21wcmVzc2lvbkNvbmZpZ1RvVmVydGV4Iiwic2xpZGluZ1dpbmRvd1RvVmVydGV4IiwiZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMiIsImR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleCQxIiwiZW50ZXJwcmlzZVdlYlNlYXJjaFRvVmVydGV4JDEiLCJmaWxlRGF0YUZyb21NbGRldiQxIiwiZmlsZURhdGFGcm9tVmVydGV4JDEiLCJmaWxlRGF0YVRvTWxkZXYkMiIsImZpbGVEYXRhVG9WZXJ0ZXgkMSIsImZ1bmN0aW9uQ2FsbEZyb21NbGRldiQxIiwiZnVuY3Rpb25DYWxsRnJvbVZlcnRleCQxIiwiZnVuY3Rpb25DYWxsVG9NbGRldiQyIiwiZnVuY3Rpb25DYWxsVG9WZXJ0ZXgkMSIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDIiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMSIsImdvb2dsZU1hcHNUb1ZlcnRleCQxIiwiZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQyIiwiZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgkMSIsImdvb2dsZVNlYXJjaFRvTWxkZXYkMiIsImludGVydmFsVG9NbGRldiQyIiwiZ29vZ2xlU2VhcmNoVG9WZXJ0ZXgkMSIsImludGVydmFsVG9WZXJ0ZXgkMSIsImxpdmVDb25uZWN0Q29uZmlnVG9NbGRldiQxIiwiZnJvbUdlbmVyYXRpb25Db25maWciLCJzcGVlY2hDb25maWdUb01sZGV2JDIiLCJ0aGlua2luZ0NvbmZpZ1RvTWxkZXYkMiIsImZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2ciLCJ0b29sVG9NbGRldiQyIiwiZnJvbVNlc3Npb25SZXN1bXB0aW9uIiwic2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2JDEiLCJmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24iLCJmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uIiwiZnJvbVJlYWx0aW1lSW5wdXRDb25maWciLCJyZWFsdGltZUlucHV0Q29uZmlnVG9NbGRldiQxIiwiZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiIsImZyb21Qcm9hY3Rpdml0eSIsInByb2FjdGl2aXR5Q29uZmlnVG9NbGRldiQxIiwibGl2ZUNvbm5lY3RDb25maWdUb1ZlcnRleCIsInNwZWVjaENvbmZpZ1RvVmVydGV4JDEiLCJ0aGlua2luZ0NvbmZpZ1RvVmVydGV4JDEiLCJ0b29sVG9WZXJ0ZXgkMSIsInNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9WZXJ0ZXgiLCJyZWFsdGltZUlucHV0Q29uZmlnVG9WZXJ0ZXgiLCJwcm9hY3Rpdml0eUNvbmZpZ1RvVmVydGV4IiwibGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9NbGRldiIsImxpdmVDb25uZWN0UGFyYW1ldGVyc1RvVmVydGV4IiwibGl2ZU11c2ljQ2xpZW50Q29udGVudEZyb21NbGRldiIsImZyb21XZWlnaHRlZFByb21wdHMiLCJ3ZWlnaHRlZFByb21wdEZyb21NbGRldiIsImxpdmVNdXNpY0NsaWVudENvbnRlbnRUb01sZGV2Iiwid2VpZ2h0ZWRQcm9tcHRUb01sZGV2IiwibGl2ZU11c2ljQ2xpZW50TWVzc2FnZVRvTWxkZXYiLCJmcm9tU2V0dXAiLCJsaXZlTXVzaWNDbGllbnRTZXR1cFRvTWxkZXYiLCJmcm9tQ2xpZW50Q29udGVudCIsImZyb21NdXNpY0dlbmVyYXRpb25Db25maWciLCJsaXZlTXVzaWNHZW5lcmF0aW9uQ29uZmlnVG9NbGRldiIsImZyb21QbGF5YmFja0NvbnRyb2wiLCJsaXZlTXVzaWNGaWx0ZXJlZFByb21wdEZyb21NbGRldiIsImZyb21GaWx0ZXJlZFJlYXNvbiIsImxpdmVNdXNpY0dlbmVyYXRpb25Db25maWdGcm9tTWxkZXYiLCJmcm9tR3VpZGFuY2UiLCJmcm9tQnBtIiwiZnJvbURlbnNpdHkiLCJmcm9tQnJpZ2h0bmVzcyIsImZyb21TY2FsZSIsImZyb21NdXRlQmFzcyIsImZyb21NdXRlRHJ1bXMiLCJmcm9tT25seUJhc3NBbmREcnVtcyIsImZyb21NdXNpY0dlbmVyYXRpb25Nb2RlIiwibGl2ZU11c2ljU2VydmVyQ29udGVudEZyb21NbGRldiIsImZyb21BdWRpb0NodW5rcyIsImxpdmVNdXNpY1NlcnZlck1lc3NhZ2VGcm9tTWxkZXYiLCJmcm9tU2V0dXBDb21wbGV0ZSIsImxpdmVNdXNpY1NlcnZlclNldHVwQ29tcGxldGVGcm9tTWxkZXYiLCJmcm9tU2VydmVyQ29udGVudCIsImZyb21GaWx0ZXJlZFByb21wdCIsImxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2IiwibGl2ZU11c2ljU2V0V2VpZ2h0ZWRQcm9tcHRzUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21NZWRpYSIsImZyb21BdWRpbyIsImZyb21BdWRpb1N0cmVhbUVuZCIsImZyb21BY3Rpdml0eVN0YXJ0IiwiZnJvbUFjdGl2aXR5RW5kIiwibGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvVmVydGV4IiwibGl2ZVNlcnZlckNvbnRlbnRGcm9tTWxkZXYiLCJmcm9tTW9kZWxUdXJuIiwiZnJvbVR1cm5Db21wbGV0ZSIsImZyb21JbnRlcnJ1cHRlZCIsImZyb21HZW5lcmF0aW9uQ29tcGxldGUiLCJmcm9tSW5wdXRUcmFuc2NyaXB0aW9uIiwidHJhbnNjcmlwdGlvbkZyb21NbGRldiIsImZyb21PdXRwdXRUcmFuc2NyaXB0aW9uIiwidXJsQ29udGV4dE1ldGFkYXRhRnJvbU1sZGV2JDEiLCJmcm9tVHVybkNvbXBsZXRlUmVhc29uIiwiZnJvbVdhaXRpbmdGb3JJbnB1dCIsImxpdmVTZXJ2ZXJDb250ZW50RnJvbVZlcnRleCIsInRyYW5zY3JpcHRpb25Gcm9tVmVydGV4IiwibGl2ZVNlcnZlckdvQXdheUZyb21NbGRldiIsImZyb21UaW1lTGVmdCIsImxpdmVTZXJ2ZXJHb0F3YXlGcm9tVmVydGV4IiwibGl2ZVNlcnZlck1lc3NhZ2VGcm9tTWxkZXYiLCJsaXZlU2VydmVyU2V0dXBDb21wbGV0ZUZyb21NbGRldiIsImZyb21Ub29sQ2FsbCIsImxpdmVTZXJ2ZXJUb29sQ2FsbEZyb21NbGRldiIsImZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiIsImxpdmVTZXJ2ZXJUb29sQ2FsbENhbmNlbGxhdGlvbkZyb21NbGRldiIsInVzYWdlTWV0YWRhdGFGcm9tTWxkZXYiLCJmcm9tR29Bd2F5IiwiZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlIiwibGl2ZVNlcnZlclNlc3Npb25SZXN1bXB0aW9uVXBkYXRlRnJvbU1sZGV2IiwibGl2ZVNlcnZlck1lc3NhZ2VGcm9tVmVydGV4IiwibGl2ZVNlcnZlclNldHVwQ29tcGxldGVGcm9tVmVydGV4IiwibGl2ZVNlcnZlclRvb2xDYWxsRnJvbVZlcnRleCIsImxpdmVTZXJ2ZXJUb29sQ2FsbENhbmNlbGxhdGlvbkZyb21WZXJ0ZXgiLCJ1c2FnZU1ldGFkYXRhRnJvbVZlcnRleCIsImxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21WZXJ0ZXgiLCJmcm9tTmV3SGFuZGxlIiwiZnJvbVJlc3VtYWJsZSIsImZyb21MYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXgiLCJmcm9tU2Vzc2lvbklkIiwiZnJvbUlkcyIsImZyb21GdW5jdGlvbkNhbGxzIiwibW9kYWxpdHlUb2tlbkNvdW50RnJvbU1sZGV2IiwiZnJvbU1vZGFsaXR5IiwibW9kYWxpdHlUb2tlbkNvdW50RnJvbVZlcnRleCIsIm11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQyIiwic3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQyIiwidmlkZW9NZXRhZGF0YUZyb21NbGRldiQxIiwidmlkZW9NZXRhZGF0YUZyb21WZXJ0ZXgkMSIsInZpZGVvTWV0YWRhdGFUb01sZGV2JDIiLCJ2aWRlb01ldGFkYXRhVG9WZXJ0ZXgkMSIsInByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2JDIiLCJwcmVidWlsdFZvaWNlQ29uZmlnVG9WZXJ0ZXgkMSIsImZyb21Qcm9hY3RpdmVBdWRpbyIsImZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiIsImZyb21BY3Rpdml0eUhhbmRsaW5nIiwiZnJvbVR1cm5Db3ZlcmFnZSIsImZyb21IYW5kbGUiLCJmcm9tVHJhbnNwYXJlbnQiLCJmcm9tVGFyZ2V0VG9rZW5zIiwidm9pY2VDb25maWdUb01sZGV2JDIiLCJ2b2ljZUNvbmZpZ1RvVmVydGV4JDEiLCJ1cmxDb250ZXh0VG9NbGRldiQyIiwidXJsQ29udGV4dFRvVmVydGV4JDEiLCJmcm9tRmluaXNoZWQiLCJ1cmxNZXRhZGF0YUZyb21NbGRldiQxIiwiZnJvbVByb21wdFRva2VuQ291bnQiLCJmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQiLCJmcm9tUmVzcG9uc2VUb2tlbkNvdW50IiwiZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50IiwiZnJvbVRob3VnaHRzVG9rZW5Db3VudCIsImZyb21Ub3RhbFRva2VuQ291bnQiLCJmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyIsImZyb21DYWNoZVRva2Vuc0RldGFpbHMiLCJmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzIiwiZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzIiwiZnJvbVRyYWZmaWNUeXBlIiwiZnJvbVdlaWdodCIsImFwaUtleUNvbmZpZ1RvVmVydGV4IiwiYXV0aENvbmZpZ1RvVmVydGV4IiwiYmxvYkZyb21NbGRldiIsImJsb2JGcm9tVmVydGV4IiwiYmxvYlRvTWxkZXYkMSIsImJsb2JUb1ZlcnRleCIsImNhbmRpZGF0ZUZyb21NbGRldiIsImNvbnRlbnRGcm9tTWxkZXYiLCJjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2IiwidXJsQ29udGV4dE1ldGFkYXRhRnJvbU1sZGV2IiwiY2FuZGlkYXRlRnJvbVZlcnRleCIsImNvbnRlbnRGcm9tVmVydGV4IiwiY2l0YXRpb25NZXRhZGF0YUZyb21WZXJ0ZXgiLCJmcm9tRmluaXNoTWVzc2FnZSIsInVybENvbnRleHRNZXRhZGF0YUZyb21WZXJ0ZXgiLCJjaGVja3BvaW50RnJvbVZlcnRleCIsImZyb21DaGVja3BvaW50SWQiLCJmcm9tRXBvY2giLCJmcm9tU3RlcCIsImNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJjb250ZW50VG9WZXJ0ZXgiLCJjb21wdXRlVG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4IiwiZnJvbVRva2Vuc0luZm8iLCJjb21wdXRlclVzZVRvTWxkZXYkMSIsImNvbXB1dGVyVXNlVG9WZXJ0ZXgiLCJjb250ZW50RW1iZWRkaW5nRnJvbU1sZGV2IiwiY29udGVudEVtYmVkZGluZ0Zyb21WZXJ0ZXgiLCJmcm9tU3RhdGlzdGljcyIsImNvbnRlbnRFbWJlZGRpbmdTdGF0aXN0aWNzRnJvbVZlcnRleCIsImZyb21UcnVuY2F0ZWQiLCJwYXJ0RnJvbU1sZGV2IiwicGFydEZyb21WZXJ0ZXgiLCJjb250ZW50VG9NbGRldiQxIiwicGFydFRvTWxkZXYkMSIsInBhcnRUb1ZlcnRleCIsImNvbnRyb2xSZWZlcmVuY2VDb25maWdUb1ZlcnRleCIsImZyb21Db250cm9sVHlwZSIsImZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbiIsImNvdW50VG9rZW5zQ29uZmlnVG9NbGRldiIsImNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgiLCJ0b29sVG9WZXJ0ZXgiLCJjb3VudFRva2Vuc1BhcmFtZXRlcnNUb01sZGV2IiwiY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbVRvdGFsVG9rZW5zIiwiY291bnRUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgiLCJkZWxldGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2IiwiZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJkZWxldGVNb2RlbFJlc3BvbnNlRnJvbU1sZGV2IiwiZGVsZXRlTW9kZWxSZXNwb25zZUZyb21WZXJ0ZXgiLCJkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQxIiwiZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvVmVydGV4IiwiZWRpdEltYWdlQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tT3V0cHV0R2NzVXJpIiwiZnJvbU5lZ2F0aXZlUHJvbXB0IiwiZnJvbU51bWJlck9mSW1hZ2VzIiwiZnJvbUd1aWRhbmNlU2NhbGUiLCJmcm9tU2FmZXR5RmlsdGVyTGV2ZWwiLCJmcm9tUGVyc29uR2VuZXJhdGlvbiIsImZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyIsImZyb21JbmNsdWRlUmFpUmVhc29uIiwiZnJvbUxhbmd1YWdlIiwiZnJvbU91dHB1dE1pbWVUeXBlIiwiZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSIsImZyb21BZGRXYXRlcm1hcmsiLCJmcm9tRWRpdE1vZGUiLCJmcm9tQmFzZVN0ZXBzIiwiZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgiLCJmcm9tUHJvbXB0IiwiZnJvbVJlZmVyZW5jZUltYWdlcyIsInJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleCIsImVkaXRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImZyb21HZW5lcmF0ZWRJbWFnZXMiLCJnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgiLCJlbWJlZENvbnRlbnRDb25maWdUb01sZGV2IiwiZW1iZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgiLCJmcm9tQXV0b1RydW5jYXRlIiwiZW1iZWRDb250ZW50TWV0YWRhdGFGcm9tTWxkZXYiLCJlbWJlZENvbnRlbnRNZXRhZGF0YUZyb21WZXJ0ZXgiLCJmcm9tQmlsbGFibGVDaGFyYWN0ZXJDb3VudCIsImVtYmVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50IiwiZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4IiwiZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tRW1iZWRkaW5ncyIsImVtYmVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCIsImVuZHBvaW50RnJvbVZlcnRleCIsImZyb21EZXBsb3llZE1vZGVsSWQiLCJlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgiLCJlbnRpdHlMYWJlbEZyb21WZXJ0ZXgiLCJmcm9tTGFiZWwiLCJmcm9tU2NvcmUiLCJmaWxlRGF0YUZyb21NbGRldiIsImZpbGVEYXRhRnJvbVZlcnRleCIsImZpbGVEYXRhVG9NbGRldiQxIiwiZmlsZURhdGFUb1ZlcnRleCIsImZ1bmN0aW9uQ2FsbEZyb21NbGRldiIsImZ1bmN0aW9uQ2FsbEZyb21WZXJ0ZXgiLCJmdW5jdGlvbkNhbGxUb01sZGV2JDEiLCJmdW5jdGlvbkNhbGxUb1ZlcnRleCIsImZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYiLCJmdW5jdGlvbkNhbGxpbmdDb25maWdUb1ZlcnRleCIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDEiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgiLCJnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2Iiwic2NoZW1hVG9NbGRldiIsInNhZmV0eVNldHRpbmdUb01sZGV2IiwidG9vbFRvTWxkZXYkMSIsInRvb2xDb25maWdUb01sZGV2Iiwic3BlZWNoQ29uZmlnVG9NbGRldiQxIiwidGhpbmtpbmdDb25maWdUb01sZGV2JDEiLCJpbWFnZUNvbmZpZ1RvTWxkZXYiLCJnZW5lcmF0ZUNvbnRlbnRDb25maWdUb1ZlcnRleCIsInNjaGVtYVRvVmVydGV4IiwiZnJvbVJvdXRpbmdDb25maWciLCJmcm9tTW9kZWxTZWxlY3Rpb25Db25maWciLCJtb2RlbFNlbGVjdGlvbkNvbmZpZ1RvVmVydGV4Iiwic2FmZXR5U2V0dGluZ1RvVmVydGV4IiwidG9vbENvbmZpZ1RvVmVydGV4IiwiZnJvbUxhYmVscyIsInNwZWVjaENvbmZpZ1RvVmVydGV4IiwiZnJvbUF1ZGlvVGltZXN0YW1wIiwidGhpbmtpbmdDb25maWdUb1ZlcnRleCIsImltYWdlQ29uZmlnVG9WZXJ0ZXgiLCJnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsImdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2IiwiZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4IiwiZ2VuZXJhdGVJbWFnZXNDb25maWdUb01sZGV2IiwiZnJvbUltYWdlU2l6ZSIsImdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tRW5oYW5jZVByb21wdCIsImdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYiLCJnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb1ZlcnRleCIsImdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYiLCJnZW5lcmF0ZWRJbWFnZUZyb21NbGRldiIsImZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMiLCJzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2IiwiZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgiLCJzYWZldHlBdHRyaWJ1dGVzRnJvbVZlcnRleCIsImdlbmVyYXRlVmlkZW9zQ29uZmlnVG9NbGRldiIsImZyb21OdW1iZXJPZlZpZGVvcyIsImZyb21EdXJhdGlvblNlY29uZHMiLCJmcm9tUmVzb2x1dGlvbiIsImdlbmVyYXRlVmlkZW9zQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tUHVic3ViVG9waWMiLCJmcm9tR2VuZXJhdGVBdWRpbyIsImZyb21MYXN0RnJhbWUiLCJpbWFnZVRvVmVydGV4IiwidmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlSW1hZ2VUb1ZlcnRleCIsImZyb21NYXNrIiwidmlkZW9HZW5lcmF0aW9uTWFza1RvVmVydGV4IiwiZnJvbUNvbXByZXNzaW9uUXVhbGl0eSIsImdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2IiwiZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldiIsImdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleCIsImdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4IiwiZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21JbWFnZSIsImltYWdlVG9NbGRldiIsImdlbmVyYXRlVmlkZW9zU291cmNlVG9NbGRldiIsImdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvVmVydGV4IiwidmlkZW9Ub1ZlcnRleCIsImdlbmVyYXRlVmlkZW9zU291cmNlVG9WZXJ0ZXgiLCJnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiIsImdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCIsImltYWdlRnJvbU1sZGV2IiwiZnJvbVJhaUZpbHRlcmVkUmVhc29uIiwiZnJvbVNhZmV0eUF0dHJpYnV0ZXMiLCJpbWFnZUZyb21WZXJ0ZXgiLCJmcm9tRW5oYW5jZWRQcm9tcHQiLCJnZW5lcmF0ZWRJbWFnZU1hc2tGcm9tVmVydGV4IiwidmlkZW9Gcm9tTWxkZXYiLCJ2aWRlb0Zyb21WZXJ0ZXgiLCJnZXRNb2RlbFBhcmFtZXRlcnNUb01sZGV2IiwiZ2V0TW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJnb29nbGVNYXBzVG9WZXJ0ZXgiLCJnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDEiLCJnb29nbGVTZWFyY2hSZXRyaWV2YWxUb1ZlcnRleCIsImdvb2dsZVNlYXJjaFRvTWxkZXYkMSIsImludGVydmFsVG9NbGRldiQxIiwiZ29vZ2xlU2VhcmNoVG9WZXJ0ZXgiLCJpbnRlcnZhbFRvVmVydGV4IiwibGF0TG5nVG9NbGRldiIsImxhdExuZ1RvVmVydGV4IiwibGlzdE1vZGVsc0NvbmZpZ1RvTWxkZXYiLCJmcm9tUXVlcnlCYXNlIiwibGlzdE1vZGVsc0NvbmZpZ1RvVmVydGV4IiwibGlzdE1vZGVsc1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdE1vZGVsc1BhcmFtZXRlcnNUb1ZlcnRleCIsImxpc3RNb2RlbHNSZXNwb25zZUZyb21NbGRldiIsImZyb21Nb2RlbHMiLCJtb2RlbEZyb21NbGRldiIsImxpc3RNb2RlbHNSZXNwb25zZUZyb21WZXJ0ZXgiLCJtb2RlbEZyb21WZXJ0ZXgiLCJtYXNrUmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tTWFza01vZGUiLCJmcm9tU2VnbWVudGF0aW9uQ2xhc3NlcyIsImZyb21NYXNrRGlsYXRpb24iLCJmcm9tVmVyc2lvbiIsImZyb21UdW5lZE1vZGVsSW5mbyIsInR1bmVkTW9kZWxJbmZvRnJvbU1sZGV2IiwiZnJvbUlucHV0VG9rZW5MaW1pdCIsImZyb21PdXRwdXRUb2tlbkxpbWl0IiwiZnJvbVN1cHBvcnRlZEFjdGlvbnMiLCJmcm9tRW5kcG9pbnRzIiwidHVuZWRNb2RlbEluZm9Gcm9tVmVydGV4IiwiZnJvbURlZmF1bHRDaGVja3BvaW50SWQiLCJmcm9tQ2hlY2twb2ludHMiLCJmcm9tRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UiLCJtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMSIsInNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMSIsInZpZGVvTWV0YWRhdGFGcm9tTWxkZXYiLCJ2aWRlb01ldGFkYXRhRnJvbVZlcnRleCIsInZpZGVvTWV0YWRhdGFUb01sZGV2JDEiLCJ2aWRlb01ldGFkYXRhVG9WZXJ0ZXgiLCJwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldiQxIiwicHJlYnVpbHRWb2ljZUNvbmZpZ1RvVmVydGV4IiwicHJvZHVjdEltYWdlVG9WZXJ0ZXgiLCJmcm9tUHJvZHVjdEltYWdlIiwicmVjb250ZXh0SW1hZ2VDb25maWdUb1ZlcnRleCIsInJlY29udGV4dEltYWdlUGFyYW1ldGVyc1RvVmVydGV4IiwicmVjb250ZXh0SW1hZ2VTb3VyY2VUb1ZlcnRleCIsInJlY29udGV4dEltYWdlUmVzcG9uc2VGcm9tVmVydGV4IiwiZnJvbVBlcnNvbkltYWdlIiwiZnJvbVByb2R1Y3RJbWFnZXMiLCJmcm9tUmVmZXJlbmNlSW1hZ2UiLCJmcm9tUmVmZXJlbmNlSWQiLCJmcm9tUmVmZXJlbmNlVHlwZSIsImZyb21NYXNrSW1hZ2VDb25maWciLCJmcm9tQ29udHJvbEltYWdlQ29uZmlnIiwiZnJvbVN0eWxlSW1hZ2VDb25maWciLCJzdHlsZVJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4IiwiZnJvbVN1YmplY3RJbWFnZUNvbmZpZyIsInN1YmplY3RSZWZlcmVuY2VDb25maWdUb1ZlcnRleCIsInJldHJpZXZhbENvbmZpZ1RvTWxkZXYiLCJyZXRyaWV2YWxDb25maWdUb1ZlcnRleCIsImZyb21DYXRlZ29yaWVzIiwiZnJvbVNjb3JlcyIsImZyb21Db250ZW50VHlwZSIsImZyb21NZXRob2QiLCJzY3JpYmJsZUltYWdlVG9WZXJ0ZXgiLCJzZWdtZW50SW1hZ2VDb25maWdUb1ZlcnRleCIsImZyb21NYXhQcmVkaWN0aW9ucyIsImZyb21Db25maWRlbmNlVGhyZXNob2xkIiwiZnJvbUJpbmFyeUNvbG9yVGhyZXNob2xkIiwic2VnbWVudEltYWdlUGFyYW1ldGVyc1RvVmVydGV4Iiwic2VnbWVudEltYWdlU291cmNlVG9WZXJ0ZXgiLCJzZWdtZW50SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgiLCJmcm9tR2VuZXJhdGVkTWFza3MiLCJmcm9tU2NyaWJibGVJbWFnZSIsInZvaWNlQ29uZmlnVG9NbGRldiQxIiwidm9pY2VDb25maWdUb1ZlcnRleCIsImZyb21TdHlsZURlc2NyaXB0aW9uIiwiZnJvbVN1YmplY3RUeXBlIiwiZnJvbVN1YmplY3REZXNjcmlwdGlvbiIsInVybENvbnRleHRUb01sZGV2JDEiLCJ1cmxDb250ZXh0VG9WZXJ0ZXgiLCJmcm9tQmFzZU1vZGVsIiwidXBkYXRlTW9kZWxDb25maWdUb01sZGV2IiwidXBkYXRlTW9kZWxDb25maWdUb1ZlcnRleCIsInVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYiLCJ1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCIsInVwc2NhbGVJbWFnZUFQSUNvbmZpZ0ludGVybmFsVG9WZXJ0ZXgiLCJmcm9tRW5oYW5jZUlucHV0SW1hZ2UiLCJmcm9tSW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3IiLCJ1cHNjYWxlSW1hZ2VBUElQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleCIsImZyb21VcHNjYWxlRmFjdG9yIiwidXBzY2FsZUltYWdlUmVzcG9uc2VGcm9tVmVydGV4IiwidXJsTWV0YWRhdGFGcm9tTWxkZXYiLCJ1cmxNZXRhZGF0YUZyb21WZXJ0ZXgiLCJDT05URU5UX1RZUEVfSEVBREVSIiwiU0VSVkVSX1RJTUVPVVRfSEVBREVSIiwiVVNFUl9BR0VOVF9IRUFERVIiLCJHT09HTEVfQVBJX0NMSUVOVF9IRUFERVIiLCJTREtfVkVSU0lPTiIsIkxJQlJBUllfTEFCRUwiLCJWRVJURVhfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiIsIkdPT0dMRV9BSV9BUElfREVGQVVMVF9WRVJTSU9OIiwicmVzcG9uc2VMaW5lUkUiLCJBcGlDbGllbnQiLCJvcHRzIiwiY2xpZW50T3B0aW9ucyIsInByb2plY3QiLCJsb2NhdGlvbiIsImFwaUtleSIsImluaXRIdHRwT3B0aW9ucyIsImFwaVZlcnNpb24iLCJiYXNlVXJsRnJvbVByb2plY3RMb2NhdGlvbiIsIm5vcm1hbGl6ZUF1dGhQYXJhbWV0ZXJzIiwiZ2V0RGVmYXVsdEhlYWRlcnMiLCJwYXRjaEh0dHBPcHRpb25zIiwiZ2V0QXBpVmVyc2lvbiIsImdldFJlcXVlc3RVcmwiLCJnZXRSZXF1ZXN0VXJsSW50ZXJuYWwiLCJnZXRIZWFkZXJzIiwidXJsRWxlbWVudCIsImpvaW4iLCJnZXRCYXNlUmVzb3VyY2VQYXRoIiwiZ2V0QXBpS2V5IiwiZ2V0V2Vic29ja2V0QmFzZVVybCIsInVybFBhcnRzIiwiVVJMIiwicHJvdG9jb2wiLCJzZXRCYXNlVXJsIiwidXJsIiwiY29uc3RydWN0VXJsIiwicHJlcGVuZFByb2plY3RMb2NhdGlvbiIsInNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aCIsInBhdGNoZWRIdHRwT3B0aW9ucyIsInNlYXJjaFBhcmFtcyIsImFwcGVuZCIsInJlcXVlc3RJbml0IiwiaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0IiwidW5hcnlBcGlDYWxsIiwiYmFzZUh0dHBPcHRpb25zIiwicmVxdWVzdEh0dHBPcHRpb25zIiwicGFyc2UiLCJyZXF1ZXN0U3RyZWFtIiwic2V0Iiwic3RyZWFtQXBpQ2FsbCIsInRpbWVvdXQiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWwiLCJ0aW1lb3V0SGFuZGxlIiwic2V0VGltZW91dCIsImFib3J0IiwidW5yZWYiLCJhZGRFdmVudExpc3RlbmVyIiwiZXh0cmFCb2R5IiwiaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQiLCJnZXRIZWFkZXJzSW50ZXJuYWwiLCJhcGlDYWxsIiwibWV0aG9kIiwidGhyb3dFcnJvcklmTm90T0siLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWZmZXIiLCJyZWFkIiwidHJpbSIsImNodW5rU3RyaW5nIiwiZGVjb2RlIiwic3RyZWFtIiwiY2h1bmtKc29uIiwiZXJyb3JKc29uIiwiZXJyb3JNZXNzYWdlIiwiYXBpRXJyb3IiLCJwcm9jZXNzZWRDaHVua1N0cmluZyIsInBhcnRpYWxSZXNwb25zZSIsIlJlc3BvbnNlIiwic3RhdHVzVGV4dCIsInJlbGVhc2VMb2NrIiwiZmV0Y2giLCJ2ZXJzaW9uSGVhZGVyVmFsdWUiLCJ1c2VyQWdlbnRFeHRyYSIsIkhlYWRlcnMiLCJNYXRoIiwiY2VpbCIsImF1dGgiLCJhZGRBdXRoSGVhZGVycyIsImZpbGVUb1VwbG9hZCIsInVwbG9hZGVyIiwiZmlsZVN0YXQiLCJzdGF0Iiwic2l6ZUJ5dGVzIiwic2l6ZSIsInVwbG9hZFVybCIsImZldGNoVXBsb2FkVXJsIiwiZG93bmxvYWRlciIsIm9rIiwiZXJyb3JCb2R5IiwiQmxvYiIsImN1cnJlbnRCb2R5T2JqZWN0IiwicGFyc2VkQm9keSIsImRlZXBNZXJnZSIsInRhcmdldCIsInNvdXJjZSIsInNvdXJjZVZhbHVlIiwidGFyZ2V0VmFsdWUiLCJtZXJnZWRCb2R5IiwiTUNQX0xBQkVMIiwiaGFzTWNwVG9vbFVzYWdlRnJvbU1jcFRvVG9vbCIsImhhc01jcFRvb2xVc2FnZSIsImlzTWNwQ2FsbGFibGVUb29sIiwic2V0TWNwVXNhZ2VIZWFkZXIiLCJleGlzdGluZ0hlYWRlciIsInRyaW1TdGFydCIsIm9iamVjdCIsIk1jcENhbGxhYmxlVG9vbCIsImxpc3RBbGxUb29scyIsIm1jcENsaWVudCIsIm1heFRvb2xzIiwibGlzdEFsbFRvb2xzXzEiLCJjdXJzb3IiLCJudW1Ub29scyIsInQiLCJsaXN0VG9vbHMiLCJuZXh0Q3Vyc29yIiwibWNwQ2xpZW50cyIsImZ1bmN0aW9uTmFtZVRvTWNwQ2xpZW50IiwiaW5pdGlhbGl6ZSIsImZ1bmN0aW9uTWFwIiwiY2FsbFRvb2wiLCJmdW5jdGlvbkNhbGxSZXNwb25zZVBhcnRzIiwicmVxdWVzdE9wdGlvbnMiLCJjYWxsVG9vbFJlc3BvbnNlIiwiaXNFcnJvciIsImlzTWNwQ2xpZW50IiwibWNwVG9Ub29sIiwibWF5YmVDb25maWciLCJoYW5kbGVXZWJTb2NrZXRNZXNzYWdlJDEiLCJvbm1lc3NhZ2UiLCJldmVudCIsInNlcnZlck1lc3NhZ2UiLCJMaXZlTXVzaWMiLCJ3ZWJTb2NrZXRGYWN0b3J5IiwiY29ubmVjdCIsIndlYnNvY2tldEJhc2VVcmwiLCJtYXBUb0hlYWRlcnMkMSIsIm9ub3BlblJlc29sdmUiLCJvbm9wZW5Qcm9taXNlIiwiY2FsbGJhY2tzIiwib25vcGVuQXdhaXRlZENhbGxiYWNrIiwid2Vic29ja2V0Q2FsbGJhY2tzIiwib25vcGVuIiwib25lcnJvciIsIm9uY2xvc2UiLCJjb25uIiwiaGVhZGVyc1RvTWFwJDEiLCJzZXR1cCIsImNsaWVudE1lc3NhZ2UiLCJzZW5kIiwiTGl2ZU11c2ljU2Vzc2lvbiIsInNldFdlaWdodGVkUHJvbXB0cyIsIndlaWdodGVkUHJvbXB0cyIsInNldFdlaWdodGVkUHJvbXB0c1BhcmFtZXRlcnMiLCJjbGllbnRDb250ZW50Iiwic2V0TXVzaWNHZW5lcmF0aW9uQ29uZmlnIiwibXVzaWNHZW5lcmF0aW9uQ29uZmlnIiwic2V0Q29uZmlnUGFyYW1ldGVycyIsInNlbmRQbGF5YmFja0NvbnRyb2wiLCJwbGF5YmFja0NvbnRyb2wiLCJwbGF5IiwiUExBWSIsInBhdXNlIiwiUEFVU0UiLCJzdG9wIiwiU1RPUCIsInJlc2V0Q29udGV4dCIsIlJFU0VUX0NPTlRFWFQiLCJjbG9zZSIsImhlYWRlck1hcCIsImZvckVhY2giLCJGVU5DVElPTl9SRVNQT05TRV9SRVFVSVJFU19JRCIsImhhbmRsZVdlYlNvY2tldE1lc3NhZ2UiLCJqc29uRGF0YSIsIkFycmF5QnVmZmVyIiwiTGl2ZSIsIm11c2ljIiwiY2xpZW50SGVhZGVycyIsIm1hcFRvSGVhZGVycyIsImhlYWRlcnNUb01hcCIsInJlc3BvbnNlTW9kYWxpdGllcyIsIkFVRElPIiwiZ2VuZXJhdGlvbkNvbmZpZyIsImlucHV0VG9vbHMiLCJjb252ZXJ0ZWRUb29scyIsImlzQ2FsbGFibGVUb29sIiwiY2FsbGFibGVUb29sIiwibGl2ZUNvbm5lY3RQYXJhbWV0ZXJzIiwiU2Vzc2lvbiIsImRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyIsInR1cm5Db21wbGV0ZSIsInRMaXZlQ2xpZW50Q29udGVudCIsInR1cm5zIiwidExpdmVDbGllbnR0VG9vbFJlc3BvbnNlIiwidG9vbFJlc3BvbnNlIiwic2VuZENsaWVudENvbnRlbnQiLCJzZW5kUmVhbHRpbWVJbnB1dCIsInNlbmRUb29sUmVzcG9uc2UiLCJERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFMiLCJzaG91bGREaXNhYmxlQWZjIiwiYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nIiwiZGlzYWJsZSIsImNhbGxhYmxlVG9vbHNQcmVzZW50IiwibWF4Q2FsbHMiLCJtYXhpbXVtUmVtb3RlQ2FsbHMiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJoYXNDYWxsYWJsZVRvb2xzIiwic29tZSIsImhhc05vbkNhbGxhYmxlVG9vbHMiLCJzaG91bGRBcHBlbmRBZmNIaXN0b3J5IiwiaWdub3JlQ2FsbEhpc3RvcnkiLCJNb2RlbHMiLCJ0cmFuc2Zvcm1lZFBhcmFtcyIsInByb2Nlc3NQYXJhbXNNYXliZUFkZE1jcFVzYWdlIiwibWF5YmVNb3ZlVG9SZXNwb25zZUpzb25TY2hlbSIsImdlbmVyYXRlQ29udGVudEludGVybmFsIiwiZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQiLCJtYXhSZW1vdGVDYWxscyIsInJlbW90ZUNhbGxzIiwicmVzcG9uc2VDb250ZW50IiwiZnVuY3Rpb25SZXNwb25zZVBhcnRzIiwiZ2VuZXJhdGVDb250ZW50U3RyZWFtSW50ZXJuYWwiLCJwcm9jZXNzQWZjU3RyZWFtIiwiZ2VuZXJhdGVJbWFnZXMiLCJnZW5lcmF0ZUltYWdlc0ludGVybmFsIiwicG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzIiwiZ2VuZXJhdGVkSW1hZ2VzIiwiZ2VuZXJhdGVkSW1hZ2UiLCJzYWZldHlBdHRyaWJ1dGVzIiwiY29udGVudFR5cGUiLCJkZWZhdWx0Q29uZmlnIiwicXVlcnlCYXNlIiwiYWN0dWFsQ29uZmlnIiwiYWN0dWFsUGFyYW1zIiwiUEFHRURfSVRFTV9NT0RFTFMiLCJlZGl0SW1hZ2UiLCJwcm9tcHQiLCJyZWZlcmVuY2VJbWFnZXMiLCJpbWciLCJlZGl0SW1hZ2VJbnRlcm5hbCIsInVwc2NhbGVJbWFnZSIsImFwaUNvbmZpZyIsIm51bWJlck9mSW1hZ2VzIiwibW9kZSIsImFwaVBhcmFtcyIsImltYWdlIiwidXBzY2FsZUZhY3RvciIsInVwc2NhbGVJbWFnZUludGVybmFsIiwiZ2VuZXJhdGVWaWRlb3MiLCJnZW5lcmF0ZVZpZGVvc0ludGVybmFsIiwicmVzcG9uc2VTY2hlbWEiLCJ0cmFuc2Zvcm1lZFRvb2xzIiwiYWxsIiwibmV3UGFyYW1zIiwibmV3SGVhZGVycyIsImluaXRBZmNUb29sc01hcCIsImFmY1Rvb2xzIiwiTWFwIiwidG9vbERlY2xhcmF0aW9uIiwiZGVjbGFyYXRpb24iLCJ3ZXJlRnVuY3Rpb25zQ2FsbGVkIiwicmVtb3RlQ2FsbENvdW50IiwiYWZjVG9vbHNNYXAiLCJtb2RlbHMiLCJyZXNwb25zZUNvbnRlbnRzIiwicmVzcG9uc2VfMSIsInJlc3BvbnNlXzFfMSIsInJlc3BvbnNlUGFydHMiLCJ0eXBlZFJlc3BvbnNlQ2h1bmsiLCJuZXdDb250ZW50cyIsInVwZGF0ZWRDb250ZW50cyIsImVfMiIsImFwaVJlc3BvbnNlXzEiLCJhcGlSZXNwb25zZV8xXzEiLCJlXzJfMSIsImVfMyIsImFwaVJlc3BvbnNlXzIiLCJhcGlSZXNwb25zZV8yXzEiLCJlXzNfMSIsImVtYmVkQ29udGVudCIsInJlY29udGV4dEltYWdlIiwic2VnbWVudEltYWdlIiwiY291bnRUb2tlbnMiLCJjb21wdXRlVG9rZW5zIiwiT3BlcmF0aW9ucyIsImdldFZpZGVvc09wZXJhdGlvbiIsInJhd09wZXJhdGlvbiIsImZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsIiwib3BlcmF0aW9uTmFtZSIsImdldFZpZGVvc09wZXJhdGlvbkludGVybmFsIiwiYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9NbGRldiIsImF1dGhUb2tlbkZyb21NbGRldiIsImF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9NbGRldiIsImJsb2JUb01sZGV2IiwiY29tcHV0ZXJVc2VUb01sZGV2IiwiY29udGVudFRvTWxkZXYiLCJwYXJ0VG9NbGRldiIsImNvbnRleHRXaW5kb3dDb21wcmVzc2lvbkNvbmZpZ1RvTWxkZXYiLCJzbGlkaW5nV2luZG93VG9NbGRldiIsImNyZWF0ZUF1dGhUb2tlbkNvbmZpZ1RvTWxkZXYiLCJmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUiLCJmcm9tVXNlcyIsImZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzIiwibGl2ZUNvbm5lY3RDb25zdHJhaW50c1RvTWxkZXYiLCJmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMiLCJjcmVhdGVBdXRoVG9rZW5QYXJhbWV0ZXJzVG9NbGRldiIsImR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2IiwiZmlsZURhdGFUb01sZGV2IiwiZnVuY3Rpb25DYWxsVG9NbGRldiIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2IiwiZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiIsImdvb2dsZVNlYXJjaFRvTWxkZXYiLCJpbnRlcnZhbFRvTWxkZXYiLCJsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYiLCJzcGVlY2hDb25maWdUb01sZGV2IiwidGhpbmtpbmdDb25maWdUb01sZGV2IiwidG9vbFRvTWxkZXYiLCJzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYiLCJyZWFsdGltZUlucHV0Q29uZmlnVG9NbGRldiIsInByb2FjdGl2aXR5Q29uZmlnVG9NbGRldiIsIm11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiIsInNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYiLCJ2aWRlb01ldGFkYXRhVG9NbGRldiIsInByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2Iiwidm9pY2VDb25maWdUb01sZGV2IiwidXJsQ29udGV4dFRvTWxkZXYiLCJnZXRGaWVsZE1hc2tzIiwiZmllbGRzIiwiZmllbGQiLCJrayIsImNvbnZlcnRCaWRpU2V0dXBUb1Rva2VuU2V0dXAiLCJzZXR1cEZvck1hc2tHZW5lcmF0aW9uIiwiYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUiLCJpbm5lclNldHVwIiwicHJlRXhpc3RpbmdGaWVsZE1hc2siLCJnZW5lcmF0ZWRNYXNrRnJvbUJpZGkiLCJsb2NrQWRkaXRpb25hbEZpZWxkcyIsImdlbmVyYXRpb25Db25maWdGaWVsZHMiLCJtYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmciLCJmaW5hbE1hc2tQYXJ0cyIsIlRva2VucyIsInRyYW5zZm9ybWVkQm9keSIsIkdPT0dMRV9BUElfS0VZX0hFQURFUiIsIlJFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRSIsIk5vZGVBdXRoIiwidmVydGV4QXV0aE9wdGlvbnMiLCJidWlsZEdvb2dsZUF1dGhPcHRpb25zIiwiZ29vZ2xlQXV0aE9wdGlvbnMiLCJnb29nbGVBdXRoIiwiYWRkS2V5SGVhZGVyIiwiYWRkR29vZ2xlQXV0aEhlYWRlcnMiLCJhdXRoSGVhZGVycyIsImdldFJlcXVlc3RIZWFkZXJzIiwiYXV0aE9wdGlvbnMiLCJzY29wZXMiLCJOb2RlRG93bmxvYWRlciIsImRvd25sb2FkUGF0aCIsIndyaXRlciIsImZyb21XZWIiLCJwaXBlIiwiZW5jb2RpbmciLCJ2aWRlb0J5dGVzIiwiTm9kZVdlYlNvY2tldEZhY3RvcnkiLCJOb2RlV2ViU29ja2V0Iiwid3MiLCJXZWJTb2NrZXQiLCJjYW5jZWxUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleCIsImNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvTWxkZXYiLCJmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lIiwiZnJvbUVwb2NoQ291bnQiLCJmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciIsImZyb21CYXRjaFNpemUiLCJmcm9tTGVhcm5pbmdSYXRlIiwiY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tVmFsaWRhdGlvbkRhdGFzZXQiLCJ0dW5pbmdWYWxpZGF0aW9uRGF0YXNldFRvVmVydGV4IiwiZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSIsImZyb21BZGFwdGVyU2l6ZSIsImNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9NbGRldiIsImZyb21QcmVUdW5lZE1vZGVsIiwiZnJvbVRyYWluaW5nRGF0YXNldCIsInR1bmluZ0RhdGFzZXRUb01sZGV2IiwiY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb1ZlcnRleCIsInR1bmluZ0RhdGFzZXRUb1ZlcnRleCIsImdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2IiwiZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4IiwibGlzdFR1bmluZ0pvYnNDb25maWdUb01sZGV2IiwibGlzdFR1bmluZ0pvYnNDb25maWdUb1ZlcnRleCIsImxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0VHVuaW5nSm9ic1BhcmFtZXRlcnNUb1ZlcnRleCIsImxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tVHVuaW5nSm9icyIsInR1bmluZ0pvYkZyb21NbGRldiIsImxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tVmVydGV4IiwidHVuaW5nSm9iRnJvbVZlcnRleCIsInR1bmVkTW9kZWxDaGVja3BvaW50RnJvbVZlcnRleCIsImZyb21FbmRwb2ludCIsInR1bmVkTW9kZWxGcm9tTWxkZXYiLCJ0dW5lZE1vZGVsRnJvbVZlcnRleCIsImZyb21FeGFtcGxlcyIsInR1bmluZ0V4YW1wbGVUb01sZGV2IiwiZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSIsImZyb21UZXh0SW5wdXQiLCJmcm9tT3V0cHV0IiwiZnJvbVR1bmVkTW9kZWwiLCJmcm9tQ3VzdG9tQmFzZU1vZGVsIiwiZnJvbUV4cGVyaW1lbnQiLCJmcm9tT3V0cHV0VXJpIiwiZnJvbVBpcGVsaW5lSm9iIiwiZnJvbVNlcnZpY2VBY2NvdW50IiwiZnJvbVZlb1R1bmluZ1NwZWMiLCJmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMiLCJmcm9tVHVuaW5nRGF0YVN0YXRzIiwiZnJvbUVuY3J5cHRpb25TcGVjIiwiZnJvbVBhcnRuZXJNb2RlbFR1bmluZ1NwZWMiLCJ0dW5pbmdPcGVyYXRpb25Gcm9tTWxkZXYiLCJUdW5pbmdzIiwiZ2V0SW50ZXJuYWwiLCJQQUdFRF9JVEVNX1RVTklOR19KT0JTIiwidHVuZSIsImJhc2VNb2RlbCIsInByZVR1bmVkTW9kZWwiLCJ0dW5lZE1vZGVsTmFtZSIsInByZVR1bmVkTW9kZWxDaGVja3BvaW50SWQiLCJjaGVja3BvaW50SWQiLCJwYXJhbXNQcml2YXRlIiwidHVuZUludGVybmFsIiwidHVuZU1sZGV2SW50ZXJuYWwiLCJ0dW5pbmdKb2IiLCJKT0JfU1RBVEVfUVVFVUVEIiwiTUFYX0NIVU5LX1NJWkUiLCJNQVhfUkVUUllfQ09VTlQiLCJJTklUSUFMX1JFVFJZX0RFTEFZX01TIiwiREVMQVlfTVVMVElQTElFUiIsIlhfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRCIsInVwbG9hZEJsb2IiLCJmaWxlU2l6ZSIsIm9mZnNldCIsInVwbG9hZENvbW1hbmQiLCJjaHVua1NpemUiLCJtaW4iLCJyZXRyeUNvdW50IiwiY3VycmVudERlbGF5TXMiLCJzbGVlcCIsInJlc3BvbnNlSnNvbiIsImdldEJsb2JTdGF0IiwibXMiLCJyZXNvbHZlUHJvbWlzZSIsIk5vZGVVcGxvYWRlciIsIm9yaWdpbmFsU3RhdCIsImluZmVyTWltZVR5cGUiLCJ1cGxvYWRGaWxlRnJvbVBhdGgiLCJmaWxlUGF0aCIsImZpbGVFeHRlbnNpb24iLCJsYXN0SW5kZXhPZiIsIm1pbWVUeXBlcyIsInRvTG93ZXJDYXNlIiwiZmlsZUhhbmRsZSIsIm9wZW4iLCJVaW50OEFycmF5IiwiYnl0ZXNSZWFkIiwiTEFOR1VBR0VfTEFCRUxfUFJFRklYIiwiR29vZ2xlR2VuQUkiLCJnZXRCb29sZWFuRW52IiwiZW52QXBpS2V5IiwiZ2V0QXBpS2V5RnJvbUVudiIsImVudlByb2plY3QiLCJnZXRFbnYiLCJlbnZMb2NhdGlvbiIsImNyZWRlbnRpYWxzIiwiZGVidWciLCJwcm9jZXNzIiwidmVyc2lvbiIsImxpdmUiLCJiYXRjaGVzIiwiY2hhdHMiLCJjYWNoZXMiLCJmaWxlcyIsIm9wZXJhdGlvbnMiLCJhdXRoVG9rZW5zIiwidHVuaW5ncyIsImVudiIsInN0cmluZ1RvQm9vbGVhbiIsInN0ciIsImVudkdvb2dsZUFwaUtleSIsImVudkdlbWluaUFwaUtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google/genai/dist/node/index.mjs\n");

/***/ })

};
;